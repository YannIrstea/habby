%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=49336sp\relax

\usepackage[margin=1in,marginparwidth=0.5in]{geometry}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}

\usepackage{multirow}
\usepackage{eqparbox}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing }}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}


\title{HABBY Documentation}
\date{Jan 09, 2017}
\release{1}
\author{Diane von Gunten, Yann Le Coarer and Fabrice Zaoui}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


HABBY is a program to estimate the habitat of fish using various hydrological models and preference curve as input.


\chapter{How to execute HABBY}
\label{\detokenize{index:how-to-execute-habby}}\label{\detokenize{index:welcome-to-habby-s-documentation}}\begin{description}
\item[{To execute HABBY:}] \leavevmode\begin{itemize}
\item {} 
Go to folder which contains habby.py using the command line.

\item {} 
Open the command line and type python habby.py.

\end{itemize}

\end{description}

The python version should be 3.4. HABBY should also function with most of the python 3 distributions.

If a module is missing, it is possible to install it using pip (``pip install -m \sphinxstyleemphasis{module\_name}''). Obviously, pip needs to installed, which should be done by default in python 3.4. If you want to be sure to have the same version of the module than originally, go to the folder zen\_file/wheele with the command line and install the missing module from there (something similar to ``pip install -m \sphinxstyleemphasis{.whl}''). Not all modules are in this folder, only the ones which were difficult to install.


\chapter{Main(   ) and source code}
\label{\detokenize{index:main-and-source-code}}
The source code is separated in two folders: one folder which contain the code source for the graphical user interface (GUI) and one folder for the rest of the code source.

The dependency between the different part of the source code can be visualized in the mindmap real\_GUI.xmind (xmind should be installed).

The main of HABBY is habby.py. It has the usual form for an application using PyQt5.  The main() creates an application of QWidget and call the Main\_Windows class, which we will discuss shortly. The last line closes the application.


\chapter{Graphical interface}
\label{\detokenize{index:graphical-interface}}
Here is the list of all modules contains in the src\_GUI folder.


\section{Main\_windows of HABBY}
\label{\detokenize{index:main-windows-of-habby}}
in src\_GUI/Main\_Windows\_1.py
\phantomsection\label{\detokenize{index:module-src_GUI}}\index{src\_GUI (module)}\phantomsection\label{\detokenize{index:module-src_GUI.Main_windows_1}}\index{src\_GUI.Main\_windows\_1 (module)}\index{CentralW (class in src\_GUI.Main\_windows\_1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.Main\_windows\_1.}\sphinxbfcode{CentralW}}{\emph{rech}, \emph{path\_prj}, \emph{name\_prj}}{}
This class create the different tabs of the programm, which are then used as the central widget by the class
MainWindows.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{rech} -- A bollean which is True if the tabs for the ``research option'' are shown. False otherwise.

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- A string with the path to the project xml file

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- A string with the name of the project

\end{itemize}

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

In the attribute list, there are a series of name which finish by “tab” such as stathab\_tab or output\_tab. Each of
these names corresponds to one tab and a new name should be added to the attributes to add a new tab.

During the creation of the class, each tab is created. Then, the signals to show the figures are connected between this
class and all the children classes which need it (often this are the classes used to load the hydrological data). When a
class emits the signal “show\_fig”, CentralW collect this signal and show the figure, using the showfig function.

Show\_fig is mostly a “plt.show()”. To avoid problem between matplotlib and PyQt, it is however important that
matplotlib use the backend “Qt5Agg” in the .py where the “plt.plot” is called. Practically, this means modifying
the matplotlib import.

Showfig shows only one figure. To show all existing figures, one can call the function show\_fig2 from the menu.
Show\_fig2 call the instance child\_win of the class ShowImageW to open a new Windows with all figure. However,
this would only show the figure without any option for the zoom.

Then we call a function which connects all the signals from each class which need to write into the log. It is a good
policy to create a “send\_log” signal for each new important class. As there are a lot of signal to connect, these
connections are written in the function “connect\_signal\_log”, where the signal for a new class can be added.

When this is done, the info for the general tab (created before) is filled. If the user has opened a project in HABBY
before, the name of the project and the other info related to it will be shown on the general tab. If the general
tab is modified in the class WelcomeW(), this part of the code which fill the general tab will probably needs to
be modified.

Finally, each tab is filled. The tabs have been created before, but there were empty. Now we fill each one with the
adequate widget. This is the link with many of the other classes that we describe below. Indeed, many of the widget
are based on more complicated classes created for example in hydro\_GUI\_2.py.

Then, we create an area under it for the log. Here HABBY will write various infos for the user. Two things to note
here: a) we should show the end of the scroll area. b) The size of the area should be controlled and not be
changing even if a lot of text appears. Hence, the setSizePolicy should be fixed.

The write\_log() and write\_log\_file() method are explained in the section about the log.
\index{connect\_signal\_log() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.connect_signal_log}}\pysiglinewithargsret{\sphinxbfcode{connect\_signal\_log}}{}{}
connect all the signal linked to the log. This is in a function only to improve lisibility.

\end{fulllineitems}

\index{init\_iu() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
A function to initilize an instance of CentralW. Called by \_\_init\_\_\_().

\end{fulllineitems}

\index{optfig() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.optfig}}\pysiglinewithargsret{\sphinxbfcode{optfig}}{}{}
A small function which open the output tab. It contains the different options for the figures.
Output should be the 6th tab, otherwise it will not work.

\end{fulllineitems}

\index{scrolldown() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.scrolldown}}\pysiglinewithargsret{\sphinxbfcode{scrolldown}}{}{}
Move the scroll bar to the bottow if the ScollArea is getting bigger

\end{fulllineitems}

\index{showfig() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.showfig}}\pysiglinewithargsret{\sphinxbfcode{showfig}}{}{}
A small function to show the last figure

\end{fulllineitems}

\index{showfig2() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.showfig2}}\pysiglinewithargsret{\sphinxbfcode{showfig2}}{}{}
A function to see all saved figures without possibility to zoom

\end{fulllineitems}

\index{write\_log() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.write_log}}\pysiglinewithargsret{\sphinxbfcode{write\_log}}{\emph{text\_log}}{}
A function to write the different log. Please read the section of the doc on the log.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{text\_log} -- the text which should be added to the log (a string)

\end{description}\end{quote}
\begin{itemize}
\item {} 
if text\_log start with \# -\textgreater{} added it to self.l2 (QLabel) and the .log file (comments)

\item {} 
if text\_log start with restart -\textgreater{} added it restart\_nameproject.txt

\item {} 
if text\_log start with WARNING -\textgreater{} added it to self.l2 (QLabel) and the .log file

\item {} 
if text\_log start with ERROR -\textgreater{} added it to self.l2 (QLabel) and the .log file

\item {} 
if text\_log start with py -\textgreater{} added to the .log file (python command)

\item {} 
if text\_log start with nothing -\textgreater{} just print to the Qlabel

\item {} 
if text\_log out from stdout -\textgreater{} added it to self.l2 (QLabel) and the .log file (comments)

\end{itemize}

if logon = false, do not write in log.txt

\end{fulllineitems}

\index{write\_log\_file() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.write_log_file}}\pysiglinewithargsret{\sphinxbfcode{write\_log\_file}}{\emph{text\_log}, \emph{pathname\_logfile}}{}
A function to write to the .log text. Called by write\_log.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{text\_log} -- the text to be written (string)

\item {} 
\sphinxstyleliteralstrong{pathname\_logfile} -- the path+name where the log is

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{EmptyTab (class in src\_GUI.Main\_windows\_1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.EmptyTab}}\pysigline{\sphinxstrong{class }\sphinxcode{src\_GUI.Main\_windows\_1.}\sphinxbfcode{EmptyTab}}
This class is  used to fill empty tabs with something during the developement.
It will not be use in the final version.
\index{addtext() (src\_GUI.Main\_windows\_1.EmptyTab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.EmptyTab.addtext}}\pysiglinewithargsret{\sphinxbfcode{addtext}}{}{}
This function print a string on the command line. This is useful if you need to check if a button (or similar).
is connected.

\end{fulllineitems}

\index{init\_iu() (src\_GUI.Main\_windows\_1.EmptyTab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.EmptyTab.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
Used in the initialization.

\end{fulllineitems}


\end{fulllineitems}

\index{MainWindows (class in src\_GUI.Main\_windows\_1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows}}\pysigline{\sphinxstrong{class }\sphinxcode{src\_GUI.Main\_windows\_1.}\sphinxbfcode{MainWindows}}
The class MainWindows contains the menu and the title of all the HABBY windows.
It also create all the widgets which can be called during execution

\sphinxstylestrong{Technical comments and walk-through}

First, we load the user setting using Qsettings: The settings by default of Qsettings are the name of the program (HABBY) and
the name of the organization which develops the program (irstea).  I have added three user settings (the name of the
last project loaded into HABBY, the path to this project and the language used). The Qsetting are stored in the
registry in Windows. Qsettings also function with Apple and Linux even if the information is stored differently

We set up the translation next. The translation of HABBY in different language is explained in more detail in
the section “Translation of HABBY”. We give here the path to the data related to the translation. More precisely, we indicate
here the path to the translation data and the name of the qm file containing the data related to the translation
in each language. If a new qm is added for a new language, it should be added here to the list.

Now, two important attributes are defined: self.name\_prj and self.path\_prj. These attribute will be communicated to
children classes. For each project, an xml file is created. This “project” file should be called name\_prj.xml
and should be situated in the path indicated by self.path\_prj.

We call the central\_widget which contains the different tabs.

We create the menu of HABBY calling the function my menu\_bar().

Two signal are connected, one to save the project (i.e to update the xml project file) and another to save an
ESTIMHAB calculation.

We show the created widget.
\index{clear\_log() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.clear_log}}\pysiglinewithargsret{\sphinxbfcode{clear\_log}}{}{}
Clear the log in the GUI.

\end{fulllineitems}

\index{closeEvent() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.closeEvent}}\pysiglinewithargsret{\sphinxbfcode{closeEvent}}{\emph{event}}{}
Close the program better than before (where it used to crash about 1 times in ten). It is not really clear why.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{event} -- managed by the operating system.

\end{description}\end{quote}

\end{fulllineitems}

\index{close\_rech() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.close_rech}}\pysiglinewithargsret{\sphinxbfcode{close\_rech}}{}{}
Close the additional research menu (see open\_rech for more information)

\end{fulllineitems}

\index{do\_log() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.do_log}}\pysiglinewithargsret{\sphinxbfcode{do\_log}}{\emph{save\_log}}{}
Save or not save the log
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{save\_log} -- an int which indicates if the log should be saved or not

\end{description}\end{quote}
\begin{itemize}
\item {} 
0: do not save log

\item {} 
1: save the log in the .log file and restart file

\end{itemize}

\end{fulllineitems}

\index{erase\_pict() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.erase_pict}}\pysiglinewithargsret{\sphinxbfcode{erase\_pict}}{}{}
All files contained in the folder indicated by path\_im will be deleted.

From the menu of HABBY, it is possible to ask to erase all files in the folder indicated by path\_im
(usually figure\_HABBY). Of course, this is a bit dangerous. So the function asks the user for confirmation.
However, it is practical because you do not have to go to the folder to erase all the images when there
are too many of them.

\end{fulllineitems}

\index{init\_ui() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.init_ui}}\pysiglinewithargsret{\sphinxbfcode{init\_ui}}{}{}
Used by \_\_init\_\_() to create an instance of the class MainWindows

\end{fulllineitems}

\index{my\_menu\_bar() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.my_menu_bar}}\pysiglinewithargsret{\sphinxbfcode{my\_menu\_bar}}{}{}
This function creates the menu bar of HABBY.

\end{fulllineitems}

\index{open\_rech() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.open_rech}}\pysiglinewithargsret{\sphinxbfcode{open\_rech}}{}{}
Open the additional research tab, which can be used to create Tab with more experimental contents.

Indeed, it is possible to show extra tab in HABBY. These supplementary tab correspond to open for researcher.
The plan is that these options are less tested than other mainstream options. It is not clear yet what
will be added to these options, but the basic architecture is there when it will be needed.

\end{fulllineitems}

\index{save\_project() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.save_project}}\pysiglinewithargsret{\sphinxbfcode{save\_project}}{}{}
A function to save the xml file with the information on the project

\sphinxstylestrong{Technical comments}

This function saves or creates the xml file related to the projet. In this xml file, there are the path and
the name to all files related to the project, notably the hdf5 files containing the hydrological data.

To find or create the xml file, we use the attribute self.path\_prj and self.name\_proj. If the path to
the project directory is not found an error appears. The error is here sent though additional windows
(to be sure that the user notice this problem), using the Qmesssage module. The user should give the general
info about the project in the general tab of HABBY and they are collected here. User option (using Qsetting)
is next updated so that the user will find his project open the next time it opens HABBY.

When HABBY open, there are therefore  two choice: a) This is a new project b) the project exists already.
If the project is new, the xml file is created and general information is written in this file. In addition,
the text file which are necessary to log the action of HABBY are created now. This part of the reason why it
is not possible to run other part of HABBY (such as loading hydrological data) before a project is saved.
In addition, it would create a lot of problems on where to store the data created. Hence, a project is needed
before using HABBY. If the project exists already (i.e. the name and the path of the project have not been
modified), the xml file is just updated to change its attributes as needed.

Interesting path are a) the biology path (named ``biology'' by default) which contains the biological information
such as the preference curve and b) the path\_im which is the path where all figures and most outputs of HABBY
is saved. If path\_im is not given, HABBY automatically create a folder called figure\_habby when the
user creates a new project. The user can however change this path if he wants. The next step is to communicate
to all the children widget than the name and path of the project have changed.

Finally the log is written (see “log and HABBY in the command line).

\end{fulllineitems}

\index{save\_project\_estimhab() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.save_project_estimhab}}\pysiglinewithargsret{\sphinxbfcode{save\_project\_estimhab}}{}{}
A function to save the information linked with Estimhab in an hdf5 file.

\sphinxstylestrong{Technical comments}

This function save the data and result from the estimhab calculation. It would look more logic if it was in
the esimhab.py script, but it was easier to call it from here instead of in the child class.

This function get all estimhab input, create an hdf5 file using h5py and save the data in the hdf5. One
specialty of hdf5 is that is cannot use Unicode. Hence all string have to be passed to ascii using the encode
function. The size of each data should also be known.

Finally, we save the name and path of the estimhab file in the xml project file.

\end{fulllineitems}

\index{setlangue() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.setlangue}}\pysiglinewithargsret{\sphinxbfcode{setlangue}}{\emph{nb\_lang}}{}
A function which change the language of the programme. It change the menu and the central widget.
It uses the self.lang attribute which should be set to the new language before calling this function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{nb\_lang} -- the number representing the language (int)

\end{description}\end{quote}
\begin{itemize}
\item {} 
0 is for English

\item {} 
1 for French

\item {} 
n for any additionnal language

\end{itemize}

\end{fulllineitems}

\index{test\_entry\_float() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.test_entry_float}}\pysiglinewithargsret{\sphinxbfcode{test\_entry\_float}}{\emph{var\_in}}{}
An utility function to test if var\_in are float or not
the boolean self.does\_it\_work is used to know if the functions run until the end.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{var\_in} -- the QlineEdit which contains the data (so var\_in.text is a string)

\item[{Returns}] \leavevmode
the tested variable var\_in

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ShowImageW (class in src\_GUI.Main\_windows\_1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.ShowImageW}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.Main\_windows\_1.}\sphinxbfcode{ShowImageW}}{\emph{path\_prj}, \emph{name\_prj}}{}
The widget which shows the saved images. Used only to show all the saved figure together iwhtout zoom or other
options.

\sphinxstylestrong{Technical comments}

The ShowImageW() class is used to show all the figures created by HABBY. It is a class which can only be
called from the menu (In Option/Option Image). This is not the usual way of opening a figure which is usually done
by plt.show from matplotlib. This is the way to look at all figures  together, which can be useful, even if zooming
is not possible anymore.

To show all image, HABBY open a separate window and show the saved image in .png format.  Currently, the figures
shown are in .png, but other formats could be used. For this, one can change the variable self.imtype.

An important point for the ShowImageW  class  is where the images were saved by the functions which created them.
In HABBY, all figures are saved in the same folder called “path\_im”. One “path\_im” is chosen at the start of each
project. By default, it is the folder “Figure\_Habby”, but the user can modify this folder in the window created by
ShowImageW(). The function for this is called “change\_folder”, also in ShowImageW(). The path\_im is written in
the xml project file. The different functions which create image read this path and send the figure created
to this folder. ShowImageW() reads all  figure of “.png” type in the” path\_im” folder and show the most recent
figure. The user can use the drop-down menu to choose to see another figure. The names of the figure are added to
the drop-down menu in the function update\_namefig. The function ``selectionchange'' changes the figure shown based
on the user action.
\index{change\_folder() (src\_GUI.Main\_windows\_1.ShowImageW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.ShowImageW.change_folder}}\pysiglinewithargsret{\sphinxbfcode{change\_folder}}{}{}
A function to change the folder where are stored the image (i.e., the path\_im)

\end{fulllineitems}

\index{init\_iu() (src\_GUI.Main\_windows\_1.ShowImageW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.ShowImageW.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
Used in the initialization.

\end{fulllineitems}

\index{selectionchange() (src\_GUI.Main\_windows\_1.ShowImageW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.ShowImageW.selectionchange}}\pysiglinewithargsret{\sphinxbfcode{selectionchange}}{\emph{i}}{}
A function to change the figure shown by ShowImageW()
:return:

\end{fulllineitems}

\index{send\_log (src\_GUI.Main\_windows\_1.ShowImageW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.ShowImageW.send_log}}\pysigline{\sphinxbfcode{send\_log}}
A PyQt signal used to write the log

\end{fulllineitems}

\index{update\_namefig() (src\_GUI.Main\_windows\_1.ShowImageW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.ShowImageW.update_namefig}}\pysiglinewithargsret{\sphinxbfcode{update\_namefig}}{}{}
This function add the different figure name to the drop-down list.

\end{fulllineitems}


\end{fulllineitems}

\index{WelcomeW (class in src\_GUI.Main\_windows\_1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.WelcomeW}}\pysigline{\sphinxstrong{class }\sphinxcode{src\_GUI.Main\_windows\_1.}\sphinxbfcode{WelcomeW}}
The class WeLcomeW()  creates the first tab of HABBY (the tab called “General”). This tab is there to create
a new project or to change the name, path, etc. of a project.
\index{init\_iu() (src\_GUI.Main\_windows\_1.WelcomeW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.WelcomeW.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
Used in the initialization of a new instance of the class WelcomeW()

\end{fulllineitems}

\index{save\_signal (src\_GUI.Main\_windows\_1.WelcomeW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.WelcomeW.save_signal}}\pysigline{\sphinxbfcode{save\_signal}}
A PyQt signal used to save the figure

\end{fulllineitems}

\index{send\_log (src\_GUI.Main\_windows\_1.WelcomeW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.WelcomeW.send_log}}\pysigline{\sphinxbfcode{send\_log}}
A PyQt signal used to write the log

\end{fulllineitems}

\index{setfolder() (src\_GUI.Main\_windows\_1.WelcomeW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.WelcomeW.setfolder}}\pysiglinewithargsret{\sphinxbfcode{setfolder}}{}{}
This function is used by the user to select the folder where the xml project file will be located.

\end{fulllineitems}


\end{fulllineitems}

\index{new\_project() (in module src\_GUI.Main\_windows\_1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.new_project}}\pysiglinewithargsret{\sphinxcode{src\_GUI.Main\_windows\_1.}\sphinxbfcode{new\_project}}{}{}
\end{fulllineitems}

\index{open\_project() (in module src\_GUI.Main\_windows\_1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.open_project}}\pysiglinewithargsret{\sphinxcode{src\_GUI.Main\_windows\_1.}\sphinxbfcode{open\_project}}{}{}
\end{fulllineitems}



\section{Hydrological information - GUI}
\label{\detokenize{index:hydrological-information-gui}}
in src\_GUI/hydro\_GUI\_2.py

This python module contains the class which forms the hydrological tab in HABBY.
It contains the information for the graphical interface and make the link with the scripts
used for the hydrological calculations.
\phantomsection\label{\detokenize{index:module-src_GUI.hydro_GUI_2}}\index{src\_GUI.hydro\_GUI\_2 (module)}\index{FreeSpace (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.FreeSpace}}\pysigline{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{FreeSpace}}
Bases: \sphinxcode{PyQt5.QtWidgets.QWidget}

Simple class with empty space, just to have only Qwidget in the stack.

\sphinxstylestrong{Technical comment}

The idea of this class is that the user see a free space when it opens the “Hydro” Tab instead
of directly seeing one of the hydraulic model. The goal is to avoid the case where a user tries to load data before
selecting the real model. For example, if a user wants to load mascaret data and that an item is selected by
default in the stack of classes related to hydrology (such as HEC-RAS1D), it might be logical for the user to try
to load masacret data using the HEC-RAS class. Because of the FreeSpace class, he actually has to select
the model he wants to load.

\end{fulllineitems}

\index{HEC\_RAS1D (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HEC_RAS1D}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{HEC\_RAS1D}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: {\hyperref[\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW}]{\sphinxcrossref{\sphinxcode{src\_GUI.hydro\_GUI\_2.SubHydroW}}}}

The class Hec\_ras 1D is there to manage the link between the graphical interface and the functions in
src/hec\_ras06.py which loads the hec-ras data in 1D. The class HEC\_RAS1D inherits from SubHydroW() so it have all
the methods and the variables from the class ubHydroW(). The class hec-ras 1D is added to the self.stack of Hydro2W(). So the class Hec-Ras 1D is called when
the user is on the hydrological tab and click on hec-ras1D as hydrological model.
\index{init\_iu() (src\_GUI.hydro\_GUI\_2.HEC\_RAS1D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HEC_RAS1D.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
This function is called by \_\_init\_\_() durring the initialization.

\sphinxstylestrong{Technical comment}

The self.attributexml variable is the name of the attribute in the xml file. To load a hec-ras file, one needs
to give to HABBY one file containing the geometry data and one file containing the simulation result. The name
and path to  these two file are saved in the xml project file under the attribute given in
the self.attributexml variable.

The variable self.extension is a list of list of the accepted file type. The first list is for the file
with geometry data. The second list is the extension of the files containing the simulation results.

Using the function self.was\_model\_loaded\_before, HABBY write the name of the hec-ras files which were loaded
in HABBY in the same project before.

Hec-Ras is a 1.5D model and so HABBY create a 2D grid based on the 1.5D input. The user can choose the interpolation
type and the number of extra profile. If the interpolation type is “interpolation by block”, the number of extra
profile will always be one. See manage\_grid.py for more information on how to create a grid.

\end{fulllineitems}

\index{load\_hec\_ras\_gui() (src\_GUI.hydro\_GUI\_2.HEC\_RAS1D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HEC_RAS1D.load_hec_ras_gui}}\pysiglinewithargsret{\sphinxbfcode{load\_hec\_ras\_gui}}{}{}
A function to execute the loading and saving of the HEC-ras file using Hec\_ras.py

\sphinxstylestrong{Technical comments}

This function is called when the user press on the button self.load\_b. It is the function which really
calls the load function for hec\_ras. First, it updates the xml project file. It adds the name of the new file
to xml project file under the attribute indicated by self.attributexml. It also gets the path\_im by reading the
path\_im in the xml project file. Then it check if the user want to create the figure or not
(if self.cb.isChecked(), figures should be created). It also manages the log as explained in the section
about the log. Notably, it redirects the  outstream to the mystdout stream. Hence, the “print” statement is
now sent to the log windows at the bottom of HABBY window. Next, it loads the hec-ras data as explained in
the section on hec\_ras06.py. It then creates the grid as explained in the manage\_grid.py based on the
interpolation type wished by the user (linear, nearest neighbor or by block). It creates the hdf5
with the loaded data. Finally, if necessary, it shows the figure by emitting a signal.
This signal is collected in the MainWindow() class.

\end{fulllineitems}

\index{show\_fig (src\_GUI.hydro\_GUI\_2.HEC\_RAS1D attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HEC_RAS1D.show_fig}}\pysigline{\sphinxbfcode{show\_fig}}
PyQtsignal to show the figure.

\end{fulllineitems}


\end{fulllineitems}

\index{HEC\_RAS2D (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HEC_RAS2D}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{HEC\_RAS2D}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: {\hyperref[\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW}]{\sphinxcrossref{\sphinxcode{src\_GUI.hydro\_GUI\_2.SubHydroW}}}}

The class hec\_RAS2D is there to manage the link between the graphical interface and the functions in src/hec\_ras2D.py
which loads the hec\_ras2D data in 2D. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW(). It is very similar to RUBAR2D class and it has the same problem about node/cell
which will need to be corrected.
\index{init\_iu() (src\_GUI.hydro\_GUI\_2.HEC\_RAS2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HEC_RAS2D.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
This method is used to by \_\_init\_\_() during the initialization.

\end{fulllineitems}

\index{load\_hec\_2d\_gui() (src\_GUI.hydro\_GUI\_2.HEC\_RAS2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HEC_RAS2D.load_hec_2d_gui}}\pysiglinewithargsret{\sphinxbfcode{load\_hec\_2d\_gui}}{}{}
This function calls the function which load hecras 2d and save the names of file in the project file.
It is similar to the function to load\_rubar2D.

\end{fulllineitems}

\index{show\_fig (src\_GUI.hydro\_GUI\_2.HEC\_RAS2D attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HEC_RAS2D.show_fig}}\pysigline{\sphinxbfcode{show\_fig}}
PyQtsignal to show the figures.

\end{fulllineitems}


\end{fulllineitems}

\index{Hydro2W (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Hydro2W}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{Hydro2W}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: \sphinxcode{PyQt5.QtWidgets.QWidget}

The class Hydro2W is the second tab of HABBY. It is the class containing all the classes/Widgets which are used
to load the hydrological data.

List of model supported by Hydro2W:
files separetly. However, sometime the file was not found
*   Telemac (2D)
*   Hec-Ras (1.5D et 2D)
*   Rubar BE et 2(1D et 2D)
*   Mascaret (1D)
*   River2D (2D)

\sphinxstylestrong{Technical comments}

To call the different classes used to load the hydrological data, the user selects the name of the hydrological
model from a QComboBox call self.mod. The method ‘selection\_change” calls the class that the user chooses in
self.mod. All the classes used to load the
hydrological data are created when HABBY starts and are kept in a stack called self.stack. The function
selection\_change() just changes the selected item of the stack based on the user choice on self.mod.

Any new hydrological model should also be added to the stack and to the list of models contained in self.mod
(name of the list: self.name\_model).

In addition to the stack containing the hydrological information, hydro2W has two buttons. One button open
a QMessageBox() which give information about the models, using the method “give\_info\_model”.  It is useful if a
special type of file is needed to load the data from a model or to give extra information about one hydrological
model. The text which is shown on the QMessageBox is given in one text file for each model.
These text file are contained in the folder ‘model\_hydro” which is in the HABBY folder. For the moment,
there are models for which no text files have been prepared. The text file should have the following format:
\begin{itemize}
\item {} 
A short sentence with general info

\item {} 
The keyword:  MORE INFO

\item {} 
All other infomation which are needed.

\end{itemize}

The second button allows the user to load an hdf5 file containing hydrological data from another project.
As long as the hdf5 is in the right format, it does not matter from which hydrological model it was loaded from
or even if this hydrological model is supported by HABBY.
\index{get\_new\_hydro\_hdf5() (src\_GUI.hydro\_GUI\_2.Hydro2W method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Hydro2W.get_new_hydro_hdf5}}\pysiglinewithargsret{\sphinxbfcode{get\_new\_hydro\_hdf5}}{}{}
This is a function which allows the user to select an hdf5 file containing the hydrological
data from a previous project and add it to the current project. It modifies the xml project file and test
that the data is in correct form by loading it. The hdf5 should have the same form than the hydrological data
created by HABBY in the method save\_hdf5 of the class SubHydroW.

\end{fulllineitems}

\index{give\_info\_model() (src\_GUI.hydro\_GUI\_2.Hydro2W method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Hydro2W.give_info_model}}\pysiglinewithargsret{\sphinxbfcode{give\_info\_model}}{}{}
A function to show extra information about each hydrological model.
The information should be in a text file with the same name as the model in the model\_hydo folder.
General info goes as the start of the text file. If the text is too long, add the keyword ``MORE INFO''
and add the longer text afterwards. The message box will show the supplementary information only if the user
asks for detailed information.

\end{fulllineitems}

\index{init\_iu() (src\_GUI.hydro\_GUI\_2.Hydro2W method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Hydro2W.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
Used in the initialization by \_\_init\_\_()

\end{fulllineitems}

\index{selectionchange() (src\_GUI.hydro\_GUI\_2.Hydro2W method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Hydro2W.selectionchange}}\pysiglinewithargsret{\sphinxbfcode{selectionchange}}{\emph{i}}{}
Change the shown widget which represents each hydrological model (all widget are in a stack)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{i} -- the number of the model (0=no model, 1=hecras1d, 2= hecras2D,...)

\end{description}\end{quote}

\end{fulllineitems}

\index{send\_log (src\_GUI.hydro\_GUI\_2.Hydro2W attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Hydro2W.send_log}}\pysigline{\sphinxbfcode{send\_log}}
A PyQt signal to send the log.

\end{fulllineitems}


\end{fulllineitems}

\index{Mascaret (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Mascaret}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{Mascaret}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: {\hyperref[\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW}]{\sphinxcrossref{\sphinxcode{src\_GUI.hydro\_GUI\_2.SubHydroW}}}}

The class Mascaret is there to manage the link between the graphical interface and the functions in src/mascaret.py
which loads the Masacret data in 1D. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW(). It is similar to the HEC-Ras1D class (see this class for more information). However, mascaret is 1D model, so the loading
of mascaret has one additional step compared to the hec-ras load: The velocity must be distributed along the
profile. For this, the load\_masacret\_gui call the self.distrbute \_velocity function. In addition, it prepares
the manning value which is necessary to distribute the velocity. The user has two choices to input the manning
value. The easiest one is just to give a value constant for the whole river. In the second choice, the user loads
a text file with a serie of lines with the following info: p, dist, n where p is the profile number
(starting at zero), dist is the distance in meter along the profile and n in the manning value (see the method
load\_manning\_text of the class SubHydroW for more information)
\index{init\_iu() (src\_GUI.hydro\_GUI\_2.Mascaret method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Mascaret.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
Used in the initialization by \_\_init\_\_()

\end{fulllineitems}

\index{load\_mascaret\_gui() (src\_GUI.hydro\_GUI\_2.Mascaret method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Mascaret.load_mascaret_gui}}\pysiglinewithargsret{\sphinxbfcode{load\_mascaret\_gui}}{}{}
The function is used to load the mascaret data, calling the function contained in the script mascaret.py

\end{fulllineitems}

\index{show\_fig (src\_GUI.hydro\_GUI\_2.Mascaret attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Mascaret.show_fig}}\pysigline{\sphinxbfcode{show\_fig}}
A PyQtsignal to show the figure.

\end{fulllineitems}


\end{fulllineitems}

\index{River2D (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.River2D}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{River2D}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: {\hyperref[\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW}]{\sphinxcrossref{\sphinxcode{src\_GUI.hydro\_GUI\_2.SubHydroW}}}}

The class River2D t is there to manage the link between the graphical interface and the functions in src/river2D.py
which loads the River2D data in 2D.

\sphinxstylestrong{Technical comments}
\begin{quote}

The class River2D inherits from SubHydroW() so it have all the methods and the variables from the class SubHydroW().
It is similar generally to the hec-ras2D class. However, the hydrological model River2D create one file per time step.
Hence, it is necessary to have a way to load all the files automatically. Loading one file after one file would be
annoying. There are four functions to manage the large number of file:
\begin{itemize}
\item {} 
add\_all\_file: find all files in a folder selected by the user.

\item {} 
add\_file\_river2D: add just one selected file

\item {} 
Remove\_all\_file: remove all selected files

\item {} 
Remove\_file: remove one selected file

\end{itemize}

None of this four functions load the data, it just add the name and path of the files to be loaded to
self.namefile and self.pathfile. Generally, in HABBY, we load hydrological data in two steps: a) select the files,
b) load the data. For river2D, the step b) is done by the function load\_river2d\_gui().
This function is similar to the one used by Rubar2D. It has the same problem about the grid which
is identical for all time steps and which contains all reaches together. So a temporary correction was applied.
Data in River2D is given on the nodes as in HABBY.
\end{quote}
\index{add\_all\_file() (src\_GUI.hydro\_GUI\_2.River2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.River2D.add_all_file}}\pysiglinewithargsret{\sphinxbfcode{add\_all\_file}}{}{}
The function finds all .cdg file in one directory to add there names to the list of files to be loaded

\end{fulllineitems}

\index{add\_file\_river2d() (src\_GUI.hydro\_GUI\_2.River2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.River2D.add_file_river2d}}\pysiglinewithargsret{\sphinxbfcode{add\_file\_river2d}}{}{}
This function is used to add one file to the list of file to be loaded.
It calls show\_dialog, prepare some data for it and update the QWidgetList with
the name of the file containted in the variable self.namefile.

\end{fulllineitems}

\index{add\_file\_to\_list() (src\_GUI.hydro\_GUI\_2.River2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.River2D.add_file_to_list}}\pysiglinewithargsret{\sphinxbfcode{add\_file\_to\_list}}{}{}
This function to add all file contained in self.namefile to the QWidgetlist. Called by add\_file\_river2D and
add\_all\_file.

\end{fulllineitems}

\index{init\_iu() (src\_GUI.hydro\_GUI\_2.River2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.River2D.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
used by \_\_init\_\_ in the initialization

\end{fulllineitems}

\index{load\_river2d\_gui() (src\_GUI.hydro\_GUI\_2.River2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.River2D.load_river2d_gui}}\pysiglinewithargsret{\sphinxbfcode{load\_river2d\_gui}}{}{}
This function is used to load the river 2d data.

\end{fulllineitems}

\index{remove\_all\_file() (src\_GUI.hydro\_GUI\_2.River2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.River2D.remove_all_file}}\pysiglinewithargsret{\sphinxbfcode{remove\_all\_file}}{}{}
This function removes all files from the list of files to be loaded and from the QlistWidget.

\end{fulllineitems}

\index{remove\_file() (src\_GUI.hydro\_GUI\_2.River2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.River2D.remove_file}}\pysiglinewithargsret{\sphinxbfcode{remove\_file}}{}{}
This is small function to remove a .cdg file from the list of files to be loaded and from the QlistWidget.

\end{fulllineitems}

\index{show\_fig (src\_GUI.hydro\_GUI\_2.River2D attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.River2D.show_fig}}\pysigline{\sphinxbfcode{show\_fig}}
A PyQtsignal to show the figure.

\end{fulllineitems}


\end{fulllineitems}

\index{Rubar1D (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Rubar1D}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{Rubar1D}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: {\hyperref[\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW}]{\sphinxcrossref{\sphinxcode{src\_GUI.hydro\_GUI\_2.SubHydroW}}}}

The class Rubar1D is there to manage the link between the graphical interface and the functions in src/rubar.py
which loads the Rubar1D data in 1D. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW(). It is very similar to Mascaret class.
\index{init\_iu() (src\_GUI.hydro\_GUI\_2.Rubar1D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Rubar1D.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
Used in the initalizatin by \_\_init\_\_()

\end{fulllineitems}

\index{load\_rubar1d() (src\_GUI.hydro\_GUI\_2.Rubar1D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Rubar1D.load_rubar1d}}\pysiglinewithargsret{\sphinxbfcode{load\_rubar1d}}{}{}
A function to execute the loading and saving the the rubar file using rubar.py. After loading the data,
it distribute the velocity along the profiles by calling self.distribute\_velocity() and it created the 2D grid
by calling the method self.grid\_and\_interpo.

\end{fulllineitems}

\index{show\_fig (src\_GUI.hydro\_GUI\_2.Rubar1D attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Rubar1D.show_fig}}\pysigline{\sphinxbfcode{show\_fig}}
A PyQtsignal to show the figures.

\end{fulllineitems}


\end{fulllineitems}

\index{Rubar2D (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Rubar2D}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{Rubar2D}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: {\hyperref[\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW}]{\sphinxcrossref{\sphinxcode{src\_GUI.hydro\_GUI\_2.SubHydroW}}}}

The class Rubar2D is there to manage the link between the graphical interface and the functions in src/rubar.py
which loads the RUBAR data in 2D. It inherits from SubHydroW() so it have all the methods and the variables from
the class SubHydroW(). The form of the function is similar to hec-ras, but it does not have the part about the grid
creation as we look here as the data created in 2D by RUBAR.
\index{init\_iu() (src\_GUI.hydro\_GUI\_2.Rubar2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Rubar2D.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
used by \_\_\_init\_\_() in the initialization.

\end{fulllineitems}

\index{load\_rubar() (src\_GUI.hydro\_GUI\_2.Rubar2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Rubar2D.load_rubar}}\pysiglinewithargsret{\sphinxbfcode{load\_rubar}}{}{}
A function to execture the loading and saving the the rubar file using rubar.py. It is similar to the
load\_hec\_ras\_gui() function. Obviously, it calls rubar and not hec\_ras this time. A small difference is that
the rubar2D outputs are only given in one grid for all time steps and all reaches. Moreover, it will be
necessary to cut the grid for each time step as a function of the wetted area and maybe to separate the
grid by reaches. This have not be done yet.

Another problem is that the data of Rubar2D is given on the cells of the grid and not the nodes.
This will need to be corrected as data in HABBY is centered on the node.

\end{fulllineitems}

\index{propose\_next\_file() (src\_GUI.hydro\_GUI\_2.Rubar2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Rubar2D.propose_next_file}}\pysiglinewithargsret{\sphinxbfcode{propose\_next\_file}}{}{}
This function proposes the second RUBAR file when the first is selected.  Indeed, to load rubar, we need
one file with the geometry data and one file with the simulation results. If the user selects a file, this
function looks if a file with the same name but with the extension of the other file type exists in the
selected folder. This could be done for all hydrological models, but the function is harder
to write when more than one extension is possible, so it has not been done yet.

\end{fulllineitems}

\index{show\_fig (src\_GUI.hydro\_GUI\_2.Rubar2D attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Rubar2D.show_fig}}\pysigline{\sphinxbfcode{show\_fig}}
A PyQtsignal to show the figure.

\end{fulllineitems}


\end{fulllineitems}

\index{SubHydroW (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{SubHydroW}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: \sphinxcode{PyQt5.QtWidgets.QWidget}

SubHydroW is class which is the parent of the classes which can be used to open the hydrological models. This class
is a bit special. It is not called directly by HABBY but by the classes which load the hydrological data and which
inherits from this class. The advantage of this architecture is that all the children classes can use the methods
written in SubHydroW(). Indeed, all the children classes load hydrological data and therefore they are similar and can use
similar functions.

In other word, there are MainWindows() which provides the windows around the widget and Hydro2W which provide the widget for the
hydrological Tab and one class by hydrological model to really load the model. The latter classes have various
methods in common, so they inherit from SubHydroW, this class.
\index{distribute\_velocity() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.distribute_velocity}}\pysiglinewithargsret{\sphinxbfcode{distribute\_velocity}}{}{}
This function make the link between the GUI and the functions of dist\_vitesse2. It is used by 1D model,
notably rubar and masacret.

Dist vitess needs a manning parameters. It can be given by the user in two forms: a constant (float) or an array
created by the function load\_manning\_text.

\end{fulllineitems}

\index{drop\_hydro (src\_GUI.hydro\_GUI\_2.SubHydroW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.drop_hydro}}\pysigline{\sphinxbfcode{drop\_hydro}}
A PyQtsignal signal for the substrate tab so it can account for the new hydrological info.

\end{fulllineitems}

\index{find\_path\_im() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.find_path_im}}\pysiglinewithargsret{\sphinxbfcode{find\_path\_im}}{}{}
A function to find the path where to save the figues, careful a simialr one is in estimhab\_GUI.py. By default,
path\_im is in a folder calls ``Figure\_Habby''.

\end{fulllineitems}

\index{grid\_and\_interpo() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.grid_and_interpo}}\pysiglinewithargsret{\sphinxbfcode{grid\_and\_interpo}}{\emph{cb\_im}}{}
This function forms the link between GUI and the various grid and interpolation functions. Is called by
the ``loading' function of hec-ras 1D, Mascaret and Rubar BE.
:param cb\_im: A boolean if true, the figures are created and shown.

\sphinxstyleemphasis{Technical comment to be added}

\end{fulllineitems}

\index{load\_manning\_text() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.load_manning_text}}\pysiglinewithargsret{\sphinxbfcode{load\_manning\_text}}{}{}
This function loads the manning data in case where manning number is not simply a constant. In this case, the manning
parameter is given in a .txt file.
The manning parameter used by 1D model such as mascaret or Rubar BE to distribute velocity along the profiles.
The format of the txt file is ``p, dist, n'' where  p is the profile number (start at zero), dist is the distance
along the profile in meter and n is the manning value (in SI unit). One point per line so something like:

0, 150, 0.035

0, 200, 0.025

1, 120, 0.035, etc.

White space is neglected and a line starting with the character \# is also neglected.

\end{fulllineitems}

\index{read\_attribute\_xml() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.read_attribute_xml}}\pysiglinewithargsret{\sphinxbfcode{read\_attribute\_xml}}{\emph{att\_here}}{}
A function to read the text of an attribute in the xml project file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{att\_here} -- the attribute name (string).

\end{description}\end{quote}

\end{fulllineitems}

\index{save\_hdf5() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.save_hdf5}}\pysiglinewithargsret{\sphinxbfcode{save\_hdf5}}{}{}
This function save the hydrological data in the hdf5 format.

\sphinxstylestrong{Techincal comments}

This function cannot be used outside of the class, so it needs to be re-written if used from the command line.

This function creates an hdf5 file which contains the hydrological data. First it creates an empty hdf5.
Then it fill the hdf5 with data. For 1D model, it fill the data in 1D (the original data), then the 1.5D data
created by dist\_vitess2.py and finally the 2D data. For model in 2D it only saved 2D data. Hence, the 2D data
is the data which is common to all model and which can always be loaded from a hydrological hdf5 created by
HABBY. The 1D and 1.5D data is only present if the model is 1D or 1.5D. Here is some general info about the
created hdf5:
\begin{itemize}
\item {} 
Name of the file: name\_projet  +  ’\_’ +  name model + date/time.h5.  For example, test4\_HEC-RAS\_25\_10\_2016\_12\_23\_23.h5.

\item {} 
Position of the file: in the folder  figure\_habby currently (probably in a project folder in the final software)

\item {} 
Format of the hdf5 file:
\begin{itemize}
\item {} 
Dats\_gen:  number of time step and number of reach

\item {} 
Data\_1D:  xhzv\_data\_all (given profile by profile)

\item {} 
Data\_15D :  vh\_pro, coord\_pro (given profile by profile in a dict) and nb\_pro\_reach.

\item {} 
Data\_2D : For each time step, for each reach: ikle, point, point\_c, inter\_h, inter\_vel

\end{itemize}

\end{itemize}

If a list has elements with a changing number of variables, it is necessary to create a dictionary to save
this list in hdf5. For example, a dictionary will be needed to save the following list: {[}{[}1,2,3,4{]}, {[}1,2,3{]}{]}.
This is used for example, to save data by profile as we can have profile with more or less points. We also note
in the hdf5 attribute some important info such as the project name, path to the project, hdf5 version.
This can be useful if an hdf5 is lost and is not linked with any project. We also add the name of the created
hdf5 to the xml project file. Now we can load the hydrological data using this hdf5 file and the xml project file.

Hdf5 file do not support unicode. It is necessary to encode string to write them in ascii.

\end{fulllineitems}

\index{save\_xml() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.save_xml}}\pysiglinewithargsret{\sphinxbfcode{save\_xml}}{\emph{i=0}, \emph{append\_name=False}}{}
A function to save the loaded data in the xml file.

This function adds the name and the path of the newly chosen hydrological data to the xml project file. First,
it open the xml project file (and send an error if the project is not saved, or if it cannot find the project
file). Then, it opens the xml file and add the path and name of the file to this xml file. If the model data was
already loaded, it adds the new name without erasing the old name IF the switch append\_name is True. Otherwise,
it erase the old name and replace it by a new name. The variable “i” has the same role than in show\_dialog.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{i} -- a int for the case where there is more than one file to load

\item {} 
\sphinxstyleliteralstrong{append\_name} -- A boolean. If True, the name found will be append to the existing name in the xml file,
instead of remplacing the old name by the new name.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{send\_err\_log() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.send_err_log}}\pysiglinewithargsret{\sphinxbfcode{send\_err\_log}}{}{}
This function sends the errors and the warnings to the logs.
The stdout was redirected to self.mystdout.

\end{fulllineitems}

\index{send\_log (src\_GUI.hydro\_GUI\_2.SubHydroW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.send_log}}\pysigline{\sphinxbfcode{send\_log}}
A Pyqtsignal to write the log.

\end{fulllineitems}

\index{show\_dialog() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.show_dialog}}\pysiglinewithargsret{\sphinxbfcode{show\_dialog}}{\emph{i=0}}{}
A function to obtain the name of the file chosen by the user. This method open a dialog so that the user select
a file. This file is NOT loaded here. The name and path to this file is saved in an attribute. This attribute
is then used to loaded the file in other function, which are different for each children class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{i} -- a int for the case where there is more than one file to load

\end{description}\end{quote}

\end{fulllineitems}

\index{was\_model\_loaded\_before() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.was_model_loaded_before}}\pysiglinewithargsret{\sphinxbfcode{was\_model\_loaded\_before}}{\emph{i=0}, \emph{many\_file=False}}{}
A function to test if the model loaded before. If yes, it updates the attibutes anf the widgets of the
hydrological model on consideration.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{i} -- an int used in cases where there is more than one file to load (geometry and output for example)

\item {} 
\sphinxstyleliteralstrong{many\_file} -- A bollean. If true this function will load more than one file, separated by `,'. If False,
it will only loads the file of one model (see the comment below).

\end{itemize}

\end{description}\end{quote}

\sphinxstylestrong{Technical comment}

This method opens the xml project file and look in the attribute of the xml file to see if data from the
hydrological model have been loaded before. If yes, the name of the data is written on the GUI of HABBY in the
Widget related to the hydrological model. Now, there are often more than one data loaded. This method allows
choosing what should be written. There are two different case to be separated: a) We have loaded two different
models (like two rivers modeled by HEC-RAS) b) One model type needs two data file (like HEC-RAS would need a
geometry and output data). For the case a), the default is to write only the first model loaded. If we wish to
write all data, the switch “many\_file” should be True. This switch is also useful for the river2D model, because
this model create one output file per time step. For the case b), the argument “i”(which is an int) allows us to
choose which data type should be shown. “i” is in the order of the self.attributexml variable. The definition of
this order is given in the definition of the class of each hydrological model.

\end{fulllineitems}


\end{fulllineitems}

\index{SubstrateW (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{SubstrateW}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: {\hyperref[\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW}]{\sphinxcrossref{\sphinxcode{src\_GUI.hydro\_GUI\_2.SubHydroW}}}}

This is the widget used to load the substrate. It is practical to re-use some of the method from SubHydroW.
So this class inherit from SubHydroW.
\index{get\_att\_name() (src\_GUI.hydro\_GUI\_2.SubstrateW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.get_att_name}}\pysiglinewithargsret{\sphinxbfcode{get\_att\_name}}{}{}
A function to get the attribute name of the shapefile which contains the substrate data. it is given by the user
in the GUI.

\end{fulllineitems}

\index{init\_iu() (src\_GUI.hydro\_GUI\_2.SubstrateW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
Used in the initialization by \_\_init\_\_().

\end{fulllineitems}

\index{load\_sub\_gui() (src\_GUI.hydro\_GUI\_2.SubstrateW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.load_sub_gui}}\pysiglinewithargsret{\sphinxbfcode{load\_sub\_gui}}{}{}
This function is used to load the substrate data. The substrate data can be in two forms: a) in the form of a shp
file form ArGIS (or another GIS-program). b) in the form of a text file (x,y, substrate data line by line).
Generally this function has some similarities to the functions used to load the hydrological data and it re-uses
some of the methods developed for them.

\end{fulllineitems}

\index{log\_txt() (src\_GUI.hydro\_GUI\_2.SubstrateW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.log_txt}}\pysiglinewithargsret{\sphinxbfcode{log\_txt}}{}{}
This function gives the log for the substrate in text form. this is in a function because it is used twice in
the function load\_sub\_gui()

\end{fulllineitems}

\index{save\_hdf5\_sub() (src\_GUI.hydro\_GUI\_2.SubstrateW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.save_hdf5_sub}}\pysiglinewithargsret{\sphinxbfcode{save\_hdf5\_sub}}{}{}
This function save the substrate data in its own hdf5 file and write the name of this hdf5 file in the
xml project file. The format of the hdf5 file is not finalzed yet so it is not documented.

\end{fulllineitems}

\index{send\_merge\_grid() (src\_GUI.hydro\_GUI\_2.SubstrateW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.send_merge_grid}}\pysiglinewithargsret{\sphinxbfcode{send\_merge\_grid}}{}{}
This function calls the function merge grid in substrate.py. The goal is to have the substrate and hydrological
data on the same grid. Hence, the hydrological grid will need to be cut to the form of the substrate grid.

\end{fulllineitems}

\index{show\_fig (src\_GUI.hydro\_GUI\_2.SubstrateW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.show_fig}}\pysigline{\sphinxbfcode{show\_fig}}
A PyQtsignal to show the figures.

\end{fulllineitems}

\index{update\_hydro\_hdf5\_name() (src\_GUI.hydro\_GUI\_2.SubstrateW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.update_hydro_hdf5_name}}\pysiglinewithargsret{\sphinxbfcode{update\_hydro\_hdf5\_name}}{}{}
This is a short function used to read all the hydrological data contained in an hdf5 files and available in
one project. When these files are read, they are added to the drop-down menu;
This should be a function because an update to this list can be triggered by the loading of a new hydrological
data. The class SubstrateW() noticed this through the signal drop\_hydro send by the hydrological class.
The signal drop\_hydro is connected to this function in the class CentralW in MainWindows.py. Indeed, it is not
possible to do it in SubstrateW().

\end{fulllineitems}


\end{fulllineitems}

\index{TELEMAC (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.TELEMAC}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{TELEMAC}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: {\hyperref[\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW}]{\sphinxcrossref{\sphinxcode{src\_GUI.hydro\_GUI\_2.SubHydroW}}}}

The class Telemac is there to manage the link between the graphical interface and the functions in src/selafin\_habby1.py
which loads the Telemac data in 2D. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW(). It is very similar to RUBAR2D class, but data from Telemac is on the node as in HABBY.
\index{init\_iu() (src\_GUI.hydro\_GUI\_2.TELEMAC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.TELEMAC.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
Used by \_\_init\_\_() during the initialization.

\end{fulllineitems}

\index{load\_telemac\_gui() (src\_GUI.hydro\_GUI\_2.TELEMAC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.TELEMAC.load_telemac_gui}}\pysiglinewithargsret{\sphinxbfcode{load\_telemac\_gui}}{}{}
The function which call the function which load telemac and save the name of files in the project file

\end{fulllineitems}

\index{show\_fig (src\_GUI.hydro\_GUI\_2.TELEMAC attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.TELEMAC.show_fig}}\pysigline{\sphinxbfcode{show\_fig}}
A PyQtsignal to show the figure.

\end{fulllineitems}


\end{fulllineitems}



\section{Figure Option - GUI}
\label{\detokenize{index:figure-option-gui}}\begin{quote}

in src\_GUI/output\_fig\_GUI.py

This part is not finished. The idea is to let the user select various options to create
the figures, notably the colour or the size of the text.
\end{quote}
\phantomsection\label{\detokenize{index:module-src_GUI.output_fig_GUI}}\index{src\_GUI.output\_fig\_GUI (module)}\index{create\_default\_figoption() (in module src\_GUI.output\_fig\_GUI)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.output_fig_GUI.create_default_figoption}}\pysiglinewithargsret{\sphinxcode{src\_GUI.output\_fig\_GUI.}\sphinxbfcode{create\_default\_figoption}}{}{}
This function creates the default dictionnary of option for the figure.

\end{fulllineitems}

\index{load\_fig\_option() (in module src\_GUI.output\_fig\_GUI)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.output_fig_GUI.load_fig_option}}\pysiglinewithargsret{\sphinxcode{src\_GUI.output\_fig\_GUI.}\sphinxbfcode{load\_fig\_option}}{\emph{path\_prj}, \emph{name\_prj}}{}
This function loads the figure option saved in the xml file and create a dictionnary will be given to the functions
which create the figures to know the different options chosen by the user. If the options are not written, this
function uses data by default which are in the fonction create\_default\_fig\_options().
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path to the xml project file

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- the name to this file

\end{itemize}

\item[{Returns}] \leavevmode
the dictionary containing the figure options

\end{description}\end{quote}

\end{fulllineitems}

\index{outputW (class in src\_GUI.output\_fig\_GUI)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.output_fig_GUI.outputW}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.output\_fig\_GUI.}\sphinxbfcode{outputW}}{\emph{path\_prj}, \emph{name\_prj}}{}
The class which support the creation and management of the output. It is notably used to select the otions to
create the figures.
\index{init\_iu() (src\_GUI.output\_fig\_GUI.outputW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.output_fig_GUI.outputW.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
\end{fulllineitems}

\index{save\_option\_fig() (src\_GUI.output\_fig\_GUI.outputW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.output_fig_GUI.outputW.save_option_fig}}\pysiglinewithargsret{\sphinxbfcode{save\_option\_fig}}{}{}
A function which save the options for the figures in the xlm project file. The options for the figures are
contained in a dictionnary. The idea is to give this dictinnory in argument to all the fonction which create
figures. In the xml project file, the options for the figures are saved under the attribute ``Figure\_Option''.

\end{fulllineitems}

\index{send\_log (src\_GUI.output\_fig\_GUI.outputW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.output_fig_GUI.outputW.send_log}}\pysigline{\sphinxbfcode{send\_log}}
A PyQtsignal used to write the log.

\end{fulllineitems}


\end{fulllineitems}



\section{The Stathab model - GUI}
\label{\detokenize{index:the-stathab-model-gui}}\label{\detokenize{index:module-src_GUI.stathab_GUI}}\index{src\_GUI.stathab\_GUI (module)}\index{StathabW (class in src\_GUI.stathab\_GUI)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.stathab\_GUI.}\sphinxbfcode{StathabW}}{\emph{path\_prj}, \emph{name\_prj}}{}
The class to load and manage the widget controlling the Stathab model.

\sphinxstylestrong{Technical comments}

The class StathabW makes the link between the data prepared by the user for Stathab and  the Stathab model
which is in the src folder (stathab\_c.py) using the graphical interface.  Most of the Stathab input are given in
form of text file. For more info on the preparation of text files for stathab, read the document called
`stathabinfo.pdf''.  To use Stathab in HABBY, all Stathab input should be in the same directory. The user select
this directory (using the button “loadb”) and HABBY tries to find the file it needs. All found files are added to
the list called “file found”. If file are missing, they are added to the “file still needed” list.  The user can then
select the fishes on which it wants to run stathab, then it run it by pressing on the “runb” button.

If file where loaded before by the user in the same project, StathabW looks for them and load them again. Here we
can have two cases: a) the data was saved in hdf5 format (as it is done when a stathab run was done) and the path
to this file noted in the xml project file. b) Only the name of the directory was written in the xml project file,
indicated that data was loaded but not saved in hdf5 yet. HABBY manages both cases.

Next, we check in the xml project file where the folder to save the figure (path\_im) is. In case, there are
no path\_im saved, Stathab create one folder to save the figure outputs. This should not be the usual case. Generally,
path\_im is created with the xml project file, but you cannot be sure.

There is a list of error message which are there for the case where the data which was loaded before do not exist
anymore. For example, somebody erased the directory with the Stathab data in the meantime.  In this case,
a pop-up message open and warn the user.

An important attribute of StathabW() is self.mystathab. This is an object fo the stahab class. The stathab model,
which is in the form of a class and not a function, will be run on this object.
\index{add\_all\_fish() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.add_all_fish}}\pysiglinewithargsret{\sphinxbfcode{add\_all\_fish}}{}{}
This function add the name of all known fish (the ones in Pref.txt) to the QListWidget.

\end{fulllineitems}

\index{add\_fish() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.add_fish}}\pysiglinewithargsret{\sphinxbfcode{add\_fish}}{}{}
This function add the name of one fish species to the selected list of fish species.

\end{fulllineitems}

\index{init\_iu() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
\end{fulllineitems}

\index{load\_from\_hdf5\_gui() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.load_from_hdf5_gui}}\pysiglinewithargsret{\sphinxbfcode{load\_from\_hdf5\_gui}}{}{}
This function calls from the GUI the load\_stathab\_from\_hdf5 function. In addition to call the function to load
the hdf5, it also updates the GUI according to the info contained in the hdf5.

\sphinxstylestrong{Technical comments}

This functino updates the Qlabel similarly to the function “load\_from\_txt\_gui()”.
It also loads the data calling the load\_stathab\_from\_hdf5 function from the Stathab class in src. The info
contains in the hdf5 file are now in the memory in various variables called self.mystathab.”something”.
HABBY used them to update the GUI. First, it updates the list which contains the name of the reaches
(self.list\_re.). Next, it checks that each of the variable needed exists and that they contain some data.
Afterwards, HABBY looks which preference file to use. Either, it will use the default preference file
(contained in HABBY/biology) or a custom preference prepared by the user. This custom preference
file should be in the same folder than the hdf5 file. When the preference file was found, HABBY reads all
the fish type which are described and add their name to the self.list\_f list which show the available fish
to the user in the GUI. Finally it checks if all the variables were found or if some were missing

\end{fulllineitems}

\index{load\_from\_txt\_gui() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.load_from_txt_gui}}\pysiglinewithargsret{\sphinxbfcode{load\_from\_txt\_gui}}{}{}
The main roles of load\_from\_text\_gui() are to call the load\_function of the stathab class (which is in
stathab\_c.py in the folder src) and to call the function which create an hdf5 file. However, it does some
modifications to the GUI before.

\sphinxstylestrong{Technical comments}

Here is the list of the modifications done to the graphical user interface before calling the load\_function of
Stathab.

First, it updates the label. Because a new directory was selected, we need to update the label containing the
directory’s name. We only show the 30 last character of the directory name. In addition, we also need to update
the other label. Indeed, it is possible that the data used by Stathab would be loaded from an hdf5 file.
In this case, the labels on the top of the list of file are slightly modified. Here, we insure that we are in
the “text” version since we will load the data from text file.

Next, it gets the name of all the reach and adds them to the list of reach name. For this, it calls a function
from the stathab class (in src). Then, it looks which files are present and add them to the list which contains
the reach name called self.list\_re.

Afterwards, it checks if the files needed by Stathab are here. The list of file is given in the
self.end\_file\_reach list. The form of the file is always the name of the reach + one item of
self.end\_file\_reach. If it does not find all files, it add the name of the files not found to self.list\_needed,
so that the user can be aware of which file he needs. The exception is Pref.txt. If HABBY do not find it in the
directory, it uses the default “Pref.txt”. All files (apart from Pref.txt) should be in the same directory.

Then, it calls a method of the Stathab class (in src) which reads the “pref.txt” file and adds the name
of the fish to the GUI. Next, if all files are present, it loads the data using the method written in Stathab
(in the src folder). When the data is loaded, it creates an hdf5 file from this data and save the name of this
new hdf5 file in the xml project file (also using a method in the stathab class).

Finally, it sends the log info as explained in the log section of the documentation

\end{fulllineitems}

\index{reach\_selected() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.reach_selected}}\pysiglinewithargsret{\sphinxbfcode{reach\_selected}}{}{}
A function which indcates which files are linked with which reach.

\sphinxstylestrong{Technical comment}

This is a small function which only impacts the GUI. When a Stathab model has more than one reach,
the user can click on the name of the reach. When he does this, HABBY selects the first file linked
with this reach and shows it in self.list\_f. This first file is highlighted and the list is scrolled
down so that the files linked with the selected reach are shown. This function manages this. It is connected
with the list self.list\_re, which is the list with the name of the reaches.

\end{fulllineitems}

\index{remove\_fish() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.remove_fish}}\pysiglinewithargsret{\sphinxbfcode{remove\_fish}}{}{}
This function remove the name of one fish species to the selected list of fish species.

\end{fulllineitems}

\index{run\_stathab\_gui() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.run_stathab_gui}}\pysiglinewithargsret{\sphinxbfcode{run\_stathab\_gui}}{}{}
This is the function which calls the function to run the Stathab model.  First it read the list called
self.list\_s. This is the list with the fishes selected by the user. Then, it calls the function to run
stathab and the one to create the figure if the figures were asked by the user. Finally, it writes the log.

\end{fulllineitems}

\index{select\_dir() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.select_dir}}\pysiglinewithargsret{\sphinxbfcode{select\_dir}}{}{}
This function is used to select the directory and find the files to laod stathab from txt files. It calls
load\_from\_txt\_gui() when done.

\end{fulllineitems}

\index{select\_hdf5() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.select_hdf5}}\pysiglinewithargsret{\sphinxbfcode{select\_hdf5}}{}{}
This function allows the user to choose an hsdf5 file as input from Stathab.

\sphinxstylestrong{Technical comment}

This function is for example useful if the user would have created an hdf5 file for a Stathab model in another
project and he would like to send the same model on other fish species.

This function writes the name of the new hdf5 file in the xml project file. It also notes that the last data
loaded was of hdf5 type. This is useful when HABBY is restarting because it is possible to have a
directory name and the address of an hdf5 file in the part of the xml project file concerning Stathab.
HABBY should know if the last file loaded was this hdf5 or the files in the directory.
Finally, it calls the function to load the hdf5 called load\_from\_hdf5\_gui.

\end{fulllineitems}

\index{send\_err\_log() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.send_err_log}}\pysiglinewithargsret{\sphinxbfcode{send\_err\_log}}{}{}
Send the errors and warnings to the logs. It is useful to note that the stdout was redirected to self.mystdout.

\end{fulllineitems}

\index{send\_log (src\_GUI.stathab\_GUI.StathabW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.send_log}}\pysigline{\sphinxbfcode{send\_log}}
A PyQtsignal used to write the log.

\end{fulllineitems}

\index{show\_fig (src\_GUI.stathab\_GUI.StathabW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.show_fig}}\pysigline{\sphinxbfcode{show\_fig}}
A PyQtsignal used to show the figures.

\end{fulllineitems}


\end{fulllineitems}



\section{Estimhab - GUI}
\label{\detokenize{index:estimhab-gui}}
in src\_GUI/estimhab\_GUI.py
\phantomsection\label{\detokenize{index:module-src_GUI.estimhab_GUI}}\index{src\_GUI.estimhab\_GUI (module)}\index{EstimhabW (class in src\_GUI.estimhab\_GUI)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.EstimhabW}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.estimhab\_GUI.}\sphinxbfcode{EstimhabW}}{\emph{path\_prj}, \emph{name\_prj}}{}
The Estimhab class provides the graphical interface for the version of the Estimhab model written in HABBY.
The Estimhab model is described elsewhere. EstimhabW() just loads the data for Estimhab given by the user.
\index{add\_fish() (src\_GUI.estimhab\_GUI.EstimhabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.EstimhabW.add_fish}}\pysiglinewithargsret{\sphinxbfcode{add\_fish}}{}{}
The function is used to select a new fish species

\end{fulllineitems}

\index{change\_folder() (src\_GUI.estimhab\_GUI.EstimhabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.EstimhabW.change_folder}}\pysiglinewithargsret{\sphinxbfcode{change\_folder}}{}{}
A small method to change the folder which indicates where is the biological data

\end{fulllineitems}

\index{find\_path\_im\_est() (src\_GUI.estimhab\_GUI.EstimhabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.EstimhabW.find_path_im_est}}\pysiglinewithargsret{\sphinxbfcode{find\_path\_im\_est}}{}{}
A function to find the path where to save the figues. Careful there is similar function in hydro\_GUI\_2.py.
Do not mix it up
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
path\_im a string which indicates the path to the folder where are save the images.

\end{description}\end{quote}

\end{fulllineitems}

\index{init\_iu() (src\_GUI.estimhab\_GUI.EstimhabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.EstimhabW.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
This function is used to initialized an instance of the EstimhabW() class. It is called be \_\_init\_\_().
\begin{quote}

\sphinxstylestrong{Technical comments and walk-through}

First we looked if some data for Estimhab was saved before by an user. If yes, we will fill the GUI with
the information saved before. Estimhab information is saved in hdf5 file format and the path/name of the
hdf5 file is saved in the xml project file. So we open the xml project file and look if the name of an hdf5
file was saved for Estimhab. If yes, the hdf5 file is read.

The format of hdf5 file is relatively simple. Each input data for Estimhab has its own dataset (qmes, hmes,
wmes, q50, qrange, and substrate).  Then, we a list of string which are a code for the fish species which
were analyzed.  All the data contained in hdf5 file is loaded into variable.

The different label are written on the graphical interface. Then, two QListWidget are modified. The first
list contains all the fish species on which HABBY has info (see XML Estimhab format for more info).
The second list is the fish selected by the user on which Estimhab will be run. Here, we link these lists
with two functions so that the user can select/deselect fish using the mouse. The function name are add\_fish()
and remove\_fish().

Then, we fill the first list. HABBY look up all file of xml type in the “Path\_bio” folder (the one indicated in
the xml project file under the attribute “Path\_bio”).  The name are them modified so that the only the name of
species appears (and not the full path). We set the layout with all the different QLineEdit where the user
can write the needed data.

Estimhab model is saved using a function situated in MainWindows\_1.py  (frankly, I am not so sure why I did put
the save function there, but anyway). So the save button just send a signal to MainWindows
here, which save the data.
\end{quote}

\end{fulllineitems}

\index{remove\_fish() (src\_GUI.estimhab\_GUI.EstimhabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.EstimhabW.remove_fish}}\pysiglinewithargsret{\sphinxbfcode{remove\_fish}}{}{}
The function is used to remove fish species

\end{fulllineitems}

\index{run\_estmihab() (src\_GUI.estimhab\_GUI.EstimhabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.EstimhabW.run_estmihab}}\pysiglinewithargsret{\sphinxbfcode{run\_estmihab}}{}{}
A function to execute Estimhab by calling the estimhab function.

\sphinxstylestrong{Technical comment}

This is the function making the link between the GUI and the source code proper. The source code for Estimhab
is in src/Estimhab.py.

This function loads in memory the data given in the graphical interface and call sthe Estimhab model.
The data could be written by the user now or it could be data which was saved in the hdf5 file before and
loaded when HABBY was open (and the init function called).  We check that all necessary data is present and
that the data given makes sense (e.g.,the minimum discharge should not be bigger than the maximal discharge,
the data should be a float, etc.). We then remove the duplicate fish species (in case the user select one
specie twice) and the Estimhab model is called. The log is then written (see the paragraph on the log for more
information). Next, the figures created by Estimmhab are shown. As there is only a short number of outputs
for Estimhab, we create a figure in all cases (it could be changed by adding a checkbox on the GUI like
in the Telemac or other hydrological class).

\end{fulllineitems}

\index{save\_signal\_estimhab (src\_GUI.estimhab\_GUI.EstimhabW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.EstimhabW.save_signal_estimhab}}\pysigline{\sphinxbfcode{save\_signal\_estimhab}}
PyQtsignal to save the Estimhab data.

\end{fulllineitems}

\index{send\_log (src\_GUI.estimhab\_GUI.EstimhabW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.EstimhabW.send_log}}\pysigline{\sphinxbfcode{send\_log}}
PyQtsignal to write the log.

\end{fulllineitems}

\index{show\_fig (src\_GUI.estimhab\_GUI.EstimhabW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.EstimhabW.show_fig}}\pysigline{\sphinxbfcode{show\_fig}}
PyQtsignal to show the figures.

\end{fulllineitems}


\end{fulllineitems}



\subsection{Biological data - Estimhab}
\label{\detokenize{index:biological-data-estimhab}}
The biological data, i.e., the preference curves of Estimhab, are saved in xml files
situated in the folder given by the path written in the xml project file under the
attribute Path\_bio. By default, it is HABBY/biology. It is possible to change this folder
using the GUI.

Estimhab is a statistical model, which functions using mathematical regressions.
The different regressions (or preference curve) of each fish are described in an xml file
whose format is given here.

Conceptually, the regressions R are of two types:
\begin{itemize}
\item {} 
Type 0          R = C * Q\textasciicircum{}\{m1\} * exp(m2*Q)

\item {} 
Type 1          R = C * (1+m1*exp(m2*Q))

\end{itemize}

Where Q is the discharge, m1 and m2 are coefficients which depend on the fish type, and C is a
constant which depends on the stream characteristic and the fish type.

The constant C is of the form C = a + sum ai * ln(Si) where a and ai are coefficients which depend on
the fish type. Si are particular stream characteristics. Which characteristics should be used is a
function of the fish type and is so given in the xml file. The value of S i is a function of the stream
and is calculated by the program.

In the xml file,
\begin{itemize}
\item {} 
Attribute coeff\_q: Give the main coefficients of the regression (m1 and m2)

\item {} 
Attribute func\_q : Give the type of regression R used.  Type 0 and type 1, as described above, are known by HABBY.

\item {} 
Attribute coeff\_const: Give the coefficient used to construct the constant C (a, a1, a2, a3,…). The number of coefficient differs for each fish, but should be at least one.

\item {} 
Attribute var\_const: Give which type of stream characteristics is used. This is not the value of the particular characteristic, but only which type is used. The following list of type is accepted:
\begin{itemize}
\item {} 
0 for Q50, natural median discharge

\item {} 
1 for H50, the height of the stream at q50

\item {} 
2 for L50, the width of the stream at q50

\item {} 
3 for V50, the velocity of the stream at q50

\item {} 
4 for Re50, the discharge divided by 10 times the width at Q50

\item {} 
5 for Fr50, the Froude number at Q50

\item {} 
6 for Dh50, the mean substrate height divided by h50

\item {} 
7 for Exp(Dh50). Erase the log() of this particular term of the constant

\end{itemize}

\end{itemize}


\chapter{Calculation of fish's habitat}
\label{\detokenize{index:calculation-of-fish-s-habitat}}
The src folder contains the python module which are not linked with the graphical user interface.
\phantomsection\label{\detokenize{index:module-src}}\index{src (module)}

\section{Hec-ras model 1D}
\label{\detokenize{index:hec-ras-model-1d}}
in src/Hec\_ras06.py

This module contains the functions used to load the outputs from the hec-ras model in 1.5D.
\phantomsection\label{\detokenize{index:module-src.Hec_ras06}}\index{src.Hec\_ras06 (module)}\index{coord\_profile\_non\_georeferenced() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.coord_profile_non_georeferenced}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{coord\_profile\_non\_georeferenced}}{\emph{data\_bank\_all}, \emph{data\_dist\_all}, \emph{data\_river\_all}, \emph{data\_profile\_all}, \emph{nb\_pro\_reach}}{}
This is a function to create the coordinates of the profile in the non-georeferenced case.
This function is called by open geo\_file(). Hypothesis: The profile are straight and perpendicular to the river.
The last profile is at the end of the river.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{data\_bank\_all} -- distance along the profile of bank station

\item {} 
\sphinxstyleliteralstrong{data\_dist\_all} -- the distance between the profile (left, center channel, right)

\item {} 
\sphinxstyleliteralstrong{data\_river\_all} -- the coordinate of the river

\item {} 
\sphinxstyleliteralstrong{data\_profile\_all} -- the (d,z) data of the profile

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- the number of profile by reach

\end{itemize}

\item[{Returns}] \leavevmode
the coordinates of the profile

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

For each profile, we create an array composed of five points: Start of profile, left bank, intersection between
river and profile, right bank and end of profile. The intersection with the river is directly given as input to
the function. Then we find the vector perpendicular to this river and we get the four other points on the same line.

To get the distance for these four other point, we must be careful to pass from the distance given in meter and the
distance in the model coordinates (scaled between {[}0, 1{]} usually). The way to go from one coordinate system to
another is to use the “alpha” variable.  We only need to correct distance, no problem with a system of coordinate
which would not be in the same direction (as the data is given along a profile). The river passes in the middle of
the right and left bank, so we can find where is left and right bank is. Because we know the total length of the
profile, we can also find the beginning and end of the profile.

\end{fulllineitems}

\index{figure\_xml() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.figure_xml}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{figure\_xml}}{\emph{data\_profile}, \emph{coord\_pro\_old}, \emph{coord\_r}, \emph{xy\_h\_all}, \emph{zone\_v\_all}, \emph{pro}, \emph{path\_im}, \emph{nb\_sim=0}, \emph{name\_profile='no\_name'}, \emph{coord\_p2=-99}}{}
A function to plot the results of the loading of hec-ras data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{data\_profile} -- (list with np.array)

\item {} 
\sphinxstyleliteralstrong{coord\_pro\_old} -- (x,y) data of the profile (list with np.array)

\item {} 
\sphinxstyleliteralstrong{coord\_r} -- (x,y) data of the river (list with np.array)

\item {} 
\sphinxstyleliteralstrong{xy\_h\_all} -- (x,y, h) for the height data for each simulation (list with np.array)

\item {} 
\sphinxstyleliteralstrong{zone\_v\_all} -- (x,y, v) for the velocity data. velocity is by zone of profile. for each simulation.
the (x,y) indicates the start of the zone which end with the next velocity

\item {} 
\sphinxstyleliteralstrong{pro} -- a list of int with the profile whcih should be ploted {[}2,3,4{]}

\item {} 
\sphinxstyleliteralstrong{nb\_sim} -- which simulation should be plotted. In fact, it often relates to the time step.

\item {} 
\sphinxstyleliteralstrong{name\_profile} -- a list of string with the name of the profiles

\item {} 
\sphinxstyleliteralstrong{coord\_p2} -- the data of the profile when non geo-referenced, optional

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where the figure should be saved (string)

\end{itemize}

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

We first choose the size of the font to be written. At term, it should be given by the options.

Two main groups of figure will be done: One list of figure with the form of the profil, the water height, and the
velocity for the chosen profiles and one (x,y) view of the position of each profile.

We chose the time step to be written (the variable nb\_sim here). The variable pro is a list which says which
profiles are to be plotted. Hence, we get the velocity and water height for the time step and profile of interest.

To plot the velocity, we first get the distance along the profile where the water level cut the profile elevation.
This is the variable xint1 and xint2. We then get the velocity data for the region under the water. We add three
points for velocity at 0, xint1 and xint2. We then used the step function to plot the vecloity. Because of the added
point, we will have a zero velocity from 0 to xint1, then the velocity data, then again zeros from xint2 to the end.

To plot the elevation of the profile, we plot the variable xz and we use the function fill\_between to fill
in blue the region under water. This function creates a line at the water elevation and fills in blue between this
line and the profile elevation. We add some titles and save the figures.

For the second type of figure (view in x,y coordinates), We first plot the river position which is saved in the
coord\_r variable. Then we plot the coordinate of each profile and their names. If the name of the profile is not
known, we plot the profile number.  We also plot the position of each velocity data and height data (as it could be
useful). If the figure gets too complicated, this can be taken away by changing the two lines which finish
with height or velocity as comment.  We add some titles and save the figures.

\end{fulllineitems}

\index{find\_coord\_height\_velocity() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.find_coord_height_velocity}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{find\_coord\_height\_velocity}}{\emph{coord\_pro}, \emph{data\_profile}, \emph{vel}, \emph{wse}, \emph{nb\_sim}, \emph{max\_vel\_dist=0}}{}
This function finds the coordinates of the height/velocity. In hec-ras outputs the data are often written in the
form (profile, distance along the profile, data). This function passes this type of information in the usual
coordinate form.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the coordinate (x,y) of the profile. List of np.array.

\item {} 
\sphinxstyleliteralstrong{data\_profile} -- data concening the geometry of the profile, notably its elevation (x,z). List of np.array.

\item {} 
\sphinxstyleliteralstrong{vel} -- the velocity data. List of np.array.

\item {} 
\sphinxstyleliteralstrong{wse} -- the water surface elevation. List of np.array.

\item {} 
\sphinxstyleliteralstrong{nb\_sim} -- the number of simulation in case there is more than one

\item {} 
\sphinxstyleliteralstrong{max\_vel\_dist} -- the minimum number of velocity point by ten meter before a warnings appears

\end{itemize}

\item[{Returns}] \leavevmode
for each simulation, a list of np.array representing (x,y,v) and (x,y,h,)

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

This is a function called after having loaded the data. Hec-Ras present the data in (profil, distance along
profile, data) form for the height. For the velocity, it is similar but the distance is given by a number between
0 and 1 (0 is the start of the profile, 1 is the end of the profile). This function transforms this data in the form
(x,y, dist, data) using the (x,y) coordinates given in the coord\_pro variable. In other word,  we have the
coordinate of the profile, not of the coordinates of the height and velocity data.

First, we get the distance between all points in (x,y) system. Then, we get the length of the profile in
meter or feet. It is possible to have a (x,y) coordinate system in a different unit. Hence, the length of the profil
is valid for the (profile, distance along profile, data) view. We multiply the velocity distance data by this
length. Hence, the distance information is now in meter or feet along the profile for water height and velocity.

There are some lines added to account for the last and first points of the profile (annoying in hec-ras). We then
calculate the new coordinates. For each velocity and water height point, we find the last known point in the (x,y)
coordinates. We do a vectorial addition from this point plus the vector between this point and the next multiplied
by the distance from this point to the point that we tried to calculate.  The variable alpha is used to pass from
one coordinate system to the next one.

Careful the height is on the node and the velocity is by zone.

\end{fulllineitems}

\index{get\_rid\_of\_white\_space() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.get_rid_of_white_space}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{get\_rid\_of\_white\_space}}{\emph{stream\_str}}{}
This is a small fonction to get rid of white space at the end of name which could contain white space. Not used
anymore as str.strip() functions well. But, as it was done already, we let it here.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{stream\_str} -- the name of the string

\item[{Returns}] \leavevmode
the same name without white space.

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_xml() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.load_xml}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{load\_xml}}{\emph{xml\_file}, \emph{path}}{}
This is a function used by openxml\_file and opengml\_file to load an xml file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{xml\_file} -- the name of an xml file (string)

\item {} 
\sphinxstyleliteralstrong{path} -- the path where the xml file is (string)

\end{itemize}

\item[{Returns}] \leavevmode
the loaded data from the XML file in the form of the root of the xml file.

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.main}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{main}}{}{}
This is not the main() of HABBY. This function is used to test this module independently of the rest of HABBY.

\end{fulllineitems}

\index{open\_geofile() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.open_geofile}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{open\_geofile}}{\emph{geo\_file}, \emph{path}}{}
This function opens the geometry file (.g0X) from Hecr-rad. It extracts the (x,z) from each profile
and the (x,y) if georeferenced,
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{geo\_file} -- the name of the Hec-Ras geometry file (string)

\item {} 
\sphinxstyleliteralstrong{path} -- the path to the geo file (string)

\end{itemize}

\item[{Returns}] \leavevmode
A list with each river profile (each profile is represented by a numpy array with the x and the altitude
of each point in the profile), the coordinate of the profile (list of np.array),
the coordinate of the river and the name of the reaches/ river in the file order (list of string)

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

The geofile is a text file with contains the geographical information. Because it is written to be read by human,
it is complicated to load and regular expression are needed. It is written profile by profile.

Generally, to give a position, hec-ras indicates the profile number and the distance along this profile. In addition,
data can be georeferenced or not. If it is geo-referenced we have some data in an (x,y) form. Otherwise, we only
have geometrical data in the form (profile, dist).

First, for each profile, we get the elevation of the points forming each profile in the form (dist, elevation).
The list of elevation for each profile starts with the keyword “Sta/Elev”. The data found in the text file is in a
string format. We use the function pass\_in\_float\_from\_geo to pass it in float. It is usually done using the function
float. However, there are cases where there are no space between two number. However, in this case, the number of
character per number is constant. In this case, we separate the number first.

Then, we get the coordinate of the river. If no coordinate are available the river is assumed to be straight. Next,
we get the bank limit (even if we do not really used afterwards), and the name of the reach. It is also important
to save the order in which the names of the reach are given. Indeed, we want this order to be the same in all
functions, but they can be different between the geo file and the data output.

Next, we want to get the position (x,y) of each profile. If it is georeferenced, we will be able to get this
position directly from the file and put it in the data\_dist\_str variable. We will then pass it to float. If not,
we will use the function coord\_profil\_non\_georeferenced to estimate the position of the profile (see below).

If the profile is not georeferenced, it is important to have the distance between two profile, so we extract the
information from the geo file in all cases (georeferenced or not). The last profile of a reach does not have a
distance to the next (not existing) profile. However, if a profile does not have a distance to the next profile
and is not the last profile, we ignore this profile. It is usually not a problem because this profile is usually
not a “real” profile, but the representation of a bridge or a culvert.

\end{fulllineitems}

\index{open\_hecras() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.open_hecras}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{open\_hecras}}{\emph{geo\_file}, \emph{res\_file}, \emph{path\_geo}, \emph{path\_res}, \emph{path\_im}, \emph{save\_fig=False}}{}
This function will open HEC-RAS outputs, i.e. the .geo file and the outputs (either .XML, .sdf or .rep) from HEC-RAS.
All arguments from this function are string.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{geo\_file} -- the name of .goX (example .go3) file which is an output from hec-ras containg the profile data

\item {} 
\sphinxstyleliteralstrong{res\_file} -- the name of O0X.xml file for the name of the .sdf file  or the name of the .rep file (output data)

\item {} 
\sphinxstyleliteralstrong{path\_res} -- path to the result file

\item {} 
\sphinxstyleliteralstrong{path\_geo} -- path to the geo file

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path to the folder where the images should be saved

\item {} 
\sphinxstyleliteralstrong{save\_fig} -- if True image is saved

\end{itemize}

\item[{Returns}] \leavevmode
coord\_pro (for each profile, x,y,elev, dist along the profile), vh\_pro
(for each profile, dist along the profile, water height, velocity). Both variable are a list of numpy array.

\end{description}\end{quote}

\sphinxstylestrong{How to obtain the input files}

To obtain the xml file in HEC-RAS version 4:
\begin{itemize}
\item {} 
open the project in HEC-RAS.

\item {} 
click on File , then export geometry and result (RAS Mapper), then OK

\end{itemize}

To obtain the sdf file in HEC-RAS version 5 which should be used if the model is georeferenced:
\begin{itemize}
\item {} 
click on File, then Export GIS data

\item {} 
Export all reaches (select Reaches to export -. Full List -\textgreater{} Ok)

\item {} 
Export all needed profile (select Profile to export -\textgreater{} Select all -\textgreater{} ok)

\end{itemize}

To obtain the report file .rep in HEC-RAS version which should be used if the model is NOT geo-referenced
\begin{itemize}
\item {} 
click on File, generate report

\item {} 
Select Flow data and Geometry data in input data and, in Specific Table, select Flow distribution and
Cross section Table

\end{itemize}

\sphinxstylestrong{Technical comments}

This is function which loads the hec\_ras inputs in 1D for the version 4 and 5 of HEC-RAS. It accepts different type
of hec-ras output as input and calls the appropriate sub-function for each input file.  The geometrical data is
always given in the geo file (with the extension g01, G01, g02, G02, g03, etc.). The output data can be in an xml
file for the hec-ras in the version 4, an sdf file for hec-ras in version 5 or a .rep file in the version 5 if the
model is not georeferenced. The xml file is the format which has been tested the most.

First, it loads the geometrical data. Then it select the function to load the output data and loads it. Then, it
transforms the loaded data in a (x,y) coordinates system. Indeed, most of the data in hec-ras is given by indicating
a profile (which crossed the modelled river) and the distance along this profile. For HABBY, it is better to get
(x,y) coordinates. Then it create figure if asked by the switch “save\_fig”. Finally, it updates the forms of the
output to be coherent with the dist\_velocity\_hecras function.  This way, in HABBY, the output from mascaret and
rubar after the velocity distribution have the same form than the output from hec-ras, which is useful afterwards
to save all these data in the hdf5 file.

\end{fulllineitems}

\index{open\_repfile() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.open_repfile}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{open\_repfile}}{\emph{report\_file}, \emph{reach\_name}, \emph{path}, \emph{data\_profile}, \emph{data\_bank}}{}
A function to open the report file (.rep) from HEC-RAS. To obtain the report file, see the doc of the function
open\_hecras.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{report\_file} -- a string with the name of the report file (.rep)

\item {} 
\sphinxstyleliteralstrong{reach\_name} -- a list of string containing the name of the reaches/rivers in the order of the geo file,
which might not be the order of the sdf file.

\item {} 
\sphinxstyleliteralstrong{path} -- the path where the report file is stored (string)

\item {} 
\sphinxstyleliteralstrong{data\_profile} -- the data from each profile from the geofile (output from the open\_geofile function)

\item {} 
\sphinxstyleliteralstrong{data\_bank} -- the position of the bank limit (output from the open\_geofile function)

\end{itemize}

\item[{Returns}] \leavevmode
velocity and the water surface elevation for each river profiles in a list of np.array,
the number of simulation (int) and the name of the river profile (list of string)

\end{description}\end{quote}

\sphinxstylestrong{Technical comments and walk-through}

This function is used to open output from models which were not geo-referenced in hec-ras v5. It cannot be used if
the model was georeferenced (or at least one should make some tests before).

First, we obtain the water height. Then, we obtain the number of time step (which is called the number of
simulation by hec-ras). To get the number of time step, we count each outputs given (one by profiles) and we
divided it by the number of profile in the river. It is a bit indirect, but I did not find a simpler solution.

We get the name of each profile and reach. Then, we get the velocity data. We have in a case which is not
geo-referenced. By consequence, there are only three velocities: one the left bank, one in the main river channel
and one the right bank.  Next we get the distance along the profile for these three velocities. Finally, we use
the function reoder\_reach for the same reason than in open\_sdffile and open\_xml.

\end{fulllineitems}

\index{open\_sdffile() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.open_sdffile}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{open\_sdffile}}{\emph{sdf\_file}, \emph{reach\_name}, \emph{path}}{}
This is a function to load .sdf file from HEC-RAS v5 used if the model is georeferenced. To find how to obtain the
sdf file, read the doc of open\_hecras.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{sdf\_file} -- the name of the sdf file (string)

\item {} 
\sphinxstyleliteralstrong{reach\_name} -- a list of string containing the name of the reaches/rivers in the order of the geo file
which might not be the one of the sdf file. Output from open\_geofile.

\item {} 
\sphinxstyleliteralstrong{path} -- the path where the file is stored (string)

\end{itemize}

\item[{Returns}] \leavevmode
velocity, water height, river\_name, number of  time step (nb\_sim)

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

To strat loading the sdf file, we open the sdf file. It is mostly a text file. Then we find velocity data and we
pass this velocity data from string to float. The process is a bit similar to the one used in the function
open\_geofile with a healthy dose of regular expressions. We do this again for height data.

We also extract the name of the river, reaches and profile. The number of simulation (nb\_sim) is a bit confusing
for a variable name. In fact, it is the number of time step. Hec-Ras considers that one simulation is the simulation
for one time step. Hence, nb\_sim is more or less nb\_timestep.

As in the xml file, we finally re-order the data as in the geo file. Indeed, it is possible to have different order
between the reaches in the geo file and in the sdf file. Here, we use the function reorder\_reach for this.

\end{fulllineitems}

\index{open\_xmlfile() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.open_xmlfile}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{open\_xmlfile}}{\emph{xml\_file}, \emph{reach\_name}, \emph{path}}{}
This function open the xml file from HEC-RAS v4 to get the velocity and water surface elevation. To know how to
obtain this xml file, read the doc of open\_hecras.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{xml\_file} -- the name of O0X.xml file from HEC-RAS. (string)

\item {} 
\sphinxstyleliteralstrong{reach\_name} -- a list of string containing the name of the reaches/rivers in the order of the geo file
which might not be the one of the xml file.

\item {} 
\sphinxstyleliteralstrong{path} -- path to the xml file (string)

\end{itemize}

\item[{Returns}] \leavevmode
velocity and the water surface elevation for each river profiles (list of np.array),
the number of simulation(int) and the name of the river profile (list of string)

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

To load the xml file, we first call the load\_xml function. It is a function which check that the xml file is well
formed and which return the “root” part fo the xml. With this “root”, it is possible to load other part of the xml
file using the Etree module.

Then, we load the velocity and water height data from the xml file. We also load the name of the profiles and of
the reach names.  Next, we pass the data into float. For each velocity of height point, we get its position along
the profile (see below for format) and the value at this point.

Finally, we re-order the data as in the geo file. Indeed, it is possible to have different order between the reaches
in the geo file and in the xml file. The last part of this function is there to order all the data as in the geo
file. There is a function reorder\_reach which does something similar, but could not be used by the output from the
xml file (it is slighty different). However the reorder\_reach function and this part of the open\_xml function is
very similar.

\end{fulllineitems}

\index{pass\_in\_float\_from\_geo() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.pass_in_float_from_geo}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{pass\_in\_float\_from\_geo}}{\emph{data\_str}, \emph{len\_number}}{}
This is a function to pass the string data into float for open\_geofile() and open\_sdffile(). It is in a function
because it is possible that two number are not separated by a space in the input data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{data\_str} -- the data in a string form

\item {} 
\sphinxstyleliteralstrong{len\_number} -- the number of digit for one number (int)

\end{itemize}

\item[{Returns}] \leavevmode
a np.array of float with 2 columns  (x,y) or (x,z)

\end{description}\end{quote}

\end{fulllineitems}

\index{reorder\_reach() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.reorder_reach}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{reorder\_reach}}{\emph{wse}, \emph{vel}, \emph{riv\_name}, \emph{reach\_name}, \emph{reach\_str}, \emph{stream\_str}, \emph{nb\_sim}}{}
The order of the reach in HABBY is in the order given in the geo file. However, it can be given in any order
in the other file. (xml, sdf, rep,...). This function re-order the reaches based on their name.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{wse} -- water height data (list of np.array for each profile)

\item {} 
\sphinxstyleliteralstrong{vel} -- velocity data (list of np.array for each profile)

\item {} 
\sphinxstyleliteralstrong{riv\_name} -- the name of the profile (yeah I know it is not really logical as a name)

\item {} 
\sphinxstyleliteralstrong{reach\_name} -- the name of the reach and stream (stream,reach) in the geo file order

\item {} 
\sphinxstyleliteralstrong{reach\_str} -- the name of the reach in the anaylsed file order

\item {} 
\sphinxstyleliteralstrong{stream\_str} -- the name of the stream in the anaylsed file order

\item {} 
\sphinxstyleliteralstrong{nb\_sim} -- the number of simulation

\end{itemize}

\item[{Returns}] \leavevmode
wse, vel, riv\_name all re-ordered

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

The reach name should not have white space at the end/start but can have white space into them.

\end{fulllineitems}

\index{update\_output() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.update_output}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{update\_output}}{\emph{zone\_v}, \emph{coord\_pro\_old}, \emph{data\_profile}, \emph{xy\_h}, \emph{nb\_pro\_reach\_old}}{}
This function updates the form of the output so it is coherent with mascaret and rubar after the lateral
distribution of velocity for these two models. There are three important changes. First, coord\_pro contains dist along
the profile (x) and height in addition to the coordinates. Secondly, vh\_pro contains only height if height is above
or equal to zero. Thirdly, a point is created at the water limits and v and height are given at the same points.
nb\_pro\_reach is also modified as in mascaret. We want to modify it so it start by zero and is additive, i.e., that
it gives total number of profile before, not the number of profile by reach.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{zone\_v} -- (x,y, dist along profile, v) for each time step. However, the zone are the one from the models.
They are different than the one from xy\_h, which is unpractical for the rest of HABBY.

\item {} 
\sphinxstyleliteralstrong{coord\_pro\_old} -- the (x,y) coordinate for the profile

\item {} 
\sphinxstyleliteralstrong{data\_profile} -- the distance along the porfile and height of each profile

\item {} 
\sphinxstyleliteralstrong{xy\_h} -- the water height

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach\_old} -- the number of the profile by reach in the old form.

\end{itemize}

\item[{Returns}] \leavevmode
coord\_pro, vh\_pro, nb\_pro\_reach

\end{description}\end{quote}

{[}doc to be finished{]}

\end{fulllineitems}



\subsection{Notes on hec-ras outputs}
\label{\detokenize{index:notes-on-hec-ras-outputs}}\begin{itemize}
\item {} 
Data in HEC-RAS can be geo-referenced or not georeferenced. It is advised to geo-reference
all model in HEC-RAS. If the model is not geo-referenced, the function makes some assumptions to
load the data: 1) the river profile are straight and perpendicular to the river.
2) the last profile is at the end of the river.

\item {} 
To geo-reference a model in hec\_ras: In the “geometric data” window, GIS tool, GIS Cut Line, Accept Display location, choose all profile

\item {} 
Numerical data are sometime not separated (0.4556 0.3453233.454 05.343). In this case, the number of digit is assumed to be 8 for the profile and 16 for the river coordinates.

\item {} 
Part of the profile can be vertical: The function also functions in this case.

\item {} 
There is sometimes more than one reach in the modelled river and these reaches sometimes form loops: The function load each reach one after the other.

\item {} 
The river reaches are sometimes not in the same order in the xml file and in the .goX file. The order of the .goX is used by the function. Reach are automatically re-ordered.

\item {} 
If the river is straight, the coordinates of the river are given differently. The function try to load the river in the “straight” style if the usual style fail.

\item {} 
The .goX file includes data on bridges and culvert. Currently, the function neglects this information.

\item {} 
Sometimes distances between profiles are not given in the .goX file. The function neglects the distance data of this profile as long as it is not the last profile.

\item {} 
The velocity data for the end and the beginning of the river profile is indicated by a large number (example 1.23e35 or -1.234e36). The function considers that velocity info is situated at the start of the profile if x\textgreater{}-1e30 and at the end of the profile if x\textgreater{} 1e30.

\item {} 
There are two concepts called “profile” in HEC-RAS: The river profiles and the simulation profiles. The river profiles are the geometry perpendicular to the river and the simulation profile are the different simulations.

\item {} 
Data in many of the example cases of HEC-RAS are in foot and miles. 1 miles = 5280 foot, and not 1000 foot.

\end{itemize}


\section{Hec-ras model 2D}
\label{\detokenize{index:hec-ras-model-2d}}
in src/Hec\_ras2D.py

This module contains the functions used to load the outputs from the hec-ras model in 2D.
\phantomsection\label{\detokenize{index:module-src.hec_ras2D}}\index{src.hec\_ras2D (module)}\index{figure\_hec\_ras2d() (in module src.hec\_ras2D)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.hec_ras2D.figure_hec_ras2d}}\pysiglinewithargsret{\sphinxcode{src.hec\_ras2D.}\sphinxbfcode{figure\_hec\_ras2d}}{\emph{v\_all, h\_all, elev\_all, coord\_p\_all, coord\_c\_all, ikle\_all, path\_im, time\_step={[}0{]}, flow\_area={[}0{]}, max\_point=-99}}{}
This is a function to plot figure of the output from hec-ras 2D.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{v\_all} -- a list of np array representing the velocity at the center of the cells

\item {} 
\sphinxstyleliteralstrong{h\_all} -- a list of np array representing the water depth at the center of the cells

\item {} 
\sphinxstyleliteralstrong{elev\_all} -- a list of np array representing the mimium elevation of each cells

\item {} 
\sphinxstyleliteralstrong{coord\_p\_all} -- a list of np array representing the coordinates of the points of the grid

\item {} 
\sphinxstyleliteralstrong{coord\_c\_all} -- a list of np array representing the coordinates of the centers of the grid

\item {} 
\sphinxstyleliteralstrong{ikle\_all} -- a list of np array representing the connectivity table
one array by flow area

\item {} 
\sphinxstyleliteralstrong{time\_step} -- which time\_step should be plotted (default, the first one)

\item {} 
\sphinxstyleliteralstrong{flow\_area} -- which flow\_area should be plotted (default, the first one)

\item {} 
\sphinxstyleliteralstrong{max\_point} -- the number of cell to be drawn when reconstructing the grid (it might long)

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where the figure should be saved

\end{itemize}

\end{description}\end{quote}

\sphinxstylestrong{Technical comment}

This function creates three figures which represent: a) the grid of the loaded models b) the water height and
c) the velocity.

The two last figures will be modified when the data will be loaded by node and not by cells. So we will not explai
n them here as they should be re-written.

The first figure is used to plot the gird. If we would plot the grid by drawing one side of each triangle
separately, it would be very long to draw. To optimize the process, we use the prepare\_grid function.

\end{fulllineitems}

\index{load\_hec\_ras2d() (in module src.hec\_ras2D)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.hec_ras2D.load_hec_ras2d}}\pysiglinewithargsret{\sphinxcode{src.hec\_ras2D.}\sphinxbfcode{load\_hec\_ras2d}}{\emph{filename}, \emph{path}}{}
The goal of this function is to load 2D data from Hec-RAS in the version 5.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{filename} -- the name of the file containg the results of HEC-RAS in 2D. (string)

\item {} 
\sphinxstyleliteralstrong{path} -- the path where the file is (string)

\end{itemize}

\item[{Returns}] \leavevmode
velocity and height at the center of the cells, the coordinate of the point of the cells,
the coordinates of the center of the cells and the connectivity table. Each output is a list of numpy array
(one array by 2D flow area)

\end{description}\end{quote}

\sphinxstylestrong{How to obtain the input file}

The file neede as input is an hdf5 file (.hdf) created automatically by Hec-Ras. There are many .hdf created by
Hec-Ras. The one to choose is the one with the extension p0X.hdf (not g0x.hdf). It is usually the largest file in
the results folder.

\sphinxstylestrong{Technical comments}

Outputs from HEC-RAS in 2D are in the hdf5 format. However, it is not possible to directly use the output of HEC-RAS
as an hdf5 input for HABBY. Indeed, even if they are both in hdf5, the formats of the hdf5 files are different
(and would miss some important info for HABBY).  So we still need to load the HEC-RAS data in HABBY even if in 2D.

This function should be modified because currently it gets the data by cells. However, we should get the
data by node. So this function should be changed.

\sphinxstylestrong{Walk-through}

The name and path of the file is given as input to the load\_hec\_ras\_2D function. Usually this is done by the class
HEC\_RAS() in the GUI.  We load the file using the h5py module. This module opens and reads hdf5 file.

Then we can read different part of the hdf5 file when we know the address of it (this is a bit like a file system).
In hdf5 file of Hec-RAS, this first thing is to get the names of the flow area in “Geometry/2D Flow Area”. In
general, this is the name of each reach, but it could be lake or pond also.

Then, we go to “Geometry/2D Flow Area/\textless{}name\textgreater{}/FacePoint Coordinates” to get the points forming the grid.
We can also get the connectivity table (or ikle) to the path “Geometry/2D Flow Area/\textless{}name\textgreater{}/Cells Face Point Indexes”
We also get the elevations of the cells. Currently, this is just the minimum elevation of the cells, but it should
be modified to get the elevation by node (in the vocabulary of HEC-RAS by “FacePoints”). We then get the water depth
by cell. Somethings should be done to get it by node. I think that we did have the elevation by node somewhere in
the hdf5 file. For there, water height can be found.
The velocity is given by face of the cells. It should be averaged differently to get it on the point and
not on the side.

\end{fulllineitems}

\index{main() (in module src.hec\_ras2D)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.hec_ras2D.main}}\pysiglinewithargsret{\sphinxcode{src.hec\_ras2D.}\sphinxbfcode{main}}{}{}
Used to test this module independantly of HABBY.

\end{fulllineitems}

\index{prepare\_grid() (in module src.hec\_ras2D)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.hec_ras2D.prepare_grid}}\pysiglinewithargsret{\sphinxcode{src.hec\_ras2D.}\sphinxbfcode{prepare\_grid}}{\emph{ikle}, \emph{coord\_p}, \emph{max\_point=-99}}{}
This is a function to put in the new form the data forming the grid to accelerate the plotting of the grid. This function creates
a list of points of the grid which are re-ordered compared to the usual list of grid point (the variable coord\_p
here). These points are reordered so that it is possible to draw only one line to form the grid (one point can
appears more than once). The grid is drawn as one long line and not as a succession of small lines, which is
quicker. When this new list is created by prepare\_function(), it is send back to figure-hec\_ras\_2D and plotted.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{ikle} -- the connectivity table

\item {} 
\sphinxstyleliteralstrong{coord\_p} -- the coordinates of the point

\item {} 
\sphinxstyleliteralstrong{max\_point} -- if the grid is very big, it is possible to only plot the first points, up to max\_points (int)

\end{itemize}

\item[{Returns}] \leavevmode
a list of x and y coordinates ordered.

\end{description}\end{quote}

\end{fulllineitems}

\index{scatter\_plot() (in module src.hec\_ras2D)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.hec_ras2D.scatter_plot}}\pysiglinewithargsret{\sphinxcode{src.hec\_ras2D.}\sphinxbfcode{scatter\_plot}}{\emph{coord}, \emph{data}, \emph{data\_name}, \emph{my\_cmap}, \emph{s1}, \emph{t}}{}
The function to plot the scatter of the data. Will not be used in the final version, but can be useful to
plot data by cells.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord} -- the coordinates of the point

\item {} 
\sphinxstyleliteralstrong{data} -- the data to be plotted (np.array)

\item {} 
\sphinxstyleliteralstrong{data\_name} -- the name of the data (string)

\item {} 
\sphinxstyleliteralstrong{my\_cmap} -- the color map (string with matplotlib colormap name)

\item {} 
\sphinxstyleliteralstrong{s1} -- the size of the dot for the scatter

\item {} 
\sphinxstyleliteralstrong{t} -- the time step being plotted

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{Mascaret}
\label{\detokenize{index:mascaret}}
in src/mascaret.py

This module contains the functions used to load the outputs from the mascaret model.
\phantomsection\label{\detokenize{index:module-src.mascaret}}\index{src.mascaret (module)}\index{correct\_duplicate() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.correct_duplicate}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{correct\_duplicate}}{\emph{seq}, \emph{send\_warn}, \emph{idfun=None}}{}
It is possible to have a vertical line on a profile (different h, identical x). This is not possible for HABBY and
the 2D grid. So this function correct duplicates along the profile.

A similiar function exists in rubar, for the case where input is (x,y) coordinates and not distance along the profile.
This function is inspired by \url{https://www.peterbe.com/plog/uniqifiers-benchmark}

It should be tested more as manage\_grid sometime still send warning about duplicate data in profile.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{seq} -- the list to be corrected (list)

\item {} 
\sphinxstyleliteralstrong{send\_warn} -- a bool to avoid printing certains warning too many time

\item {} 
\sphinxstyleliteralstrong{idfun} -- support an optional transform function (not used)

\end{itemize}

\item[{Returns}] \leavevmode
the profile data without duplicate and the bollean which manages the warning.

\end{description}\end{quote}

\end{fulllineitems}

\index{define\_stream\_network() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.define_stream_network}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{define\_stream\_network}}{\emph{node\_number}, \emph{start\_node}, \emph{end\_node}, \emph{angles}, \emph{nb\_pro\_reach}, \emph{nb\_reach}, \emph{abcisse}}{}
This function extracts the stream network from the node and angle data. This is used if we have more than one
reach to define the geometry of the junction.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{node\_number} -- the start/end number of the reaches for each nodes (list of list)

\item {} 
\sphinxstyleliteralstrong{start\_node} -- the numbers indicating the start of each reach (list)

\item {} 
\sphinxstyleliteralstrong{end\_node} -- the numbers indicating the end of each reach

\item {} 
\sphinxstyleliteralstrong{angles} -- for each node the angle between the reach

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- the number of profile by reach

\item {} 
\sphinxstyleliteralstrong{nb\_reach} -- the number of reach

\item {} 
\sphinxstyleliteralstrong{abcisse} -- the distance along the river of each reach

\end{itemize}

\item[{Returns}] \leavevmode
the river coordinates and the unit vector indicating the river direction

\end{description}\end{quote}

\end{fulllineitems}

\index{figure\_mascaret() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.figure_mascaret}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{figure\_mascaret}}{\emph{coord\_pro, coord\_r, xhzv\_data, on\_profile, nb\_pro\_reach, name\_pro, name\_reach, path\_im, pro, plot\_timestep={[}-1{]}, reach\_plot={[}0{]}}}{}
The function to plot the figures related to mascaret.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the cordinates (x,y,h, dist along the river) of the profiles

\item {} 
\sphinxstyleliteralstrong{coord\_r} -- the coordinate (x,y) of the river

\item {} 
\sphinxstyleliteralstrong{name\_pro} -- the name of the profile

\item {} 
\sphinxstyleliteralstrong{name\_reach} -- the name of the reach

\item {} 
\sphinxstyleliteralstrong{on\_profile} -- which result are on the profile. Some output are not the profiles.

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- the number of profile by reach (careful this is the number of profile, not the number of output)

\item {} 
\sphinxstyleliteralstrong{xhzv\_data} -- the height and velcoity (x,h,v) list by time step

\item {} 
\sphinxstyleliteralstrong{profile} (\sphinxstyleliteralemphasis{pro}) -- which profile to be plotted (list of int)

\item {} 
\sphinxstyleliteralstrong{plot\_timestep} -- which timestep to be plotted

\item {} 
\sphinxstyleliteralstrong{reach\_plot} -- the reach to be plotted for the river view

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the figure

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_node() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.find_node}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{find\_node}}{\emph{node\_number}, \emph{reach\_to\_find}}{}
This function finds which node is a stream end or a stream start. It is associated by the function
define\_stream\_network()
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{node\_number} -- the list of list of the reaches linked with one node

\item {} 
\sphinxstyleliteralstrong{reach\_to\_find} -- the number indicating the start or end of the reach

\end{itemize}

\item[{Returns}] \leavevmode
the node number, ordered as in the xcas file

\end{description}\end{quote}

\end{fulllineitems}

\index{flat\_coord\_pro() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.flat_coord_pro}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{flat\_coord\_pro}}{\emph{coord\_pro}}{}
This function is not used anymroe.

The variable coord\_pro was a list of profile by reach. Finally, it was useful to have each profile one after the
other with accounting for the reach. So we stop to use this function whose goal was to pass from one form of
coord\_pro to the other form 9with or wihtout reach information).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{coord\_pro} -- the list of profile (x,y,h, dist along the river) by reach

\item[{Returns}] \leavevmode
coord\_pro\_f: a list of profile without the reach information. The list is flatten

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_geo\_name\_from\_xcas() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.get_geo_name_from_xcas}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{get\_geo\_name\_from\_xcas}}{\emph{file\_gen}, \emph{path\_gen}}{}
This function gets the name of the .geo file from the .xcas xml file. It is not used yet, but it could be useful
in the GUI to simplify the loading of mascaret. The user would not need to give the name of the geo and the xcas
files separetly. However, it is not written in yet.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_gen} -- the xcas file

\item {} 
\sphinxstyleliteralstrong{path\_gen} -- the path to the xcas file

\end{itemize}

\item[{Returns}] \leavevmode
the name of the .geo file (no path indicated)

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_name\_from\_cas() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.get_name_from_cas}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{get\_name\_from\_cas}}{\emph{file\_gen}, \emph{path\_gen}}{}
This function gets the name of the .geo file from the .cas text file. It is not used yet, but it could be useful
in the GUI to simplify the loading of mascaret. The user would not need to give the name of the geo and the cas
files separetly. However, it is not written in yet.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_gen} -- the name of .cas file (string)

\item {} 
\sphinxstyleliteralstrong{path\_gen} -- the path to the cas file (string

\end{itemize}

\item[{Returns}] \leavevmode
the name of the .geo file (no path indicated)

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_this\_res\_on\_the\_profile() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.is_this_res_on_the_profile}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{is\_this\_res\_on\_the\_profile}}{\emph{abscisse}, \emph{xhzv\_data\_all}}{}
The output of mascaret can be given at points of the river where there is no profile.
The function here says which results are on the profiles. All profiles are linked with an output, but some output
are not linked with a profile.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{abscisse} -- the distance between each profile (list of float)

\item {} 
\sphinxstyleliteralstrong{xhzv\_data\_all} -- the outputs from mascaret by time step

\end{itemize}

\item[{Returns}] \leavevmode
a list of bool of the length of xhzv\_data, True on profile, False not on profile

\end{description}\end{quote}

\sphinxstylestrong{Technical comment}

In the mascaret outputs, some rounding are suprising. For example, 0.49 can be transformed to 0.50 in an otehr file
(not 0.5). To avoid this type of problem, we says that outputs with a distance smaller than 3cm of the profile are
on the profile. If there are more than one output by profile, we takes the output which is the closest to the
profile.

\end{fulllineitems}

\index{load\_mascaret() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.load_mascaret}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{load\_mascaret}}{\emph{file\_gen}, \emph{file\_geo}, \emph{file\_res}, \emph{path\_gen}, \emph{path\_geo}, \emph{path\_res}}{}
The function is used to load the mascaret data. It load the geofile and the general file. Then, it re-forms the
geometrical data. Next, it loads the output data from mascaret. Fianally, it looks which outputs is close to
a profile and which outputs is not linked with a profile as there are some outputs given between profiles.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_gen} -- the xcas .xml file giving general info about the model (string)

\item {} 
\sphinxstyleliteralstrong{file\_geo} -- the file containting the profile data (.geo) (string)

\item {} 
\sphinxstyleliteralstrong{file\_res} -- the files containting the mascaret output in the Optyca format (.opt) (string)

\item {} 
\sphinxstyleliteralstrong{path\_gen} -- the path to the xcas file or .cas file (string). By default, choose the xcas file.

\item {} 
\sphinxstyleliteralstrong{path\_geo} -- the path to the geo file (string)

\item {} 
\sphinxstyleliteralstrong{path\_res} -- the path to the res file (string)

\end{itemize}

\item[{Returns}] \leavevmode
the coordinates of the profile (x,y,z, dist along the profile), the coordinate of the river (x,y), name of
reach and profile, data height and velocity (list by time step), list of bollean indicating which data is
on the profile and the number of profile by reach.

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.main}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{main}}{}{}
Used to test this module separately.

\end{fulllineitems}

\index{open\_geo\_mascaret() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.open_geo_mascaret}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{open\_geo\_mascaret}}{\emph{file\_geo}, \emph{path\_geo}}{}
This function load the mascaret geo file. Generally, the profile are not geo-referenced when using this function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_geo} -- the name of the geo file (string)

\item {} 
\sphinxstyleliteralstrong{path\_geo} -- the path to the geo file (string)

\end{itemize}

\item[{Returns}] \leavevmode
the profile data (x,y), profile name (list of string),
brief name (list of string), the number of profile in each reach and distance along the river/abcisse (list)

\end{description}\end{quote}

\end{fulllineitems}

\index{open\_res\_file() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.open_res_file}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{open\_res\_file}}{\emph{file\_res}, \emph{path\_res}}{}
The function to load the output from mascaret (.opt file). The format is Optyca.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_res} -- the name of the .opt file (string)

\item {} 
\sphinxstyleliteralstrong{path\_res} -- the path to this file (string)

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{open\_rub\_file() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.open_rub_file}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{open\_rub\_file}}{\emph{file\_res}, \emph{path\_res}}{}
The function to open the binary output file from mascaret (.rub format).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_res} -- the name of the rub binary file (string)

\item {} 
\sphinxstyleliteralstrong{path\_res} -- the path to this file (string)

\end{itemize}

\item[{Returns}] \leavevmode
xhzv\_data, timestep

\end{description}\end{quote}

\sphinxstylestrong{Technical comment}

The binary output file was done using a program written in FORTRAN. So there are often suprising
octet which are added to the binary file. Be careful before changing anything.

\end{fulllineitems}

\index{profil\_coord\_non\_georef() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.profil_coord_non_georef}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{profil\_coord\_non\_georef}}{\emph{coord\_pro}, \emph{coord\_r}, \emph{nr}, \emph{nb\_pro\_reach}, \emph{bt=None}}{}
This function gets the coordinates (x,y) of the profile as masacret outputs are not georeferenced.

Hypothesis: The river and the profile are straight. The profile is perpendicular to the river.
The river pass at the minimum elevation of the river bed. If there is a distinction between the main bed the
secondary bed is given, we take the minimum elevation of the main bed

The origin of the coordinate system is the start of the river.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the coordinate of the profile. This variable is not in the general coordinate system,
just distance along the profile and bed elevation (p, dist, h)

\item {} 
\sphinxstyleliteralstrong{coord\_r} -- the river coordinates

\item {} 
\sphinxstyleliteralstrong{n} -- the vector indicating the river direction

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- the number of profile by reach (additive)

\item {} 
\sphinxstyleliteralstrong{bt} -- optional, it indicates which points in the profiles are in the minor/major bed

\end{itemize}

\item[{Returns}] \leavevmode
the velocity and height data, the timestep

\end{description}\end{quote}

\end{fulllineitems}

\index{river\_coord\_non\_georef\_from\_cas() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.river_coord_non_georef_from_cas}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{river\_coord\_non\_georef\_from\_cas}}{\emph{file\_gen}, \emph{path\_gen}, \emph{abcisse}, \emph{nb\_pro\_reach}}{}
Get the coordinates of the river based on the cas text file. If there are only one river, this is an easy task as
the river is straight. If there are more than one reach, the junctions and the angles between the reach sould be
managed using the define\_stream\_network function and the information in the .cas file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_gen} -- the .cas file whcih contains general info (string)

\item {} 
\sphinxstyleliteralstrong{path\_gen} -- the path to this file (string)

\item {} 
\sphinxstyleliteralstrong{abcisse} -- ditance along the profiles

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- the number of reach by profile

\end{itemize}

\item[{Returns}] \leavevmode
the river coordinate and the unit vector indicating the river direction

\end{description}\end{quote}

\end{fulllineitems}

\index{river\_coord\_non\_georef\_from\_xcas() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.river_coord_non_georef_from_xcas}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{river\_coord\_non\_georef\_from\_xcas}}{\emph{file\_gen}, \emph{path\_gen}, \emph{abcisse}, \emph{nb\_pro\_reach}}{}
Get the coordinates of the river based on the xcas xml file. If there are only one river, this is an easy task as
the river is straight. If there are more than one reach, the junctions and the angles between the reach sould be
managed using the define\_stream\_network function and the information in the .xcas file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_gen} -- the .xcas file with the information concerning the reach (string)

\item {} 
\sphinxstyleliteralstrong{path\_gen} -- the path to the xcas file (string)

\item {} 
\sphinxstyleliteralstrong{abcisse} -- the distance along the river

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- the number of profile by reach

\end{itemize}

\item[{Returns}] \leavevmode
coord\_r the coordinate of the river

\end{description}\end{quote}

\end{fulllineitems}



\section{River 2D}
\label{\detokenize{index:river-2d}}
in src/river2D.py

This module contains the functions used to load the outputs from the River2D model.
\phantomsection\label{\detokenize{index:module-src.river2d}}\index{src.river2d (module)}\index{figure\_river2d() (in module src.river2d)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.river2d.figure_river2d}}\pysiglinewithargsret{\sphinxcode{src.river2d.}\sphinxbfcode{figure\_river2d}}{\emph{xyzhv}, \emph{ikle}, \emph{path\_im}, \emph{t=0}}{}
A function to plot the output from river 2d. Need hec-ras2d as import because it re-used most of the plot from this
script.

Plot only one time step because river 2d output have one file by time step.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{xyzhv} -- the x,y, coordinates of the node (h,v are nodal output in river 2d), the river bed, the water height
and the velocity (one data by column, row are node)

\item {} 
\sphinxstyleliteralstrong{ikle} -- connectivity table

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the figure

\item {} 
\sphinxstyleliteralstrong{t} -- the time step which is being plotted

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_rid\_of\_lines() (in module src.river2d)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.river2d.get_rid_of_lines}}\pysiglinewithargsret{\sphinxcode{src.river2d.}\sphinxbfcode{get\_rid\_of\_lines}}{\emph{datahere}, \emph{nb\_data}}{}
There are lines which are useless in the cdg file. This function is used to correct ikle and data\_node
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{datahere} -- the data with the empty lines

\item {} 
\sphinxstyleliteralstrong{nb\_data} -- nb\_node or nb\_el

\end{itemize}

\item[{Returns}] \leavevmode
datahere wihtout the useless lines

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_river2d\_cdg() (in module src.river2d)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.river2d.load_river2d_cdg}}\pysiglinewithargsret{\sphinxcode{src.river2d.}\sphinxbfcode{load\_river2d\_cdg}}{\emph{file\_cdg}, \emph{path}}{}
The file to load the output data from River2D. Careful the input data of River2D has the same ending and nearly
the same format as the output. However, it is nessary to have the output here. River2D gives one cdg. file by timestep.
Hence, this function read only one timeste. HABBY read all time step by calling this function once for each time step.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_cdg} -- the name of the cdg file (string)

\item {} 
\sphinxstyleliteralstrong{path} -- the path to this file (string).

\end{itemize}

\item[{Returns}] \leavevmode
the velcoity and height data, the coordinate and the connectivity table.

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module src.river2d)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.river2d.main}}\pysiglinewithargsret{\sphinxcode{src.river2d.}\sphinxbfcode{main}}{}{}
Used to test this module.

\end{fulllineitems}



\section{Rubar}
\label{\detokenize{index:rubar}}
in src/rubar.py

This module contains the functions used to load the Rubar data in 2D and 1D.
\phantomsection\label{\detokenize{index:module-src.rubar}}\index{src.rubar (module)}\index{correct\_duplicate\_xy() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.correct_duplicate_xy}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{correct\_duplicate\_xy}}{\emph{seq3D}, \emph{send\_warn}, \emph{idfun=None}}{}
It is possible to have a vertical line on a profile (different h, identical x). This is not possible for HABBY and
the 2D grid. So this function correct duplicates along the profile.

A similiar function exists in mascaret, for the case where the input is the distance along the profile and not
(x,y) coordinates. This function is inspired by \url{https://www.peterbe.com/plog/uniqifiers-benchmark}.

It should be tested more as manage\_grid sometime still send warning about duplicate data in profile.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{seq3D} -- the list to be corrected in this case (x,y,z,dist along the profile)

\item {} 
\sphinxstyleliteralstrong{send\_warn} -- a bool to avoid printing the warning too many time

\item {} 
\sphinxstyleliteralstrong{idfun} -- support an optional transform function (not tested)

\end{itemize}

\item[{Returns}] \leavevmode
the list wihtout duplicate and the boolean which helps manage the warnings

\end{description}\end{quote}

\end{fulllineitems}

\index{figure\_rubar1d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.figure_rubar1d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{figure\_rubar1d}}{\emph{coord\_pro, lim\_riv, data\_xhzv, name\_profile, path\_im, pro, plot\_timestep, nb\_pro\_reach={[}0, 10000000000{]}}}{}
The function to plot the loaded RUBAR 1D data (Rubar BE).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the coordinate of the profile (x, y, z, dist along the river)

\item {} 
\sphinxstyleliteralstrong{lim\_riv} -- the right bank, river center, left bank

\item {} 
\sphinxstyleliteralstrong{data\_xhzv} -- the data by time step with x the distance along the river, h the water height and v the vlocity

\item {} 
\sphinxstyleliteralstrong{cote} -- the altitude of the river center

\item {} 
\sphinxstyleliteralstrong{name\_profile} -- the name of the profile

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the image

\item {} 
\sphinxstyleliteralstrong{pro} -- the profile number which should be plotted

\item {} 
\sphinxstyleliteralstrong{plot\_timestep} -- which timestep should be plotted

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- the number of profile by reach

\end{itemize}

\item[{Returns}] \leavevmode
none

\end{description}\end{quote}

\end{fulllineitems}

\index{figure\_rubar2d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.figure_rubar2d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{figure\_rubar2d}}{\emph{xy, coord\_c, ikle, v, h, path\_im, time\_step={[}-1{]}}}{}
This functions plots the rubar 2d data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{xy} -- coordinates of the points

\item {} 
\sphinxstyleliteralstrong{coord\_c} -- the center of the point

\item {} 
\sphinxstyleliteralstrong{ikle} -- connectivity table

\item {} 
\sphinxstyleliteralstrong{v} -- speed

\item {} 
\sphinxstyleliteralstrong{h} -- height

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the figure

\item {} 
\sphinxstyleliteralstrong{time\_step} -- The time step which will be plotted

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_triangular\_grid() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.get_triangular_grid}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{get\_triangular\_grid}}{\emph{ikle}, \emph{coord\_c}, \emph{xy}, \emph{h}, \emph{v}}{}~\begin{description}
\item[{In Rubar it is possible to have non-triangular cells. It is possible to have a grid composed of a mix of pentagonal,}] \leavevmode
4-sided and triangualr cells. This function transform the ``mixed'' grid to a triangular grid. For this, it uses the
centroid of each cell with more than three side and it create a triangle by side (linked with the center of the cell)

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{ikle} -- the connectivity table

\item {} 
\sphinxstyleliteralstrong{coord\_c} -- the coordinate of the centroid of the cell

\item {} 
\sphinxstyleliteralstrong{xy} -- the points of the grid

\item {} 
\sphinxstyleliteralstrong{h} -- data on water height

\item {} 
\sphinxstyleliteralstrong{v} -- data on velocity

\end{itemize}

\item[{Returns}] \leavevmode
the updated ikle, coord\_c (the center of the cell , must be updated ) and xy (the grid coordinate)

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_coord\_1d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.load_coord_1d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{load\_coord\_1d}}{\emph{name\_rbe}, \emph{path}}{}
the function to load the rbe file, which is an xml file. The gives the geometry of the river system.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{name\_rbe} -- The name fo the rbe file (string)

\item {} 
\sphinxstyleliteralstrong{path} -- the path to this file (string)

\end{itemize}

\item[{Returns}] \leavevmode
the coordinates of the profiles and the coordinates of the right bank, center of the river, left bank
(list of np.array with x,y,z coordinate), name of the profile (list of string), dist along the river (list of float)
number of cells (int)

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_dat\_2d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.load_dat_2d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{load\_dat\_2d}}{\emph{geofile}, \emph{path}}{}
This  function is used to load the geomtery info for the 2D case, using the .dat file
The .dat file has the same role than the .mai file but with more information (number of side and more
complicated connectivity table).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{geofile} -- the .dat file which contain the connectivity table and the (x,y)

\item {} 
\sphinxstyleliteralstrong{path} -- the path to this file

\end{itemize}

\item[{Returns}] \leavevmode
connectivity table, point coordinates, coordinates of the cell centers

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_data\_1d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.load_data_1d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{load\_data\_1d}}{\emph{name\_data\_vh}, \emph{path}, \emph{x}}{}
This function loads the output data for Rubar BE (in 1D). The geometry data should be loaded before using this function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{name\_data\_vh} -- the name of the profile.ETUDE file (string)

\item {} 
\sphinxstyleliteralstrong{path} -- the path to this file

\item {} 
\sphinxstyleliteralstrong{x} -- the distance along the river (from the .geo file)

\end{itemize}

\item[{Returns}] \leavevmode
data x, velocity height, cote for each time step (list of np.array), time step

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_mai\_1d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.load_mai_1d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{load\_mai\_1d}}{\emph{mailfile}, \emph{path}}{}
This function is not used anymore. It was used to load the coordinate of the 1D data. It might become useful again
in the case where we found a Rubar model with more than one reach (which we do not have yet).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{mailfile} -- the name of the file which contain the (x,z) data

\item {} 
\sphinxstyleliteralstrong{path} -- the path to this file

\end{itemize}

\item[{Returns}] \leavevmode
x of the river, np.array and the number of mail

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_mai\_2d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.load_mai_2d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{load\_mai\_2d}}{\emph{geofile}, \emph{path}}{}
The function to load the geomtery info for the 2D case when we use the .mai file. It would also be possible
to use the .dat file. In fact, it is advised to use the dat file when possible as there are more info in the .dat file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{geofile} -- the .mai file which contain the connectivity table and the (x,y)

\item {} 
\sphinxstyleliteralstrong{path} -- the path to this file

\end{itemize}

\item[{Returns}] \leavevmode
connectivity table, point coordinates, coordinates of the cell centers

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_rubar1d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.load_rubar1d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{load\_rubar1d}}{\emph{geofile}, \emph{data\_vh}, \emph{pathgeo}, \emph{pathdata}, \emph{path\_im}, \emph{savefig}}{}
the function to load the RUBAR BE data (in 1D).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{geofile} -- the name of .rbe file which gives the coordinates of each profile (string)

\item {} 
\sphinxstyleliteralstrong{data\_vh} -- the name of the profile.ETUDE file which contains the height and velocity data (string)

\item {} 
\sphinxstyleliteralstrong{pathgeo} -- the path to the geofile - string

\item {} 
\sphinxstyleliteralstrong{pathdata} -- the path to the data\_vh file

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the file where to save the image

\item {} 
\sphinxstyleliteralstrong{savefig} -- a boolean. If True create and save the figure.

\end{itemize}

\item[{Returns}] \leavevmode
coordinates of the profile (x,y,z dist along the profile) coordinates (x,y) of the river and the bed,
data xhzv by time step where x is the distance along the river, h the water height, z the elevation of the bed
and v the velocity

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_rubar2d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.load_rubar2d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{load\_rubar2d}}{\emph{geofile}, \emph{tpsfile}, \emph{pathgeo}, \emph{pathtps}, \emph{path\_im}, \emph{save\_fig}}{}
This is the function used to load the RUBAR data in 2D
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{geofile} -- the name of the .mai or .dat file which contains the connectivity table and the coordinates (string)

\item {} 
\sphinxstyleliteralstrong{tpsfile} -- the name of the .tps file (string)

\item {} 
\sphinxstyleliteralstrong{pathgeo} -- path to the geo file (string)

\item {} 
\sphinxstyleliteralstrong{pathtps} -- path to the tps file which contains the outputs (string)

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the figure (string)

\item {} 
\sphinxstyleliteralstrong{save\_fig} -- a boolean indicating if the figures should be created or not

\end{itemize}

\item[{Returns}] \leavevmode
velocity and height at the center of the cells, the coordinate of the point of the cells,
the coordinates of the center of the cells and the connectivity table.

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_tps\_2d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.load_tps_2d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{load\_tps\_2d}}{\emph{tpsfile}, \emph{path}, \emph{nb\_cell}}{}
The function to load the output data in the 2D rubar case. The geometry file (.mai or .dat) should be loaded before.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{tpsfile} -- the name of the file with the data for the 2d case

\item {} 
\sphinxstyleliteralstrong{path} -- the path to the tps file.

\item {} 
\sphinxstyleliteralstrong{nb\_cell} -- the number of cell extracted from the .mai file

\end{itemize}

\item[{Returns}] \leavevmode
v, h, timestep (all in list of np.array)

\end{description}\end{quote}

\end{fulllineitems}

\index{m\_file\_load\_coord\_1d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.m_file_load_coord_1d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{m\_file\_load\_coord\_1d}}{\emph{geofile\_name}, \emph{pathgeo}}{}
This function loads the m.ETUDE file which is based on .st format from cemagref. When we use the M.ETUDE file
instead of the rbe file, more than one reach can be studied but the center and side of the river is not
indicated anymore.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{geofile\_name} -- The name to the m.ETUDE file (string)

\item {} 
\sphinxstyleliteralstrong{pathgeo} -- the path to this file (string)

\end{itemize}

\item[{Returns}] \leavevmode
the coordinates of the profiles (list of np.array with x,y,z coordinate), name of the profile
(list of string), dist along the river (list of float), number of profile by reach

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.main}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{main}}{}{}
Used to test this module

\end{fulllineitems}



\section{Telemac}
\label{\detokenize{index:telemac}}
in src/selafin\_habby1.py

This module contains the functions used to load the Telemac data.
\phantomsection\label{\detokenize{index:module-src.selafin_habby1}}\index{src.selafin\_habby1 (module)}\index{Selafin (class in src.selafin\_habby1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src.selafin\_habby1.}\sphinxbfcode{Selafin}}{\emph{filename}}{}
Selafin file format reader for Telemac 2D. Create an object for reading data from a slf file.
Adapted from the original script `parserSELAFIN.py' from the open Telemac distribution.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{filename} -- the name of the binary Selafin file

\end{description}\end{quote}
\index{addcontent() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.addcontent}}\pysiglinewithargsret{\sphinxbfcode{addcontent}}{\emph{fileName}, \emph{times}, \emph{values}}{}
\end{fulllineitems}

\index{appendcoretimeslf() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.appendcoretimeslf}}\pysiglinewithargsret{\sphinxbfcode{appendcoretimeslf}}{\emph{t}}{}
\end{fulllineitems}

\index{appendcorevarsslf() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.appendcorevarsslf}}\pysiglinewithargsret{\sphinxbfcode{appendcorevarsslf}}{\emph{varsor}}{}
\end{fulllineitems}

\index{appendheaderslf() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.appendheaderslf}}\pysiglinewithargsret{\sphinxbfcode{appendheaderslf}}{}{}
Write the header file

\end{fulllineitems}

\index{getheaderfloatsslf() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.getheaderfloatsslf}}\pysiglinewithargsret{\sphinxbfcode{getheaderfloatsslf}}{}{}
Get the mesh coordinates

\end{fulllineitems}

\index{getheaderintegersslf() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.getheaderintegersslf}}\pysiglinewithargsret{\sphinxbfcode{getheaderintegersslf}}{}{}
Get dimensions and descritions (mesh)

\end{fulllineitems}

\index{getheadermetadataslf() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.getheadermetadataslf}}\pysiglinewithargsret{\sphinxbfcode{getheadermetadataslf}}{}{}
Get header information

\end{fulllineitems}

\index{gettimehistoryslf() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.gettimehistoryslf}}\pysiglinewithargsret{\sphinxbfcode{gettimehistoryslf}}{}{}
Get the timesteps

\end{fulllineitems}

\index{getvalues() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.getvalues}}\pysiglinewithargsret{\sphinxbfcode{getvalues}}{\emph{t}}{}
Get the values for the variables at time t

\end{fulllineitems}

\index{getvariablesat() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.getvariablesat}}\pysiglinewithargsret{\sphinxbfcode{getvariablesat}}{\emph{frame}, \emph{varindexes}}{}
Get the values for the variables at a particular time step

\end{fulllineitems}

\index{putcontent() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.putcontent}}\pysiglinewithargsret{\sphinxbfcode{putcontent}}{\emph{fileName}, \emph{times}, \emph{values}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{getendianfromchar() (in module src.selafin\_habby1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.getendianfromchar}}\pysiglinewithargsret{\sphinxcode{src.selafin\_habby1.}\sphinxbfcode{getendianfromchar}}{\emph{fileslf}, \emph{nchar}}{}~\begin{description}
\item[{Get the endian encoding}] \leavevmode
``\textless{}'' means little-endian
``\textgreater{}'' means big-endian

\end{description}

\end{fulllineitems}

\index{getfloattypefromfloat() (in module src.selafin\_habby1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.getfloattypefromfloat}}\pysiglinewithargsret{\sphinxcode{src.selafin\_habby1.}\sphinxbfcode{getfloattypefromfloat}}{\emph{fileslf}, \emph{endian}, \emph{nfloat}}{}
Get float precision

\end{fulllineitems}

\index{load\_telemac() (in module src.selafin\_habby1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.load_telemac}}\pysiglinewithargsret{\sphinxcode{src.selafin\_habby1.}\sphinxbfcode{load\_telemac}}{\emph{namefilet}, \emph{pathfilet}}{}
A function which load the telemac data using the Selafin class
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{namefilet} -- the name of the selafin file (string)

\item {} 
\sphinxstyleliteralstrong{pathfilet} -- the path to this file (string)

\end{itemize}

\item[{Returns}] \leavevmode
the velocity, the height, the coordinate of the points of the grid, the connectivity table.

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_vel\_h() (in module src.selafin\_habby1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.plot_vel_h}}\pysiglinewithargsret{\sphinxcode{src.selafin\_habby1.}\sphinxbfcode{plot\_vel\_h}}{\emph{coord\_p2, h, v, path\_im, timestep={[}-1{]}}}{}
a function to plot the velocity and height which are the output from TELEMAC
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_p2} -- the coordinates of the point forming the grid

\item {} 
\sphinxstyleliteralstrong{h} -- the  water height

\item {} 
\sphinxstyleliteralstrong{v} -- the velocity

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where the image should be saved (string)

\item {} 
\sphinxstyleliteralstrong{timestep} -- which time step should be plotted

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{Load HABBY hdf5 file}
\label{\detokenize{index:load-habby-hdf5-file}}
in src/load\_hdf5.py

This module contains some functions to load and manage hdf5 input/outputs. This is still in progress.
\phantomsection\label{\detokenize{index:module-src.load_hdf5}}\index{src.load\_hdf5 (module)}\index{get\_all\_filename() (in module src.load\_hdf5)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.load_hdf5.get_all_filename}}\pysiglinewithargsret{\sphinxcode{src.load\_hdf5.}\sphinxbfcode{get\_all\_filename}}{\emph{dirname}, \emph{ext}}{}
This function gets the name of all file with a particular extension in a folder. Useful to get all the output
from one hydraulic model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{dirname} -- the path to the directory (string)

\item {} 
\sphinxstyleliteralstrong{ext} -- the extension (.txt for example). It is a string, the point needs to be the first character.

\end{itemize}

\item[{Returns}] \leavevmode
a list with the filename (filename+dir) for each extension

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_hdf5\_hyd() (in module src.load\_hdf5)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.load_hdf5.load_hdf5_hyd}}\pysiglinewithargsret{\sphinxcode{src.load\_hdf5.}\sphinxbfcode{load\_hdf5\_hyd}}{\emph{hdf5\_name\_hyd}}{}
A function to load the 2D hydrological data contains in the hdf5 file in the form required by HABBY.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{hdf5\_name\_hyd} -- path and filename of the hdf5 file (string)

\item[{Returns}] \leavevmode
the connectivity table, the coordinates of the point, the height data, the velocity data on the coordinates.

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_hdf5\_sub() (in module src.load\_hdf5)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.load_hdf5.load_hdf5_sub}}\pysiglinewithargsret{\sphinxcode{src.load\_hdf5.}\sphinxbfcode{load\_hdf5\_sub}}{\emph{hdf5\_name\_sub}}{}
A function to load the substrate data contained in the hdf5 file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{hdf5\_name\_sub} -- path and file name to the hdf5 file (string)

\end{description}\end{quote}

\end{fulllineitems}

\index{open\_hdf5() (in module src.load\_hdf5)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.load_hdf5.open_hdf5}}\pysiglinewithargsret{\sphinxcode{src.load\_hdf5.}\sphinxbfcode{open\_hdf5}}{\emph{hdf5\_name}}{}
This is a function which open an hdf5 file and check that it exists. it does not load the data. It only opens the
files.
:param hdf5\_name: the path and name of the hdf5 file (string)

\end{fulllineitems}



\subsection{Form of the hdf5 files}
\label{\detokenize{index:form-of-the-hdf5-files}}
Here is the actual form of the hdf5 containing the 2D hydrological data.
\begin{itemize}
\item {} 
Number of timestep: Data\_gen/Nb\_timestep

\item {} 
Number of reach: Data\_gen/Nb\_reach

\item {} 
Connectivity table for the whole profile: Data\_2D/Whole\_Profile/Reach\_\textless{}r\textgreater{}/ikle

\item {} 
Connectivity table for the wetted area (by time step): Data\_2D/Timestep\textless{}t\textgreater{}/Reach\_\textless{}r\textgreater{}/ikle

\item {} 
Coordinates for the whole profile: Data\_2D/Whole\_Profile/Reach\_\textless{}r\textgreater{}/point\_all

\item {} 
Coordinates for the wetted area (by time steps): Data\_2D/Timestep\textless{}t\textgreater{}/Reach\_\textless{}r\textgreater{}/point\_all

\item {} 
Data for the velocity: Data\_2D/Timestep\textless{}t\textgreater{}/Reach\_\textless{}r\textgreater{}/inter\_vel\_all

\item {} 
Data for the height:  Data\_2D/Timestep\textless{}t\textgreater{}/Reach\_\textless{}r\textgreater{}/inter\_h\_all

\end{itemize}

Here is the actual form of the hdf5 containing the substrate data.
\begin{itemize}
\item {} 
the coordinate of the point forming the substrate ``grid'': coord\_p\_sub/

\item {} 
the connectivity table of the substrate ``grid'': ikle\_sub/

\item {} 
Substrate data; not done yet

\end{itemize}


\section{Velocity distribution}
\label{\detokenize{index:velocity-distribution}}
in src/dist\_vitesse2.py

The goal of this list of function is to distribute the velocity along the cross-section
for 1D model such as mascaret or Rubar BE. Hec-Ras outputs do not need to uses this type
of function as they are already distributed along the profiles.

The method of velocity distribution in HABBY is similar to the one used by Hec-Ras to distribute
velocity.
\phantomsection\label{\detokenize{index:module-src.dist_vistess2}}\index{src.dist\_vistess2 (module)}\index{dist\_velocity\_hecras() (in module src.dist\_vistess2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.dist_vistess2.dist_velocity_hecras}}\pysiglinewithargsret{\sphinxcode{src.dist\_vistess2.}\sphinxbfcode{dist\_velocity\_hecras}}{\emph{coord\_pro}, \emph{xhzv\_data\_all}, \emph{manning\_pro}, \emph{nb\_point=-99}, \emph{eng=1.0}, \emph{on\_profile={[}{]}}}{}
This function distribute the velocity along the profile using the method from hec-ras
which is described in the hydraulic reference manual p 4-20 (Flow distribtion calculation)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the coordinates and elevation of the river bed for each profile (x,y, h, dist along the profile)
this list is flatten No reach info.

\item {} 
\sphinxstyleliteralstrong{xhzv\_data\_all} -- water height and velocity at each profile, 1D

\item {} 
\sphinxstyleliteralstrong{manning\_pro} -- the manning coefficient for zone between point of each profile.
For a particular profile, the length of manning\_pro is the length of coord\_pro{[}0{]}

\item {} 
\sphinxstyleliteralstrong{nb\_point} -- number of velocity points (-99 takes the number of measured elevation as the number of velocity points).

\item {} 
\sphinxstyleliteralstrong{eng} -- in case the output from hec-ras are in US unit (eng=1 for SI unit and 1.486 for US unit)

\item {} 
\sphinxstyleliteralstrong{on\_profile} -- Mascaret also gives outputs in poitns between profile. on\_profile is true if the results are
close or on the profile (les than 3cm of difference). This is not important for rubar or other models

\end{itemize}

\item[{Returns}] \leavevmode
the velocity for each profile by time step (x,v)

\end{description}\end{quote}

\sphinxstylestrong{Technical comment and walk-through}

First, we decide on which point along the profile we will calculate the velocity. This is controlled by the
variable nb\_point. If nb\_point=-99, we will calculate the velocity at the same point than the profile (i.e., the
velocity will be calculated at each point on which the elevation of the profile was measured). There are cases where
this is not adequate. Let’s imagine for example a rectangular canal. The calculation would only give two velocity
points, which is not enough. So, it is possible to give the number of velocity point on which the calculation must
be made, using the variable nb\_point.

Currently, the velocity points are determined by dividing the whole profile in nb\_point segments. This means that
some velocity point are not used afterwards because they are in the dry part of the profile and that it is not
possible to select for a part of the profile where more velocity points would be calculated. This could be modified
in the future if it is judged necessary.

To determine the point where velocity should be calculated we need to get two array: one “x” array, the distance
along the profile and one “h” array, the elevation of the profile at this point. As we choose the position of the
velocity point as regularly placed along the profile, the “x” array is easy to determine using linespace. For the
“h” array, we use the hypothesis that the elevation of the profile changes linearly between the measured elevation
points. We find between which elevation point are the new point and we use a linear interpolation to find the new”h”.
To find between which points we are, we use the bisect.bisect function. It is a bit like the np.where function,
but it is quicker when the array is ordered (as it is the case here).

Then, we get the manning array as created by the get\_manning\_arr and the get\_manning function. It should be a float.

Next, we cut the profile to keep only the part under water. For this, we do two things: First we had a point on the
profile where h==0. We should account for the fact that we might have  “islands” (part of the profile which are
dry, but surrounded by water on both side.). So we cannot only looked which part are dry, we need to look
for each point where we pass from “wet to dry” or from “dry to wet”. At this place, we add one point where h= 0.
For these new points water height is obviously known, but x (the distlance along profile) should be determined.
It is determined assuming a linear change between the measured points of the profile.

If the profile is not entirely dry, we will now distribute the velocity along the profile. First, for each part of
the profile where velocity will be calculated, it looks where is the higher height (like if this part of the profile
is going up or down). Next, we calculate the area, the wetted perimeter and the hydraulic radius of each part of the
profile. By combining this geometrical information with the manning parameter, we can calculate the conveyance
of each part of the profile. See manual of hec-ras p.4-20 for the conveyance definition.

We now calculate the conveyance of the whole profile. Normally, the sum of the conveyance of the part is higher
than the total conveyance. The next part of the script corrects for this, using the ratio of the total conveyance
and the sum of the parts of the conveyance. Next, we calculate the velocity using the modelled energy slope (Sf)
and the manning equation. We then then add a velocity of zero where there are no water (velocity is not defined
at his point).

\end{fulllineitems}

\index{get\_manning() (in module src.dist\_vistess2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.dist_vistess2.get_manning}}\pysiglinewithargsret{\sphinxcode{src.dist\_vistess2.}\sphinxbfcode{get\_manning}}{\emph{manning1}, \emph{nb\_point}, \emph{nb\_profil}, \emph{coord\_pro}}{}
This function creates an array with the manning value when a single float is given, so when the manning value
is a constant for the whole river.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{manning1} -- the manning value (can be a value or an array)

\item {} 
\sphinxstyleliteralstrong{nb\_point} -- the number of velocity point by profile

\item {} 
\sphinxstyleliteralstrong{nb\_profil} -- the number of profile

\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- necessary if the number is -99 as we need to know the length of each profile

\end{itemize}

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

The function dist\_velcoity\_hec\_ras needs a manning array with a length equal to the number of profile, where each
row (representing a profile) have one value by velocity point which will be calculated. This function creates an
array of this form based on a float. It creates a list of manning value which is identical for each point of the
river. It can be used for the cases where the same number of point is asked for each profile or for the case where
the number of point is defined by the form of the profile (nb\_point = -99).

\end{fulllineitems}

\index{get\_manning\_arr() (in module src.dist\_vistess2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.dist_vistess2.get_manning_arr}}\pysiglinewithargsret{\sphinxcode{src.dist\_vistess2.}\sphinxbfcode{get\_manning\_arr}}{\emph{manning\_arr}, \emph{nb\_point}, \emph{coord\_pro}}{}
This function create the manning array when manning data is loaded using a text file. In this case, the manning
value do not needs to be a constant.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{manning\_arr} -- the data for manning

\item {} 
\sphinxstyleliteralstrong{nb\_point} -- the number of velocity point by profile

\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- x,y,dist

\end{itemize}

\end{description}\end{quote}

\sphinxstylestrong{Technical comment}

The user creates a txt file with a list of manning info. Each manning value is given the following way:
the profile, the distance along the profile and the manning value. One value by line in SI unit.

This function automatically fills the missing value, so that the user do not needs to give each manning value.
He can describe one profile and this profile will be replicated until the next profile written in the text file.

\end{fulllineitems}

\index{main() (in module src.dist\_vistess2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.dist_vistess2.main}}\pysiglinewithargsret{\sphinxcode{src.dist\_vistess2.}\sphinxbfcode{main}}{}{}
Used to test this module.

\end{fulllineitems}

\index{plot\_dist\_vit() (in module src.dist\_vistess2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.dist_vistess2.plot_dist_vit}}\pysiglinewithargsret{\sphinxcode{src.dist\_vistess2.}\sphinxbfcode{plot\_dist\_vit}}{\emph{v\_pro}, \emph{coord\_pro}, \emph{xhzv\_data}, \emph{plot\_timestep}, \emph{pro}, \emph{name\_pro={[}{]}}, \emph{on\_profile={[}{]}}, \emph{zone\_v\_all={[}{]}}, \emph{data\_profile={[}{]}}, \emph{xy\_h\_all={[}{]}}}{}
This is a function to plot the distribution of velocity and the elevation of the profile. It is quite close to the
similar function which is in hec-ras (see this function for a more detailed explanation)

It can be used to test the program if we provide the variable zone\_v\_all where zone\_v\_all is an hec-ras output with a
velocity distribution. In this case, it would plot the comparison between the output from this script and the
output from hec-ras. Of course, for this, it is necessary to have prepared the 1D output from hec-ras
(using the function preparetest\_velocity) and to have the same points on which to calculate the velocity.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{v\_pro} -- the calculated velcocity distribution by time step

\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the coordinate of the profiles

\item {} 
\sphinxstyleliteralstrong{xhzv\_data} -- the output data from the model, before the velocity distrbution

\item {} 
\sphinxstyleliteralstrong{plot\_timestep} -- which time step to be plottied

\item {} 
\sphinxstyleliteralstrong{name\_pro} -- the name of the profile (optionnal just for the title)

\item {} 
\sphinxstyleliteralstrong{pro} -- which porfile to be plotted

\item {} 
\sphinxstyleliteralstrong{on\_profile} -- select the data which is on the profile

\item {} 
\sphinxstyleliteralstrong{zone\_v} -- output from hec-ras used to test dist\_vitesse

\item {} 
\sphinxstyleliteralstrong{data\_profile} -- output from hec-ras used to test dist\_vitesse

\item {} 
\sphinxstyleliteralstrong{xy\_h} -- output from hec-ras used to test dist\_vitesse

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{preparetest\_velocity() (in module src.dist\_vistess2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.dist_vistess2.preparetest_velocity}}\pysiglinewithargsret{\sphinxcode{src.dist\_vistess2.}\sphinxbfcode{preparetest\_velocity}}{\emph{coord\_pro}, \emph{vh\_pro\_orr}, \emph{v\_in}}{}
This is a debugging function. It takes as input the output from the hec-ras model and gives a 1D velocity as
output. This is only to test this program. It will not be used by HABBY directly. To use this function, it is
necessary to use the function to load hec-ras data from HABBY, so that the hec-ras data is in the right form.
The 1D-velocity is assumed to be the velocity as the lowest part of the profile. This is where a 1D-model would
estimate the position of the river (the lowest part of the river bed).

A complicated point to test the program is to put the velocity point at the same point than hec-ras. As hec-ras
calculate velocity between zones and not on one point, this is more or less impossible to do with precision.
However, one can count the number of velocity zone and give this as an input to dist\_velocity\_hecras() for the
variable nb\_point. However, both line will not be exactly at the same place. The results should however be close
enough.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the coordinate of the profile (x,y,h,dist along profile)

\item {} 
\sphinxstyleliteralstrong{vh\_pro\_orr} -- the velocity distribution which is the output from hec ras (produced by hec-ras06.py)

\item {} 
\sphinxstyleliteralstrong{v\_in} -- the uni-dimensional velocity

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{Create a grid}
\label{\detokenize{index:create-a-grid}}
in src/manage\_grid\_8

This module is composed of the functions used to manage the grid,
notably to create 2D grid from the output from 1D model.

There are two main way to go from data in 1.5D in a profile form to a 2D grid:
\begin{itemize}
\item {} 
through the usage of the triangle module in create\_grid().

\item {} 
through the definition of a middle profile used as a guide to create the grid in create\_grid\_only\_one\_profile().

\end{itemize}

For an in-depth explanation on how to create the grids, please see the pdf document \sphinxcode{More info on the grid}
\phantomsection\label{\detokenize{index:module-src.manage_grid_8}}\index{src.manage\_grid\_8 (module)}\index{add\_point() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.add_point}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{add\_point}}{\emph{point\_all}, \emph{point}}{}
To manage the substrate data, we modify the hydrological grid to avoid to have cells with two substrate type.
This function add one coordinate point to the list of coordinates which compose the hydrological grid. This point
is the intersection between one side of one triangluar cell of the hydrological grid and one side of the
sibstrate layer (which is a shp). It only adds this intersection point if it is not already in point\_all.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{point\_all} -- the coordinates of the hydrological grid

\item {} 
\sphinxstyleliteralstrong{point} -- one intersection point between substrat and hydrological grids

\end{itemize}

\item[{Returns}] \leavevmode
the updated point\_all (the coordinates of the hydrological grid)

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_dummy\_substrate() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.create_dummy_substrate}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{create\_dummy\_substrate}}{\emph{coord\_pro}, \emph{sqrtnp}}{}
For testing purposes, it can be useful to create a substrate input even if one does not exist.
This substrate is compose of n triangle situated on the rivers in the same coodinates system.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the coordinate of each profile

\item {} 
\sphinxstyleliteralstrong{sqrtnp} -- the number of point which will compose one side of the new substrate grid (so the total number
of point is sqrtnb squared).

\end{itemize}

\item[{Returns}] \leavevmode
dummy coord\_sub, ikle\_sub

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_grid() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.create_grid}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{create\_grid}}{\emph{coord\_pro, extra\_pro, coord\_sub, ikle\_sub, nb\_pro\_reach={[}0, 10000000000.0{]}, vh\_pro\_t={[}{]}, q={[}{]}, pnew\_add=1}}{}
It creates a grid from the coord\_pro data using the triangle module.
It creates the grid up to the end of the profile if vh\_pro\_t is not present
or up to the water limit if vh\_pro\_t is present
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{q} -- used in the secondary process (like in hydro\_gui2) when we do not call this function direclty, but we
call it in a second process so that the GUI do not crash if something go wrong

\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the profile coordinates (x,y, h, dist along) the profile

\item {} 
\sphinxstyleliteralstrong{extra\_pro} -- the number of ``extra'' profiles to be added between profile to simplify the grid

\item {} 
\sphinxstyleliteralstrong{coord\_sub} -- (not used anymore)
the coordinate of the point forming the substrate layer (often created with substrate.load\_sub)

\item {} 
\sphinxstyleliteralstrong{ikle\_sub} -- (not used anymore)
the connectivity table of the substrate grid (often created with substrate.load\_sub)

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- the number of reach by profile starting with 0

\item {} 
\sphinxstyleliteralstrong{vh\_pro\_t} -- the velocity and height of the water (used to cut the limit of the river).

\item {} 
\sphinxstyleliteralstrong{pnew\_add} -- (not used anymore) a parameter to cut the substrate side in smaller part (improve grid quality)
in the form dist along profile, h , v for the analyzed time step. f not given, gird is contructed on the whole profile.

\end{itemize}

\item[{Returns}] \leavevmode
connectivity table and grid point

\end{description}\end{quote}

\sphinxstylestrong{Form of the function in summary}
\begin{itemize}
\item {} 
if vh\_pro\_t:
\begin{itemize}
\item {} 
find cordinate under water and used this to update coord\_pro

\item {} 
see if there is islands, find the island limits and the holes indicating the inside/outside of the islands

\end{itemize}

\item {} 
find the point which give the end/start of the segment defining the grid limit

\item {} 
find all point which need to be added to the grid and add extra profile if needed

\item {} 
based on the start/end points and the island limits, create the segments which gives the grid limit

\item {} 
triangulate and so create the grid

\item {} 
flag point which are overlapping in two grids

\end{itemize}

For more info, see the document ``More info on the grid''.

\end{fulllineitems}

\index{create\_grid\_only\_1\_profile() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.create_grid_only_1_profile}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{create\_grid\_only\_1\_profile}}{\emph{coord\_pro, nb\_pro\_reach={[}0, 10000000000.0{]}, vh\_pro\_t={[}{]}}}{}
This function creates the grid from the coord\_pro data using one additional profil in the middle. No triangulation.
The interpolation of the data is done in this function also, contrarily to create\_grid().
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the profile coordinates (x,y, h, dist along) the profile

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- the number of profile by reach

\item {} 
\sphinxstyleliteralstrong{vh\_pro\_t} -- the data with heigh and velocity, giving the river limits

\end{itemize}

\item[{Returns}] \leavevmode
the connevtivity table, the coordinate of the grid, the centroid of the grid, the velocity data on this
grid, the height data on this grid.

\end{description}\end{quote}

For more info on this function, see the document ``More info on the grid''.

\end{fulllineitems}

\index{cut\_2d\_grid() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.cut_2d_grid}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{cut\_2d\_grid}}{\emph{ikle}, \emph{point\_all}, \emph{water\_height}, \emph{velocity}}{}
This function cut the grid of the 2D model to have correct wet surface. If we have a node with h\textless{}0 and other node(s)
with h\textgreater{}0, this function cut the cells to find the wetted perimeter, assuminga linear decrease in the water elevation.
This function works for one time steps and for one reach
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{ikle} -- the connectivity table of the 2D grid

\item {} 
\sphinxstyleliteralstrong{point\_all} -- the coordinate of the point

\item {} 
\sphinxstyleliteralstrong{water\_height} -- the water height data given on the nodes

\item {} 
\sphinxstyleliteralstrong{velocity} -- the velcoity given on the nodes

\end{itemize}

\item[{Returns}] \leavevmode
the update connectivity table, the coodinate of the point, the height of the water and the velocity on the updated grid

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_profile\_between() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.find_profile_between}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{find\_profile\_between}}{\emph{coord\_pro\_p0}, \emph{coord\_pro\_p1}, \emph{nb\_pro}, \emph{trim=True}}{}
Find n profile between two profiles which are not straight. This functions is useful to create the grid from 1D model
as profile in 1D model are often far away from another.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro\_p0} -- the coord\_pro (x,y,h, z) of the first profile

\item {} 
\sphinxstyleliteralstrong{coord\_pro\_p1} -- the coord\_pro (x,y,h, z) of the second profile

\item {} 
\sphinxstyleliteralstrong{nb\_pro} -- the number of profile to add

\item {} 
\sphinxstyleliteralstrong{Trim} -- If True cut the end and start of profile to avoid to have part of the grid outside of the water limit

\end{itemize}

\item[{Returns}] \leavevmode
a list with the updated profiles

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_crossing\_segment\_sub() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.get_crossing_segment_sub}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{get\_crossing\_segment\_sub}}{\emph{p1sub, p2sub, lim\_here, lim\_by\_reachr, point\_all, island, ind\_seg\_sub\_ini={[}0{]}}}{}
This function looks at one substrate segment and find the crossing points of this semgent with the different
segment which composed the hydrological grid. This function is useful to cut the grid as a function of the form
of the substrate layer (to avoid having cells in the hydrological grid which have two substrate value).

If island switch is True, lim\_here is the limit of the island, so
inside the polygon is outside the river. If island is false, lim\_here is the limit of the reach under investigation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{p1sub} -- the start point of the substrate semgent

\item {} 
\sphinxstyleliteralstrong{p2sub} -- the end point of the substrate segment

\item {} 
\sphinxstyleliteralstrong{lim\_here} -- the reach?island limit given in the coordinate system

\item {} 
\sphinxstyleliteralstrong{lim\_by\_reachr} -- the limits for reach r which will be given to triangle given by point\_all indices.

\item {} 
\sphinxstyleliteralstrong{point\_all} -- all the point (ccordinates) which will be given to triangle

\item {} 
\sphinxstyleliteralstrong{island} -- a boolean indicating if we are on an island or not

\item {} 
\sphinxstyleliteralstrong{ind\_seg\_sub\_ini} -- the indices of the first segment add by p1sub et p2sub by the reach. Only used island = true

\end{itemize}

\item[{Returns}] \leavevmode
the updated point\_all and lim\_by\_reach

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_new\_point\_and\_cell\_1\_profil() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.get_new_point_and_cell_1_profil}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{get\_new\_point\_and\_cell\_1\_profil}}{\emph{coord\_pro\_p}, \emph{vh\_pro\_t\_p}, \emph{point\_mid\_x}, \emph{point\_mid\_y}, \emph{point\_all}, \emph{ikle}, \emph{point\_c}, \emph{dir}}{}
This function is use by create\_grid\_one\_profile. It creates the grid for one profile (one ``line'' of triangle).
To create the whole grod this function is called for each profile.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro\_p} -- the coordinates of the profile

\item {} 
\sphinxstyleliteralstrong{vh\_pro\_t\_p} -- the height and velocity data of the profile analysed

\item {} 
\sphinxstyleliteralstrong{point\_mid\_x} -- the x coodinate of the points forming the middle profile

\item {} 
\sphinxstyleliteralstrong{point\_mid\_y} -- the y coordinate of the points forming the middle profile

\item {} 
\sphinxstyleliteralstrong{point\_all} -- the point of the grid

\item {} 
\sphinxstyleliteralstrong{ikle} -- the connectivity table of the grid

\item {} 
\sphinxstyleliteralstrong{point\_c} -- the central point of each cell

\item {} 
\sphinxstyleliteralstrong{dir} -- in which direction are we going around the profile (upstream/downstram)

\end{itemize}

\item[{Returns}] \leavevmode
point\_all, ikle, point\_c (the centroid of the cell)

\end{description}\end{quote}

For more info, see the document ``More info on the grid''.

\end{fulllineitems}

\index{inside\_polygon() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.inside_polygon}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{inside\_polygon}}{\emph{seg\_poly}, \emph{point}}{}
This function find if a point is inside a polygon, using a ray casting algorythm. It is called by various functions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{seg\_poly} -- the segment forming the polygon

\item {} 
\sphinxstyleliteralstrong{point} -- the point which is indide or outside the polygon

\end{itemize}

\item[{Returns}] \leavevmode
True is the point is inside the polygon, false otherwise

\end{description}\end{quote}

\end{fulllineitems}

\index{interpo\_linear() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.interpo_linear}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{interpo\_linear}}{\emph{point\_all}, \emph{coord\_pro}, \emph{vh\_pro\_t}}{}
Using scipy.gridata, this function interpolates the 1.5 D velocity and height to the new grid
It can be used for only one time step. The interpolation is linear.
It is usually called after create\_grid have been called.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{point\_all} -- the coordinate of the grid point

\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the coordinate of the profile. It should be coherent with the coordinate from vh\_pro.
To insure this, pass coord\_pro through the function ``create\_grid'' with the same vh\_pro as input

\item {} 
\sphinxstyleliteralstrong{vh\_pro\_t} -- for each profile, dist along the profile, water height and velocity at a particular time step

\end{itemize}

\item[{Returns}] \leavevmode
the new interpolated data for velocity and water height

\end{description}\end{quote}

\end{fulllineitems}

\index{interpo\_nearest() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.interpo_nearest}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{interpo\_nearest}}{\emph{point\_all}, \emph{coord\_pro}, \emph{vh\_pro\_t}}{}
Using scipy.gridata, this function interpolates the 1.5 D velocity and height to the new grid
It can be used for only one time step. The interpolation is nearest neighbours.
It is usually called after create\_grid have been called.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{point\_all} -- the coordinate of the grid point

\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the coordinate of the profile. It should be coherent with the coordinate from vh\_pro.
To insure this, pass coord\_pro through the function ``create\_grid'' with the same vh\_pro as input

\item {} 
\sphinxstyleliteralstrong{vh\_pro\_t} -- for each profile, dist along the profile, water height and velocity at a particular time step

\end{itemize}

\item[{Returns}] \leavevmode
the new interpolated data for velocity and water height

\end{description}\end{quote}

\end{fulllineitems}

\index{intersection\_seg() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.intersection_seg}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{intersection\_seg}}{\emph{p1hyd}, \emph{p2hyd}, \emph{p1sub}, \emph{p2sub}, \emph{col=True}}{}
This function finds if there is an intersection between two segment (AB and CD). Idea from :
\url{http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect}
It is based on the caluclaion of the cross-product z= 0 for 2D

Careful there is many function using this function, so change here should be thought about.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{p1hyd} -- point A

\item {} 
\sphinxstyleliteralstrong{p2hyd} -- point B

\item {} 
\sphinxstyleliteralstrong{p1sub} -- point C

\item {} 
\sphinxstyleliteralstrong{p2sub} -- point D

\item {} 
\sphinxstyleliteralstrong{col} -- if True, colinear segment crossed. If false, they do not cross

\end{itemize}

\item[{Returns}] \leavevmode
intersect (True or False) and the crossing point (if True, empty is False)

\end{description}\end{quote}

\end{fulllineitems}

\index{linear\_h\_cross() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.linear_h_cross}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{linear\_h\_cross}}{\emph{p1}, \emph{p2}, \emph{h1}, \emph{h2}}{}
This function is called by cut\_2D\_grid. It find the intersection point along a side of the triangle if part of a
cells is dry.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{p1} -- the coordinate (x,y) of the first point

\item {} 
\sphinxstyleliteralstrong{p2} -- the coordinate (x,y) of the first point

\item {} 
\sphinxstyleliteralstrong{h1} -- the water height at p1 (might be negative or positive)

\item {} 
\sphinxstyleliteralstrong{h2} -- the water height at p2 (might be negative or positive)

\end{itemize}

\item[{Returns}] \leavevmode
the intersection point

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.main}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{main}}{}{}
Used to test this module

\end{fulllineitems}

\index{newp() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.newp}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{newp}}{\emph{p0}, \emph{p1}, \emph{extra\_pro}}{}
This function find the start/end of the added profile. If only one profile is needed, it is just the
point in the middle of the start/end of the profile. If mroe than one profile is needed, there are linearly
distributed. This function only give the start and the end of the profile, the profile in full are constructed using
find\_profile\_between()
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{p0} -- the point at the profile p

\item {} 
\sphinxstyleliteralstrong{p1} -- the point at the profile p-1

\item {} 
\sphinxstyleliteralstrong{extra\_pro} -- the number of extra profile needed

\end{itemize}

\item[{Returns}] \leavevmode
the start/end of the new profile

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_grid() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.plot_grid}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{plot\_grid}}{\emph{point\_all\_reach}, \emph{ikle\_all}, \emph{lim\_by\_reach}, \emph{hole\_all}, \emph{overlap}, \emph{point\_c\_all={[}{]}}, \emph{inter\_vel\_all={[}{]}}, \emph{inter\_h\_all={[}{]}}, \emph{path\_im={[}{]}}, \emph{coord\_pro2={[}{]}}}{}
This is a function to plot a grid, it is very similar to the one from hec-ras2D.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{point\_all\_reach} -- the grid point by reach

\item {} 
\sphinxstyleliteralstrong{ikle\_all} -- the connectivity table by reach

\item {} 
\sphinxstyleliteralstrong{lim\_by\_reach} -- the segment giving the limits of the grid

\item {} 
\sphinxstyleliteralstrong{hole\_all} -- the coordinates of the holes

\item {} 
\sphinxstyleliteralstrong{overlap} -- the point of each reach which are also on an other reach

\item {} 
\sphinxstyleliteralstrong{point\_c\_all} -- the centroid of each element

\item {} 
\sphinxstyleliteralstrong{inter\_vel\_all} -- the interpolated velocity for each reach

\item {} 
\sphinxstyleliteralstrong{inter\_h\_all} -- the interpolated height

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the image

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_coord\_pro\_with\_vh\_pro() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.update_coord_pro_with_vh_pro}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{update\_coord\_pro\_with\_vh\_pro}}{\emph{coord\_pro}, \emph{vh\_pro\_t}}{}
The points describing the profile elevation and the points where velocity is measured might not be the same.
Additionally,part of the profile might be dry and we have added points giving the wetted limit in vh\_pro\_t. They were
are not in the original profil (coord\_pro). In this function,
coord\_pro is recalculated to account for these modicfications. It is used by create\_grid() and
create\_grid\_one\_profile, but only if vh\_pro\_t exists.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the original coord\_pro

\item {} 
\sphinxstyleliteralstrong{vh\_pro\_t} -- the value and position of h and velcoity measurement with the river limits

\end{itemize}

\item[{Returns}] \leavevmode
updated coord\_pro

\end{description}\end{quote}

More information in the document ``More info on the grid'' (linked above)

\end{fulllineitems}



\section{Estimhab -source}
\label{\detokenize{index:estimhab-source}}
in src/estimhab.py

The module contains the Estimhab model. For an explanation on the estimhab model, please see
the pdf document \sphinxcode{estimhab2008}
\phantomsection\label{\detokenize{index:module-src.estimhab}}\index{src.estimhab (module)}\index{estimhab() (in module src.estimhab)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.estimhab.estimhab}}\pysiglinewithargsret{\sphinxcode{src.estimhab.}\sphinxbfcode{estimhab}}{\emph{qmes}, \emph{width}, \emph{height}, \emph{q50}, \emph{qrange}, \emph{substrat}, \emph{path\_bio}, \emph{fish\_name}, \emph{path\_im}, \emph{pict=False}}{}
This the function which forms the Estimhab model in HABBY. It is a reproduction in python of the excel file which
forms the original Estimhab model.. Unit in meter amd m\textasciicircum{}3/sec
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{qmes} -- the two measured discharge

\item {} 
\sphinxstyleliteralstrong{width} -- the two measured width

\item {} 
\sphinxstyleliteralstrong{height} -- the two measured height

\item {} 
\sphinxstyleliteralstrong{q50} -- the natural median discharge

\item {} 
\sphinxstyleliteralstrong{qrange} -- the range of discharge

\item {} 
\sphinxstyleliteralstrong{substrat} -- mean height of substrat

\item {} 
\sphinxstyleliteralstrong{pict} -- if true the figure is shown. If false, the figure is not shown

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where the image should be saved

\item {} 
\sphinxstyleliteralstrong{path\_bio} -- the path to the xml file with the information on the fishes

\item {} 
\sphinxstyleliteralstrong{fish\_name} -- the name of the fish which have to be analyzed

\end{itemize}

\item[{Returns}] \leavevmode
habitat value and useful surface (VH and SPU) as a function of discharge

\end{description}\end{quote}

\sphinxstylestrong{Technical comments and walk-through}

First, we get all the discharges on which we want to calculate the SPU (surface ponderée utile),
using the inputs from the user.

Next we use hydrological rating curves (info on google if needed) to get the height and the width of the river for
all discharge. The calculation is based on the width and height of the river measured at two discharges (given by the
user).

Next, we get other parameters which are used in the preference curves such as the Froude number of
the mean discharge or the Reynolds number.

Next, we load the fish data contains in the xml files in the biology folder. Careful, this is not the xml project
file. This are the xml files described above in the “Class EstimhabW” section. There are one xml file per fish and
they described the preference curves. For the argumentation on the form of the relationship, report yourself to the
documentation of Estimhab (one pdf file should in the folder “doc “ in HABBY).

Then, we calculate the habitat values (VH and SPU). Finally, we plot the results in a figure and we save it as
a text file.

\end{fulllineitems}

\index{main() (in module src.estimhab)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.estimhab.main}}\pysiglinewithargsret{\sphinxcode{src.estimhab.}\sphinxbfcode{main}}{}{}
Used to test this module.

\end{fulllineitems}

\index{pass\_to\_float\_estimhab() (in module src.estimhab)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.estimhab.pass_to_float_estimhab}}\pysiglinewithargsret{\sphinxcode{src.estimhab.}\sphinxbfcode{pass\_to\_float\_estimhab}}{\emph{var\_name}, \emph{root}}{}
This is a function to pass from an xml element to a float
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{root} -- the root of the open xml file

\item {} 
\sphinxstyleliteralstrong{var\_name} -- the name of the attribute in the xml file

\end{itemize}

\item[{Returns}] \leavevmode
the float data

\end{description}\end{quote}

\end{fulllineitems}



\section{Stathab - source}
\label{\detokenize{index:stathab-source}}
in src/stathab\_c

This module contains the function used to run the model stathab.For an explanation on
the form of the stathab input, please see the pdf document \sphinxcode{stathabinfo}
\phantomsection\label{\detokenize{index:module-src.stathab_c}}\index{src.stathab\_c (module)}\index{Stathab (class in src.stathab\_c)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src.stathab\_c.}\sphinxbfcode{Stathab}}{\emph{name\_prj}, \emph{path\_prj}}{}
The class for the Stathab model
\index{create\_hdf5() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.create_hdf5}}\pysiglinewithargsret{\sphinxbfcode{create\_hdf5}}{}{}
A function to create an hdf5 file from the loaded txt. It creates ``name\_prj''\_STATHAB.h5, an hdf5 file with the
info from stathab

\end{fulllineitems}

\index{dengauss() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.dengauss}}\pysiglinewithargsret{\sphinxbfcode{dengauss}}{\emph{x}}{}
gaussian density, used only for debugging purposes.
This is not used in Habby, but can be useful if scipy is not available (remplace all stat.norm.cdf with
dengauss)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{x} -- the parameter of the gaussian

\item[{Returns}] \leavevmode
the gaussian density

\end{description}\end{quote}

\end{fulllineitems}

\index{dist\_h() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.dist_h}}\pysiglinewithargsret{\sphinxbfcode{dist\_h}}{\emph{sh0}, \emph{h0}, \emph{bornh}, \emph{h}}{}
The calculation of height distribution  acrros the river
The distribution is a mix of an exponential and guassian.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{sh0} -- the sh of the original data
sh is the parameter of the distribution, gives the relative importance of ganussian and exp distrbution

\item {} 
\sphinxstyleliteralstrong{h} -- the mean height data

\item {} 
\sphinxstyleliteralstrong{h0} -- the mean height

\item {} 
\sphinxstyleliteralstrong{bornh} -- the limits of each class of height

\end{itemize}

\item[{Returns}] \leavevmode
disth the distribution of heights across the river for the mean height h.

\end{description}\end{quote}

\end{fulllineitems}

\index{dist\_v() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.dist_v}}\pysiglinewithargsret{\sphinxbfcode{dist\_v}}{\emph{h}, \emph{d}, \emph{bornv}, \emph{v}}{}
The calculation of velocity distribution across the river
The distribution is a mix of an exponential and guassian.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{h} -- the height which is related to the mean velocity v

\item {} 
\sphinxstyleliteralstrong{d} -- granulo moyenne

\item {} 
\sphinxstyleliteralstrong{bornv} -- the born of the velocity

\item {} 
\sphinxstyleliteralstrong{v} -- the mean velocity

\end{itemize}

\item[{Returns}] \leavevmode
the distribution of velocity across the river

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_sh0() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.find_sh0}}\pysiglinewithargsret{\sphinxbfcode{find\_sh0}}{\emph{disthmesr}, \emph{h0}}{}
the function to find sh0, using a minimzation technique. Not used because the output was string.
Possibly an error on the bornes? We remplaced this function by the function find\_sh0\_maxvrais().
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{disthmesr} -- the measured distribution of height

\item {} 
\sphinxstyleliteralstrong{h0} -- the measured mean height

\end{itemize}

\item[{Returns}] \leavevmode
the optimized sh0

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_sh0\_maxvrais() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.find_sh0_maxvrais}}\pysiglinewithargsret{\sphinxbfcode{find\_sh0\_maxvrais}}{\emph{disthmesr}, \emph{h0}}{}
the function to find sh0, using the maximum of vraisemblance.
This function aims at reproducing the results from the c++ code. Hence, no use of scipy
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{disthmesr} -- the measured distribution of height

\item {} 
\sphinxstyleliteralstrong{h0} -- the measured mean height

\end{itemize}

\item[{Returns}] \leavevmode
the optimized sh0

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_stathab\_from\_hdf5() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.load_stathab_from_hdf5}}\pysiglinewithargsret{\sphinxbfcode{load\_stathab\_from\_hdf5}}{}{}
A function to load the file from an hdf5 whose name is given in the xml project file

\end{fulllineitems}

\index{load\_stathab\_from\_txt() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.load_stathab_from_txt}}\pysiglinewithargsret{\sphinxbfcode{load\_stathab\_from\_txt}}{\emph{reachname\_file}, \emph{end\_file\_reach}, \emph{name\_file\_allreach}, \emph{path}}{}
A function to read and check the input from stathab based on the text files.
All files should be in the same folder.
The file Pref.txt is read in run\_stathab.
If self.fish\_chosen is not present, all fish in the preference file are read.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{reachname\_file} -- the file with the name of the reaches to study (usually listirv.txt)

\item {} 
\sphinxstyleliteralstrong{end\_file\_reach} -- the ending of the files whose names depends on the reach

\item {} 
\sphinxstyleliteralstrong{name\_file\_allreach} -- the name of the file common to all reaches

\item {} 
\sphinxstyleliteralstrong{path} -- the path to the file

\end{itemize}

\item[{Returns}] \leavevmode
the inputs needed for run\_stathab

\end{description}\end{quote}

\end{fulllineitems}

\index{power\_law() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.power_law}}\pysiglinewithargsret{\sphinxbfcode{power\_law}}{\emph{qwh\_r}}{}
The function to calculate power law for discharge and width
ln(h0 = a1 + a2 ln(Q)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{qwh\_r} -- an array where each line in one observatino of Q, width and height

\item[{Returns}] \leavevmode
the coeff of the regression

\end{description}\end{quote}

\end{fulllineitems}

\index{savefig\_stahab() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.savefig_stahab}}\pysiglinewithargsret{\sphinxbfcode{savefig\_stahab}}{}{}
A function to save the results in text and the figure

\end{fulllineitems}

\index{savetxt\_stathab() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.savetxt_stathab}}\pysiglinewithargsret{\sphinxbfcode{savetxt\_stathab}}{}{}
A function to save the stathab result in .txt form

\end{fulllineitems}

\index{stathab\_calc() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.stathab_calc}}\pysiglinewithargsret{\sphinxbfcode{stathab\_calc}}{\emph{path\_pref='.'}, \emph{name\_pref='Pref.txt'}}{}
The function to calculate stathab output.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{path\_pref} -- the path to the preference file

\item {} 
\sphinxstyleliteralstrong{name\_pref} -- the name of the preference file

\end{itemize}

\item[{Returns}] \leavevmode
the biological preferrence index (np.array of {[}reach, specices, nbclaq{]} size), surface or volume by class, etc.

\end{description}\end{quote}

\end{fulllineitems}

\index{test\_stathab() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.test_stathab}}\pysiglinewithargsret{\sphinxbfcode{test\_stathab}}{\emph{path\_ori}}{}
A short function to test part of the outputs against the C++ code,
It is not used in Habby but it is practical to debug.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{path\_ori} -- the path to the files from stathab based on the c++ code

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{load\_float\_stathab() (in module src.stathab\_c)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.load_float_stathab}}\pysiglinewithargsret{\sphinxcode{src.stathab\_c.}\sphinxbfcode{load\_float\_stathab}}{\emph{filename}, \emph{check\_neg}}{}
A function to load float with extra checks
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{filename} -- the file to load with the path

\item {} 
\sphinxstyleliteralstrong{check\_neg} -- if true negative value are not allowed in the data

\end{itemize}

\item[{Returns}] \leavevmode
data if ok, -99 if failed

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_namereach() (in module src.stathab\_c)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.load_namereach}}\pysiglinewithargsret{\sphinxcode{src.stathab\_c.}\sphinxbfcode{load\_namereach}}{\emph{path}, \emph{name\_file\_reach='listriv.txt'}}{}
A function to only load the reach names (useful for the GUI)

:param path : the path to the file listriv.txt
:param name\_file\_reach: In case the file name is not listriv.txt
:return: the list of reach name

\end{fulllineitems}

\index{load\_pref() (in module src.stathab\_c)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.load_pref}}\pysiglinewithargsret{\sphinxcode{src.stathab\_c.}\sphinxbfcode{load\_pref}}{\emph{filepref}, \emph{path}}{}
The function loads the different pref coeffficient contained in filepref
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{filepref} -- the name of the file (usually Pref.txt)

\item {} 
\sphinxstyleliteralstrong{path} -- the path to this file

\end{itemize}

\item[{Returns}] \leavevmode
the name of the fish, a np.array with the differen coeff

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module src.stathab\_c)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.main}}\pysiglinewithargsret{\sphinxcode{src.stathab\_c.}\sphinxbfcode{main}}{}{}
used to test this module.

\end{fulllineitems}



\section{Substrate}
\label{\detokenize{index:substrate}}
in src/substrate.py

This module contains the function to manage the substrate data. This is still a work in progress.
\phantomsection\label{\detokenize{index:module-src.substrate}}\index{src.substrate (module)}\index{fig\_merge\_grid() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.fig_merge_grid}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{fig\_merge\_grid}}{\emph{point\_all\_both\_t}, \emph{ikle\_both\_t}, \emph{path\_im}, \emph{ikle\_orr={[}{]}}, \emph{point\_all\_orr={[}{]}}}{}
A function to plot the grid after it was merged with the substrate data.
It plots one time step at the time.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{point\_all\_both} -- the coordinate of the points of the updated grid

\item {} 
\sphinxstyleliteralstrong{ikle\_both} -- the connectivity table

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where the image should be saved

\item {} 
\sphinxstyleliteralstrong{ikle\_orr} -- the orginial ikle

\item {} 
\sphinxstyleliteralstrong{point\_all\_orr} -- the orginal point\_all

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{fig\_substrate() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.fig_substrate}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{fig\_substrate}}{\emph{coord\_p, ikle, sub\_info, path\_im, xtxt={[}-99{]}, ytxt={[}-99{]}, subtxt={[}-99{]}}}{}
The function to plot the raw substrate data, which was loaded before
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_p} -- the coordinate of the point

\item {} 
\sphinxstyleliteralstrong{ikle} -- the connectivity table

\item {} 
\sphinxstyleliteralstrong{sub\_info} -- the information on subtrate by element

\item {} 
\sphinxstyleliteralstrong{xtxt} -- if the data was given in txt form, the orignal x data

\item {} 
\sphinxstyleliteralstrong{ytxt} -- if the data was given in txt form, the orignal y data

\item {} 
\sphinxstyleliteralstrong{subtxt} -- if the data was given in txt form, the orignal sub data

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the figure

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{grid\_update\_sub2() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.grid_update_sub2}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{grid\_update\_sub2}}{\emph{ikle}, \emph{coord\_p}, \emph{point\_crossing}, \emph{coord\_sub}}{}
A function to find the updated grid with the substrate. More complicated than grid\_update3 because it tries to makes
new cell based on the lines linkes the centroid and the side of the trianlge. Looks more elegant at first but
quite complicated and do not work for all cases. So it is not used.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{ikle} -- the hydrological grid to be merge with the substrate grid

\item {} 
\sphinxstyleliteralstrong{coord\_p} -- the coordinate of the point of the hydrological grid

\item {} 
\sphinxstyleliteralstrong{point\_crossing} -- the crossing point, with the elemtn of the hydrological grid linked with it and the
direction (nx,ny) of the substrate line at this point

\item {} 
\sphinxstyleliteralstrong{coord\_sub} -- the coordinate of the substrate, only useful to if the the substrate cut two time the samie of a
cell of the hydrological grid

\end{itemize}

\item[{Returns}] \leavevmode
the new grid

\end{description}\end{quote}

\end{fulllineitems}

\index{grid\_update\_sub3() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.grid_update_sub3}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{grid\_update\_sub3}}{\emph{ikle}, \emph{coord\_p}, \emph{point\_crossing}, \emph{coord\_sub}}{}
A function to update the grid after finding the crossing points
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{ikle} -- the hydrological grid to be merge with the substrate grid

\item {} 
\sphinxstyleliteralstrong{coord\_p} -- the coordinate of the point of the hydrological grid

\item {} 
\sphinxstyleliteralstrong{point\_crossing} -- the crossing point, with the elemtn of the hydrological grid linked with it and the
direction (nx,ny) of the substrate line at this point

\item {} 
\sphinxstyleliteralstrong{coord\_sub} -- the coordinate of the substrate, only useful to if the the substrate cut two time the samie of a
cell of the hydrological grid

\end{itemize}

\item[{Returns}] \leavevmode
the new grid

\end{description}\end{quote}

\end{fulllineitems}

\index{intersec\_cross() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.intersec_cross}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{intersec\_cross}}{\emph{hyd1}, \emph{hyd2}, \emph{sub1}, \emph{sub2}, \emph{e=-99}, \emph{nx={[}{]}}, \emph{ny={[}{]}}}{}
A function function to calculate the intersection, segment are not parrallel,
used in case where we know that the intersection exists
Also save various info with the intersection (element, direction, etc.)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{hyd1} -- the first hydrological point

\item {} 
\sphinxstyleliteralstrong{hyd2} -- the second

\item {} 
\sphinxstyleliteralstrong{sub1} -- the first substrate point

\item {} 
\sphinxstyleliteralstrong{sub2} -- the second

\item {} 
\sphinxstyleliteralstrong{e} -- the element of the hydrological grid (optional)

\item {} 
\sphinxstyleliteralstrong{nx} -- the direction of the cutting part of the substrate grid (x dir)

\item {} 
\sphinxstyleliteralstrong{ny} -- the direction of the cutting part of the substrate grid (y dir)

\end{itemize}

\item[{Returns}] \leavevmode
intersection and the direction of cutting part.

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_sub\_shp() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.load_sub_shp}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{load\_sub\_shp}}{\emph{filename}, \emph{path}, \emph{name\_att='SUBSTRATE'}}{}
A function to load the substrate in form of shapefile.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{filename} -- the name of the shapefile

\item {} 
\sphinxstyleliteralstrong{path} -- the path where the shapefile is

\item {} 
\sphinxstyleliteralstrong{name\_att} -- the name of the substrate column in the attribute table

\end{itemize}

\item[{Returns}] \leavevmode
grid in form of list of coordinate and connectivity table (two list)
and an array with substrate type

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_sub\_txt() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.load_sub_txt}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{load\_sub\_txt}}{\emph{filename}, \emph{path}}{}
A function to load the substrate in form of a text file. The text file must have 3 column x,y coordinate and
substrate info, no header or title.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{filename} -- the name of the shapefile

\item {} 
\sphinxstyleliteralstrong{path} -- the path where the shapefile is

\end{itemize}

\item[{Returns}] \leavevmode
grid in form of list of coordinate and connectivity table (two list)
and an array with substrate type and (x,y,sub) of the orginal data

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.main}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{main}}{}{}
Used to test this module.

\end{fulllineitems}

\index{merge\_grid\_hydro\_sub() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.merge_grid_hydro_sub}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{merge\_grid\_hydro\_sub}}{\emph{hdf5\_name\_hyd}, \emph{hdf5\_name\_sub}, \emph{default\_data}}{}
After the data for the substrate and the hydrological data are loaded, they are still in different grids.
This functions will merge both grid together. This is done for all time step and all reaches
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{hdf5\_name\_hyd} -- the path and name of the hdf5 file with the hydrological data

\item {} 
\sphinxstyleliteralstrong{hdf5\_name\_sub} -- the path and the name of the hdf5 with the substrate data

\item {} 
\sphinxstyleliteralstrong{default\_data} -- The substrate data given in the region of the hydrological grid where no substrate is given

\end{itemize}

\item[{Returns}] \leavevmode
the connectivity table, the coordinates, the substrated data, the velocity and height data all in a merge form.

\end{description}\end{quote}

\end{fulllineitems}

\index{point\_cross2() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.point_cross2}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{point\_cross2}}{\emph{ikle}, \emph{coord\_p}, \emph{ikle\_sub}, \emph{coord\_p\_sub}}{}
A function which find where the crossing points are. Crossing pitn are the points on the triangular side of the
hydrological grid which cross with a side of the substrate grid. The algo based on finding if points of one elements
are in the same polygon using a ray casting method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{ikle} -- the connectivity table for the hydrological data

\item {} 
\sphinxstyleliteralstrong{coord\_p} -- the coordinates of the points of the hydrological grid

\item {} 
\sphinxstyleliteralstrong{ikle\_sub} -- the connecity vity table of the substrate

\item {} 
\sphinxstyleliteralstrong{coord\_p\_sub} -- the coordinates of the points of the substrate grid

\end{itemize}

\item[{Returns}] \leavevmode
intersection

\end{description}\end{quote}

\end{fulllineitems}

\index{point\_cross\_bis() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.point_cross_bis}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{point\_cross\_bis}}{\emph{ikle}, \emph{coord\_p}, \emph{ikle\_sub}, \emph{coord\_p\_sub}}{}
A function which find where the crossing points are. Crossing pitn are the points on the triangular side of the
hydrological grid which cross with a side of the substrate grid. Easier than point\_cross 2 but slow, so it is not used.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{ikle} -- the connectivity table for the hydrological data

\item {} 
\sphinxstyleliteralstrong{coord\_p} -- the coordinates of the points of the hydrological grid

\item {} 
\sphinxstyleliteralstrong{ikle\_sub} -- the connecity vity table of the substrate

\item {} 
\sphinxstyleliteralstrong{coord\_p\_sub} -- the coordinates of the points of the substrate grid

\end{itemize}

\item[{Returns}] \leavevmode
intersection

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Various notes}
\label{\detokenize{index:various-notes}}

\section{Translation of HABBY}
\label{\detokenize{index:translation-of-habby}}
In HABBY, it is possible to translate all strings which are in a python file (.py)
which is in the src\_GUI folder. It should be possible to translate also strings which
are in a .py file which is in the .src folder if one modifies the .pro file,
but this is not done yet. Also, it might not be necessary because ./src contains
code which is not linked with the graphical interface. Hence, English might be sufficient here.

To add a new string to translate:
\begin{itemize}
\item {} 
Code as usual and write the string in English.

\item {} 
Add self.tr() around the string  a = Qlabel(self.tr(“My message”))

\item {} 
If the code is in a new python file (like the .py was just created), open the habby\_trans.pro file which is src\_GUI. Then add the line SOURCES+= new\_file.py where new\_file.py is the new python file.

\item {} 
If you want to add a new language, add the line TRANSLATIONS += Zen\_ES.ts in the case you want to add Spanish or any other language.

\item {} 
Copy the files ZEN\_EN.ts and ZEN\_FR.ts from HABBY/translation to /src\_GUI

\item {} 
In the src\_GUI folder, run the following command on the cmd: pylupdate5 habby\_trans.pro. it will work if pylupdate is installed.

\item {} 
It should update the .ts file (which is an xml file)

\item {} 
Copy both .ts file back to HABBY/translation

\item {} 
Open Qt  linguist. This is a program that you need to install before. Open the French .ts file. The English should not need translation.

\item {} 
Translate as needed and save in Qt Linguist.

\item {} 
A .qm file is the binary representing the .ts file with all the translation. To create .qm file, type (in the cmd) lrelease  file.ts. It will create a file.qm file

\item {} 
Run HABBY. The string should be updated.

\end{itemize}

\sphinxstylestrong{In the code}

If the user asked for a new language, we need to reload the translator with the following lines:
\begin{quote}

\sphinxstyleemphasis{app = QApplication.instance()}

\sphinxstyleemphasis{self.languageTranslator.load(file.qm, self.path\_trans)}

\sphinxstyleemphasis{app.installTranslator(self.languageTranslator)}
\end{quote}

with the appropriate name for “file.qm”.

In HABBY, the list of the name of all qm file are in the variable self.file\_langue
in class MainWindows. Hence, we can follow the selected language using an integer self.lang
(0 for English and 1 for French). We can now call self.file\_langue{[}self.lang{]} to get the qm
file in the right language. If a new language is added, it is necessary to add one string to this
list and to modify the menu.

When the translator has been created, it is necessary to re-do all Widgets and Windows. This is not a problem when we open HABBY, but it can be a bit of work if the user asks for a change in language when HABBY is running. This is the function of the setlangue function. This function would work for all language (it takes an integer as input to know which language to use), but it needs to be modified if one modifies the Main\_Windows Class strongly (notably if one add signals).
The language should be saved in the user setting using Qsettings as it is done at the end of the
setlangue function.


\section{Create a .exe}
\label{\detokenize{index:create-a-exe}}
Here are step to create a .exe using PyInstaller
\begin{itemize}
\item {} 
install Pyinstaller (pip install pyinstaller)

\item {} 
cd ``folder with source code''

\item {} 
pyinstaller.exe {[}option{]} habby.py, with the option --onefile to get only one .exe and --windowed to not have the cmd which opens with the application.

\end{itemize}

Here are some common problems:
\begin{itemize}
\item {} 
ImportError: (No module named `PyQt5.QtGui'): Copy the folder platform with qwindows.dll and add to the set\_up.py  ``includes'': {[}''PyQt5.QtCore'', ``PyQt5.QtGui''{]}

\item {} 
This application fails to start because ... the Qt platform pugin windows: Copy the folder platform with qwindows.dll in it

\item {} 
ImportError: h5Py ``includes'': {[}''h5py'',''h5py.defs'', ``h5py.utils'', ``h5py.h5ac'', `h5py.\_proxy' {]} etc if necessary

\item {} 
Intel MKL fatal error copy the .dll missing (or just find an old dist and copy all mkl stuff) AND the libiomp5md.dll

\item {} 
The translation does not work: Add the translation folder into the dist folder

\item {} 
Do not find log0.txt (or crash when saving project): create a folder called src\_GUI, copy the files log0.txt and restart\_log0.txt from the src\_GUI folder in the python module

\end{itemize}


\section{Logging}
\label{\detokenize{index:logging}}
\sphinxstylestrong{General information}

There are two different logs for HABBY. By default, the first one is called “name\_projet”.log and
the second is called restart/\_'name\_project'.log. Their name and path can be changed in the xml
project file. Both file are text file.

The first log is in the form of a python file with comments. If python and the necessary modules
are installed on the machine, this log can be renamed “name.py” and started as a python file.
In the command line, the following command should be used: python name.py. This file can be
modified to create a new script to use HABBY in a different ways. For this, python syntax should be used.

The second log, called restart/\_’name\_project’.log, has limited functionalities but allows to
re-start the HABBY simulation from the command line, without the need for python.
Format of this file is described below. It is aimed to be readable and easily modifiable.
To use the restart file, type in the command line: habby restart/\_’name\_project’.log. (not done yet)

\sphinxstylestrong{Type of log and format}

Currently, there are five types of outputs, which can be sent to the log:
\begin{itemize}
\item {} 
Comment, which should start with \#. They will be sent to the python-type log file and to the GUI of Habby.

\item {} 
Errors, which should start with word “Error”. They will be sent to the python-type log file and to the GUI of Habby. In the GUI, they will appear in red.

\item {} 
Warnings, which should start with the word “Warning”. They will be sent to the python-type log file and to the GUI of Habby. In the GUI, they will appear in orange.

\item {} 
Restart info, which should start with the word “restart’. They will be sent to the restart\_’name\_project’.log. The format will be developed afterwards.

\item {} 
All types of text which do not start with these code words are only shown to the GUI of Habby.

\item {} 
Python code, which should start with the line py followed by four spaces.  It will be sent to the python-type log file. It is usually a function which is part of Habby code. The different arguments of the function should be given in the preceding lines.

\end{itemize}

\sphinxstylestrong{Example}

Let’s write to the log a function which takes an integer and a string as input. The function
is in the module called habby1, which is imported by default in the .log file. The strings to send
as log would be:
\begin{itemize}
\item {} 
``\#  this my fancy function''

\item {} 
``py    my\_int = '' + str(my\_int\_in\_code)

\item {} 
``py    my\_string = ’” + my\_string\_in\_the \_code+ ``'“

\item {} 
``py    habby1.myfunc(my\_int, my\_string)''

\end{itemize}

A comment should be added before each chunk of python code to improve the readability.

\sphinxstylestrong{Update the log}

Let’s consider a scenario where a new function has been written in a non-GUI module (class or
function) and has to be called in the GUI in a method of a class. Let’s call the new function
new\_func and the class in the GUI my\_class.

To create a new line of log for new\_func, one should follow these steps:
\begin{itemize}
\item {} 
A PyQtsignal with a string as argument should be added to my\_class: send\_log = pyqtSignal(str, name='send\_log')

\item {} 
If a log should be sent directly from my\_class (for example, to say that new\_func  has been called), the signal should be emitted: self.send\_log.emit(`\# new\_func has been called'))

\item {} 
In the new function,  error and warning are written as follows: print(“Error: here is an error.n”) or print(“Warning:  This is just a warning.n”)

\item {} 
In my\_class, error and warning are collected by redirecting stdout to a string. The following lines of code should be added around the calling of my\_func():
\begin{itemize}
\item {} 
sys.stdout = mystdout = StringIO()  \# redirect stdout

\item {} 
my\_func(my\_int,my\_string)

\item {} 
sys.stdout = sys.\_\_stdout\_\_   \# re-sent stdout to the cmd

\item {} 
str\_found = mystdout.getvalue()   \# get all warning, error, text,…

\item {} 
str\_found = str\_found.split(`n')  \# separate each message

\item {} 
for i in range(0, len(str\_found)):
\begin{itemize}
\item {} 
if len(str\_found{[}i{]}) \textgreater{} 1:
\begin{itemize}
\item {} 
self.send\_log.emit(str\_found{[}i{]})  \#send the text

\end{itemize}

\end{itemize}

\end{itemize}

\item {} 
To import StringIO, the following statement is needed at the start of the code: from io import StringIO

\item {} 
If new\_func is called from the command line, stdout will not be redirected and the errors or warnings will be printed on the cmd as usual.  Stderr should be re-directed in a similar manner if needed.

\item {} 
The signal should be collected in the function connect\_signal\_log in the Main\_Windows\_1.py.  For this, a line should be added in the function:
*       self.my\_class.send\_log.connect(self.write\_log)

\end{itemize}

\sphinxstylestrong{Format of the restart file}

To be determined.


\section{Git - code management}
\label{\detokenize{index:git-code-management}}
\sphinxstylestrong{Pour commencer:}
\begin{itemize}
\item {} 
Choisir un dossier sur l’ordinateur local ou va se trouver les fichiers sources.

\item {} 
cd  « dossier avec les codes source»

\item {} 
git config - - global user.name « username »

\item {} 
git config - - global user.email  « mail »

\item {} 
git init

\item {} 
lier le repertoire local avec le repertoire distant sur forge.irstea.fr

\end{itemize}

\sphinxstylestrong{Pour mettre une nouvelle version sur le site web}
\begin{itemize}
\item {} 
cd « dossier avec les codes source»

\item {} 
git pull (prend la dernière version à jour sur le site et mets tous les fichiers ensemble) ou git fetch (prend juste les derniers fichiers sans mettre tous les fichiers ensemble).

\item {} 
git add ‘my\_file.py ou .pyc’ (choisit les fichiers qui doivent être envoyé), le signe * fonctionne.

\item {} 
git log (donne l’historique)

\item {} 
git status (donne les nouveaux fichiers locals)

\item {} 
git commit \textendash{}m « description » (commit localement)

\item {} 
git push

\end{itemize}

\sphinxstylestrong{Pour ajouter une nouvelle branche}
\begin{itemize}
\item {} 
Donc pour avoir une partie du travail sépare du reste

\item {} 
git checkout \textendash{}b {[}branchname{]} pour créer la branche et y travailler

\item {} 
git checkout {[}branchname{]} pour y travailler

\end{itemize}


\section{Write the documentation}
\label{\detokenize{index:write-the-documentation}}
Habby uses Sphinx to document the code. Sphinx uses the docstring given in each function. Hence, it is necessary to write a docstring for each function which has to be documented.

To update the html documentation, go to the doc folder and execute the command: “make html”.

To update the Latex documentation, use the commande ``make latex'' and use Miketex to create the pdf. rts2pdf does not work with Python 3.

To add text in the documentation, modify the index.rst file in the doc folder. To add a new module to the
documentation, add the module as written in the index.rts file in the doc folder. To add text comment, the index.rts file can also be direclty modified.

It is important to keep the formatting and the alignment.

If the module is in a new folder, the address of the folder must be added to the config.py file.
It is better to not use absolute path for this, so it is possible to move the documentation on another
computer. If the documentation does not run on a new computer, check the path given in the config.py file.

In the docstring, add as many blank lines as possible (in reasonable limit). This is easier for the
formatting. To make a bullet list, one should use a tab and the symbol “*”.  Using only the symbol * will
fail.

To add a new title, do not start the title or the line of symbol under the title with a blank space.


\section{License of used python modules}
\label{\detokenize{index:license-of-used-python-modules}}\begin{itemize}
\item {} 
h5py: BSD License

\item {} 
Element tree (XML): MIT License

\item {} 
numpy: BSD License

\item {} 
matplotlib: BSD License

\item {} 
PyQt5: GNU License

\end{itemize}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{s}
\item {\sphinxstyleindexentry{src}}\sphinxstyleindexpageref{index:\detokenize{module-src}}
\item {\sphinxstyleindexentry{src.dist\_vistess2}}\sphinxstyleindexpageref{index:\detokenize{module-src.dist_vistess2}}
\item {\sphinxstyleindexentry{src.estimhab}}\sphinxstyleindexpageref{index:\detokenize{module-src.estimhab}}
\item {\sphinxstyleindexentry{src.Hec\_ras06}}\sphinxstyleindexpageref{index:\detokenize{module-src.Hec_ras06}}
\item {\sphinxstyleindexentry{src.hec\_ras2D}}\sphinxstyleindexpageref{index:\detokenize{module-src.hec_ras2D}}
\item {\sphinxstyleindexentry{src.load\_hdf5}}\sphinxstyleindexpageref{index:\detokenize{module-src.load_hdf5}}
\item {\sphinxstyleindexentry{src.manage\_grid\_8}}\sphinxstyleindexpageref{index:\detokenize{module-src.manage_grid_8}}
\item {\sphinxstyleindexentry{src.mascaret}}\sphinxstyleindexpageref{index:\detokenize{module-src.mascaret}}
\item {\sphinxstyleindexentry{src.river2d}}\sphinxstyleindexpageref{index:\detokenize{module-src.river2d}}
\item {\sphinxstyleindexentry{src.rubar}}\sphinxstyleindexpageref{index:\detokenize{module-src.rubar}}
\item {\sphinxstyleindexentry{src.selafin\_habby1}}\sphinxstyleindexpageref{index:\detokenize{module-src.selafin_habby1}}
\item {\sphinxstyleindexentry{src.stathab\_c}}\sphinxstyleindexpageref{index:\detokenize{module-src.stathab_c}}
\item {\sphinxstyleindexentry{src.substrate}}\sphinxstyleindexpageref{index:\detokenize{module-src.substrate}}
\item {\sphinxstyleindexentry{src\_GUI}}\sphinxstyleindexpageref{index:\detokenize{module-src_GUI}}
\item {\sphinxstyleindexentry{src\_GUI.estimhab\_GUI}}\sphinxstyleindexpageref{index:\detokenize{module-src_GUI.estimhab_GUI}}
\item {\sphinxstyleindexentry{src\_GUI.hydro\_GUI\_2}}\sphinxstyleindexpageref{index:\detokenize{module-src_GUI.hydro_GUI_2}}
\item {\sphinxstyleindexentry{src\_GUI.Main\_windows\_1}}\sphinxstyleindexpageref{index:\detokenize{module-src_GUI.Main_windows_1}}
\item {\sphinxstyleindexentry{src\_GUI.output\_fig\_GUI}}\sphinxstyleindexpageref{index:\detokenize{module-src_GUI.output_fig_GUI}}
\item {\sphinxstyleindexentry{src\_GUI.stathab\_GUI}}\sphinxstyleindexpageref{index:\detokenize{module-src_GUI.stathab_GUI}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
