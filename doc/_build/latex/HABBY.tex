%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=49336sp\relax

\usepackage[margin=1in,marginparwidth=0.5in]{geometry}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}

\usepackage{multirow}
\usepackage{eqparbox}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing }}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{2}



\title{HABBY Documentation}
\date{Nov 06, 2017}
\release{1}
\author{Diane von Gunten, Yann Le Coarer and Fabrice Zaoui}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


HABBY is a program to estimate the habitat of fish using various hydrological models and preference curve as input.


\chapter{How to execute HABBY}
\label{\detokenize{index:how-to-execute-habby}}\label{\detokenize{index:welcome-to-habby-s-documentation}}\begin{description}
\item[{To execute HABBY:}] \leavevmode\begin{itemize}
\item {} 
Go to folder which contains habby.py using the command line.

\item {} 
Open the command line and type python habby.py.

\end{itemize}

\end{description}

The python version should be 3.4. HABBY should also function with most of the python 3 distributions.

If a module is missing, it is possible to install it using pip (``pip install -m \sphinxstyleemphasis{module\_name}''). Obviously, pip needs to installed, which should be done by default in python 3.4. If you want to be sure to have the same version of the module than originally, go to the folder zen\_file/wheele with the command line and install the missing module from there (something similar to ``pip install -m \sphinxstyleemphasis{.whl}''). Not all modules are in this folder, only the ones which were difficult to install.


\chapter{Main(   ) and source code}
\label{\detokenize{index:main-and-source-code}}
The source code is separated in two folders: one folder which contain the code source for the graphical user interface (GUI) and one folder for the rest of the code source.

The dependency between the different part of the source code can be visualized in the mindmap real\_GUI.xmind (xmind should be installed).

The main of HABBY is habby.py. It has the usual form for an application using PyQt5.  The main() creates an application of QWidget and call the Main\_Windows class, which we will discuss shortly. The last line closes the application.

It is also possible to call habby from the command line without the GUI. For this, the script called habby\_cmd.py is used.


\chapter{Graphical interface}
\label{\detokenize{index:graphical-interface}}
Here is the list of all modules contains in the src\_GUI folder.


\section{Main\_windows of HABBY}
\label{\detokenize{index:main-windows-of-habby}}
in src\_GUI/Main\_Windows\_1.py
\phantomsection\label{\detokenize{index:module-src_GUI}}\index{src\_GUI (module)}\phantomsection\label{\detokenize{index:module-src_GUI.Main_windows_1}}\index{src\_GUI.Main\_windows\_1 (module)}\index{CentralW (class in src\_GUI.Main\_windows\_1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.Main\_windows\_1.}\sphinxbfcode{CentralW}}{\emph{rech}, \emph{path\_prj}, \emph{name\_prj}, \emph{lang\_bio}}{}
This class create the different tabs of the programm, which are then used as the central widget by the class
MainWindows.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{rech} -- A bollean which is True if the tabs for the ``research option'' are shown. False otherwise.

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- A string with the path to the project xml file

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- A string with the name of the project

\item {} 
\sphinxstyleliteralstrong{lang\_bio} -- A string with the word `English', `French' (or an other language). It is used to find the langugage
in which the biological info should be shown. So lang\_bio should have the same form than the attribute
``langugage'' in xml preference file.

\end{itemize}

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

In the attribute list, there are a series of name which finish by “tab” such as stathab\_tab or output\_tab. Each of
these names corresponds to one tab and a new name should be added to the attributes to add a new tab.

During the creation of the class, each tab is created. Then, the signals to show the figures are connected between this
class and all the children classes which need it (often this are the classes used to load the hydrological data). When a
class emits the signal “show\_fig”, CentralW collect this signal and show the figure, using the showfig function.

Show\_fig is mostly a “plt.show()”. To avoid problem between matplotlib and PyQt, it is however important that
matplotlib use the backend “Qt5Agg” in the .py where the “plt.plot” is called. Practically, this means modifying
the matplotlib import.

Showfig shows only one figure. To show all existing figures, one can call the function show\_fig2 from the menu.
Show\_fig2 call the instance child\_win of the class ShowImageW to open a new Windows with all figure. However,
this would only show the figure without any option for the zoom.

Then we call a function which connects all the signals from each class which need to write into the log. It is a good
policy to create a “send\_log” signal for each new important class. As there are a lot of signal to connect, these
connections are written in the function “connect\_signal\_log”, where the signal for a new class can be added.

When this is done, the info for the general tab (created before) is filled. If the user has opened a project in HABBY
before, the name of the project and the other info related to it will be shown on the general tab. If the general
tab is modified in the class WelcomeW(), this part of the code which fill the general tab will probably needs to
be modified.

Finally, each tab is filled. The tabs have been created before, but there were empty. Now we fill each one with the
adequate widget. This is the link with many of the other classes that we describe below. Indeed, many of the widget
are based on more complicated classes created for example in hydro\_GUI\_2.py.

Then, we create an area under it for the log. Here HABBY will write various infos for the user. Two things to note
here: a) we should show the end of the scroll area. b) The size of the area should be controlled and not be
changing even if a lot of text appears. Hence, the setSizePolicy should be fixed.

The write\_log() and write\_log\_file() method are explained in the section about the log.
\index{add\_all\_tab() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.add_all_tab}}\pysiglinewithargsret{\sphinxbfcode{add\_all\_tab}}{}{}
This function add the different tab to habby (used by init and by save\_project). Careful, if you change the
position of the Option tab, you should also modify the varaible self.opttab in init

\end{fulllineitems}

\index{closefig() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.closefig}}\pysiglinewithargsret{\sphinxbfcode{closefig}}{}{}
A small function to close the images open in HABBY and managed by matplotlib

\end{fulllineitems}

\index{connect\_signal\_fig\_and\_drop() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.connect_signal_fig_and_drop}}\pysiglinewithargsret{\sphinxbfcode{connect\_signal\_fig\_and\_drop}}{}{}
This function connect the PyQtsignal to show figure and to connect the log. It is a function to
improve lisibility.

\end{fulllineitems}

\index{connect\_signal\_log() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.connect_signal_log}}\pysiglinewithargsret{\sphinxbfcode{connect\_signal\_log}}{}{}
connect all the signal linked to the log. This is in a function only to improve lisibility.

\end{fulllineitems}

\index{init\_iu() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
A function to initialize an instance of CentralW. Called by \_\_init\_\_\_().

\end{fulllineitems}

\index{optfig() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.optfig}}\pysiglinewithargsret{\sphinxbfcode{optfig}}{}{}
A small function which open the output tab.

\end{fulllineitems}

\index{save\_info\_projet() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.save_info_projet}}\pysiglinewithargsret{\sphinxbfcode{save\_info\_projet}}{}{}
This function is used to save the description of the project and the username in the xml project file

\end{fulllineitems}

\index{save\_on\_change\_tab() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.save_on_change_tab}}\pysiglinewithargsret{\sphinxbfcode{save\_on\_change\_tab}}{}{}
This function is used to save the data when the tab are changed. In most tab this is not needed as data
is alredy saved by another functions. However, it is useful for the Welcome Tab and the Option Tab.
This function can be modified if needed for new tabs.

Careful, the order of the tab is important here.

\end{fulllineitems}

\index{scrolldown() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.scrolldown}}\pysiglinewithargsret{\sphinxbfcode{scrolldown}}{}{}
Move the scroll bar to the bottow if the ScollArea is getting bigger

\end{fulllineitems}

\index{showfig() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.showfig}}\pysiglinewithargsret{\sphinxbfcode{showfig}}{}{}
A small function to show the last figure

\end{fulllineitems}

\index{showfig2() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.showfig2}}\pysiglinewithargsret{\sphinxbfcode{showfig2}}{}{}
A function to see all saved figures without possibility to zoom

\end{fulllineitems}

\index{update\_hydro\_hdf5\_name() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.update_hydro_hdf5_name}}\pysiglinewithargsret{\sphinxbfcode{update\_hydro\_hdf5\_name}}{}{}
This is a short function used to read all the hydrological data (contained in an hdf5 files) available in
one project.

When these files are read, they are added to the drop-down menu on the hydrological tab an on the substrate tab.
On the substrate Tab, if we have more than one hdf5 file, the first item is blank to insure that the user
actively choose the hdf5 to reduce the risk of error (Otherwise the user might merge the substrate and
an hydrological hdf5 without seeing that he needs to select the right hydrological hdf5).

This tasks should be in a function because an update to this list can be triggered by the loading of a new
hydrological data. The class Hydro2W() and substrateW() noticed this through the signal drop\_hydro
send by the hydrological class. The signal drop\_hydro is connected to this function is in the class
CentralW in MainWindows.py.

\end{fulllineitems}

\index{update\_merge\_for\_chronicle() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.update_merge_for_chronicle}}\pysiglinewithargsret{\sphinxbfcode{update\_merge\_for\_chronicle}}{}{}
This function looks up the list of merge file in the QComBox in the bio\_info tab and copy this
list to the QCombobox in chronicle\_GUI. So the two lists of merge file are the same

\end{fulllineitems}

\index{write\_log() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.write_log}}\pysiglinewithargsret{\sphinxbfcode{write\_log}}{\emph{text\_log}}{}
A function to write the different log. Please read the section of the doc on the log.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{text\_log} -- the text which should be added to the log (a string)

\end{description}\end{quote}
\begin{itemize}
\item {} 
if text\_log start with \# -\textgreater{} added it to self.l2 (QLabel) and the .log file (comments)

\item {} 
if text\_log start with restart -\textgreater{} added it restart\_nameproject.txt

\item {} 
if text\_log start with WARNING -\textgreater{} added it to self.l2 (QLabel) and the .log file

\item {} 
if text\_log start with ERROR -\textgreater{} added it to self.l2 (QLabel) and the .log file

\item {} 
if text\_log start with py -\textgreater{} added to the .log file (python command)

\item {} 
if text\_log starts with Process -\textgreater{} Text added to the StatusBar only

\item {} 
if text\_log == ``clear status bar'' -\textgreater{} the status bar is cleared

\item {} 
if text\_log start with nothing -\textgreater{} just print to the Qlabel

\item {} 
if text\_log out from stdout -\textgreater{} added it to self.l2 (QLabel) and the .log file (comments)

\end{itemize}

if logon = false, do not write in log.txt

\end{fulllineitems}

\index{write\_log\_file() (src\_GUI.Main\_windows\_1.CentralW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CentralW.write_log_file}}\pysiglinewithargsret{\sphinxbfcode{write\_log\_file}}{\emph{text\_log}, \emph{pathname\_logfile}}{}
A function to write to the .log text. Called by write\_log.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{text\_log} -- the text to be written (string)

\item {} 
\sphinxstyleliteralstrong{pathname\_logfile} -- the path+name where the log is

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CreateNewProject (class in src\_GUI.Main\_windows\_1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CreateNewProject}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.Main\_windows\_1.}\sphinxbfcode{CreateNewProject}}{\emph{lang}, \emph{path\_trans}, \emph{file\_langue}, \emph{oldpath\_prj}}{}
A class which is used to help the user to create a new project
\index{init\_iu() (src\_GUI.Main\_windows\_1.CreateNewProject method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CreateNewProject.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
\end{fulllineitems}

\index{save\_project (src\_GUI.Main\_windows\_1.CreateNewProject attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CreateNewProject.save_project}}\pysigline{\sphinxbfcode{save\_project}}
a signal to save the project

\end{fulllineitems}

\index{send\_log (src\_GUI.Main\_windows\_1.CreateNewProject attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CreateNewProject.send_log}}\pysigline{\sphinxbfcode{send\_log}}
A PyQt signal used to write the log

\end{fulllineitems}

\index{setfolder() (src\_GUI.Main\_windows\_1.CreateNewProject method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.CreateNewProject.setfolder}}\pysiglinewithargsret{\sphinxbfcode{setfolder}}{}{}
This function is used by the user to select the folder where the xml project file will be located.

\end{fulllineitems}


\end{fulllineitems}

\index{EmptyTab (class in src\_GUI.Main\_windows\_1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.EmptyTab}}\pysigline{\sphinxstrong{class }\sphinxcode{src\_GUI.Main\_windows\_1.}\sphinxbfcode{EmptyTab}}
This class is  used to fill empty tabs with something during the developement.
It will not be use in the final version.
\index{addtext() (src\_GUI.Main\_windows\_1.EmptyTab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.EmptyTab.addtext}}\pysiglinewithargsret{\sphinxbfcode{addtext}}{}{}
This function print a string on the command line. This is useful if you need to check if a button (or similar).
is connected.

\end{fulllineitems}

\index{init\_iu() (src\_GUI.Main\_windows\_1.EmptyTab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.EmptyTab.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
Used in the initialization.

\end{fulllineitems}


\end{fulllineitems}

\index{MainWindows (class in src\_GUI.Main\_windows\_1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows}}\pysigline{\sphinxstrong{class }\sphinxcode{src\_GUI.Main\_windows\_1.}\sphinxbfcode{MainWindows}}
The class MainWindows contains the menu and the title of all the HABBY windows.
It also create all the widgets which can be called during execution

\sphinxstylestrong{Technical comments and walk-through}

First, we load the user setting using Qsettings: The settings by default of Qsettings are the name of the program (HABBY) and
the name of the organization which develops the program (irstea).  I have added three user settings (the name of the
last project loaded into HABBY, the path to this project and the language used). The Qsetting are stored in the
registry in Windows. Qsettings also function with Apple and Linux even if the information is stored differently

We set up the translation next. The translation of HABBY in different language is explained in more detail in
the section “Translation of HABBY”. We give here the path to the data related to the translation. More precisely, we indicate
here the path to the translation data and the name of the qm file containing the data related to the translation
in each language. If a new qm is added for a new language, it should be added here to the list.

Now, two important attributes are defined: self.name\_prj and self.path\_prj. These attribute will be communicated to
children classes. For each project, an xml file is created. This “project” file should be called name\_prj.xml
and should be situated in the path indicated by self.path\_prj.

We call the central\_widget which contains the different tabs.

We create the menu of HABBY calling the function my menu\_bar().

Two signal are connected, one to save the project (i.e to update the xml project file) and another to save an
ESTIMHAB calculation.

We show the created widget.
\index{change\_name\_project() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.change_name_project}}\pysiglinewithargsret{\sphinxbfcode{change\_name\_project}}{}{}
This function is used to change the name of the current project. To do this, it copies the xml
project with a new name and copy the file for the log with a new name

\end{fulllineitems}

\index{check\_concurrency() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.check_concurrency}}\pysiglinewithargsret{\sphinxbfcode{check\_concurrency}}{}{}
This function tests if the project which is opening by HABBY is not used by another instance of HABBY. It is
dangerous  to open two time the same project as we have problem with the writing of the xml files.

To check if a project is open, we have a text file in the project folder named ``check\_concurrency.txt''.
In this text file, there is either the word ``open'' or ``close''. When HABBY open a new project, it checks
this file is set to close and change it to open. Hence, if a project is oen twice a warning is writtem/

\end{fulllineitems}

\index{clear\_log() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.clear_log}}\pysiglinewithargsret{\sphinxbfcode{clear\_log}}{}{}
Clear the log in the GUI.

\end{fulllineitems}

\index{closeEvent() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.closeEvent}}\pysiglinewithargsret{\sphinxbfcode{closeEvent}}{\emph{event}}{}
This is the function which handle the closing of the program. It use the function end\_concurrency() to indicate
to other habby instances that we do not use a particular project anymore.

We use os\_exit instead of sys.exit so it also close the other thread if more than one is open.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{event} -- managed by the operating system.

\end{description}\end{quote}

\end{fulllineitems}

\index{close\_project() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.close_project}}\pysiglinewithargsret{\sphinxbfcode{close\_project}}{}{}
This function close the current project wihout opening a new project

\end{fulllineitems}

\index{close\_rech() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.close_rech}}\pysiglinewithargsret{\sphinxbfcode{close\_rech}}{}{}
Close the additional research menu (see open\_rech for more information). For the moment, ONLY works with
two research tabs. Modify this function if a different number of tab is needed.

\end{fulllineitems}

\index{create\_menu\_right() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.create_menu_right}}\pysiglinewithargsret{\sphinxbfcode{create\_menu\_right}}{}{}
This function create the menu for right click

\end{fulllineitems}

\index{do\_log() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.do_log}}\pysiglinewithargsret{\sphinxbfcode{do\_log}}{\emph{save\_log}}{}
Save or not save the log
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{save\_log} -- an int which indicates if the log should be saved or not

\end{description}\end{quote}
\begin{itemize}
\item {} 
0: do not save log

\item {} 
1: save the log in the .log file and restart file

\end{itemize}

\end{fulllineitems}

\index{empty\_project() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.empty_project}}\pysiglinewithargsret{\sphinxbfcode{empty\_project}}{}{}
This function open a new empty project

\end{fulllineitems}

\index{end\_concurrency() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.end_concurrency}}\pysiglinewithargsret{\sphinxbfcode{end\_concurrency}}{}{}
This functiion indicates to the project folder than this project is not used anymore. Hence, this project
can be used freely by an other instance of HABBY.

\end{fulllineitems}

\index{erase\_pict() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.erase_pict}}\pysiglinewithargsret{\sphinxbfcode{erase\_pict}}{}{}
All files contained in the folder indicated by path\_im will be deleted.

From the menu of HABBY, it is possible to ask to erase all files in the folder indicated by path\_im
(usually figure\_HABBY). Of course, this is a bit dangerous. So the function asks the user for confirmation.
However, it is practical because you do not have to go to the folder to erase all the images when there
are too many of them.

\end{fulllineitems}

\index{init\_ui() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.init_ui}}\pysiglinewithargsret{\sphinxbfcode{init\_ui}}{}{}
Used by \_\_init\_\_() to create an instance of the class MainWindows

\end{fulllineitems}

\index{my\_menu\_bar() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.my_menu_bar}}\pysiglinewithargsret{\sphinxbfcode{my\_menu\_bar}}{\emph{right\_menu=False}}{}
This function creates the menu bar of HABBY when call without argument or with the argument right\_menu is False.
if right menu is True, it creates a very similar menu but we use a QMenu() instead of a QMenuBar() as it
is the menu open when the user right click
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{right\_menu} -- If call with True, we create a menu for the right click and not for the menu part on the top
of the screen.

\end{description}\end{quote}

\end{fulllineitems}

\index{my\_toolbar() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.my_toolbar}}\pysiglinewithargsret{\sphinxbfcode{my\_toolbar}}{}{}
\end{fulllineitems}

\index{new\_project() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.new_project}}\pysiglinewithargsret{\sphinxbfcode{new\_project}}{}{}
This function open an empty project and guide the user to create a new project, using a new Windows
of the class CreateNewProject

\end{fulllineitems}

\index{on\_context\_menu() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.on_context_menu}}\pysiglinewithargsret{\sphinxbfcode{on\_context\_menu}}{\emph{point}}{}
This function is used to show the menu on right click. If we are ont he Habitat Tab and that the focus is on
the QListWidget, it shows the informatin concerning the fish
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{point} -- Not understood, linke with the position of the menu.

\end{description}\end{quote}

\end{fulllineitems}

\index{open\_help() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.open_help}}\pysiglinewithargsret{\sphinxbfcode{open\_help}}{}{}
This function open the html which form the help from HABBY. For the moment, it is the full documentation
with all the coding detail, but we should create a new html or a new pdf file which would be more pratical
for the user.

\end{fulllineitems}

\index{open\_project() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.open_project}}\pysiglinewithargsret{\sphinxbfcode{open\_project}}{}{}
This function is used to open an existing habby project by selecting an xml project file. Called by
my\_menu\_bar()

\end{fulllineitems}

\index{open\_recent\_project() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.open_recent_project}}\pysiglinewithargsret{\sphinxbfcode{open\_recent\_project}}{\emph{j}}{}
This function open a recent project of the user. The recent project are listed in the menu and can be
selected by the user. When the user select a recent project to open, this function is called. Then, the name of
the recent project is selected and the method save\_project() is called.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{j} -- This indicates which project should be open, based on the order given in the menu

\end{description}\end{quote}

\end{fulllineitems}

\index{open\_rech() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.open_rech}}\pysiglinewithargsret{\sphinxbfcode{open\_rech}}{}{}
Open the additional research tab, which can be used to create Tab with more experimental contents.

Indeed, it is possible to show extra tab in HABBY. These supplementary tab correspond to open for researcher.
The plan is that these options are less tested than other mainstream options. It is not clear yet what
will be added to these options, but the tabs are already there when it will be needed.

\end{fulllineitems}

\index{save\_project() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.save_project}}\pysiglinewithargsret{\sphinxbfcode{save\_project}}{}{}
A function to save the xml file with the information on the project

\sphinxstylestrong{Technical comments}

This function saves or creates the xml file related to the projet. In this xml file, there are the path and
the name to all files related to the project, notably the hdf5 files containing the hydrological data.

To find or create the xml file, we use the attribute self.path\_prj and self.name\_proj. If the path to
the project directory is not found an error appears. The error is here sent though additional windows
(to be sure that the user notice this problem), using the Qmesssage module. The user should give the general
info about the project in the general tab of HABBY and they are collected here. User option (using Qsetting)
is next updated so that the user will find his project open the next time it opens HABBY.

When HABBY open, there are therefore  two choice: a) This is a new project b) the project exists already.
If the project is new, the xml file is created and general information is written in this file. In addition,
the text file which are necessary to log the action of HABBY are created now. This part of the reason why it
is not possible to run other part of HABBY (such as loading hydrological data) before a project is saved.
In addition, it would create a lot of problems on where to store the data created. Hence, a project is needed
before using HABBY. If the project exists already (i.e. the name and the path of the project have not been
modified), the xml file is just updated to change its attributes as needed.

Interesting path are a) the biology path (named ``biology'' by default) which contains the biological information
such as the preference curve and b) the path\_im which is the path where all figures and most outputs of HABBY
is saved. If path\_im is not given, HABBY automatically create a folder called figures when the
user creates a new project. The user can however change this path if he wants. It also create other similar
folders to sotre different type of outputs. The next step is to communicate
to all the children widget than the name and path of the project have changed.

This function also changes the title of the Windows to reflect the project name and it adds the saved
project to the list of recent project if it is not part of the list already. Because of this the menu must
updated.

Finally the log is written (see “log and HABBY in the command line).

\end{fulllineitems}

\index{save\_project\_estimhab() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.save_project_estimhab}}\pysiglinewithargsret{\sphinxbfcode{save\_project\_estimhab}}{}{}
A function to save the information linked with Estimhab in an hdf5 file.

\sphinxstylestrong{Technical comments}

This function save the data and result from the estimhab calculation. It would look more logic if it was in
the esimhab.py script, but it was easier to call it from here instead of in the child class.

This function get all estimhab input, create an hdf5 file using h5py and save the data in the hdf5. One
specialty of hdf5 is that is cannot use Unicode. Hence all string have to be passed to ascii using the encode
function. The size of each data should also be known.

Finally, we save the name and path of the estimhab file in the xml project file.

\end{fulllineitems}

\index{save\_project\_if\_new\_project() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.save_project_if_new_project}}\pysiglinewithargsret{\sphinxbfcode{save\_project\_if\_new\_project}}{}{}
This function is used to save a project when the project is created from the other Windows CreateNewProject. It
can not be in the new\_project function as the new\_project function call CreateNewProject().

\end{fulllineitems}

\index{see\_file() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.see_file}}\pysiglinewithargsret{\sphinxbfcode{see\_file}}{}{}
This function allows the user to see the files in the project folder and to open them.

\end{fulllineitems}

\index{setlangue() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.setlangue}}\pysiglinewithargsret{\sphinxbfcode{setlangue}}{\emph{nb\_lang}}{}
A function which change the language of the programme. It change the menu and the central widget.
It uses the self.lang attribute which should be set to the new language before calling this function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{nb\_lang} -- the number representing the language (int)

\end{description}\end{quote}
\begin{itemize}
\item {} 
0 is for English

\item {} 
1 for French

\item {} 
n for any additionnal language

\end{itemize}

\end{fulllineitems}

\index{test\_entry\_float() (src\_GUI.Main\_windows\_1.MainWindows method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.MainWindows.test_entry_float}}\pysiglinewithargsret{\sphinxbfcode{test\_entry\_float}}{\emph{var\_in}}{}
An utility function to test if var\_in are float or not
the boolean self.does\_it\_work is used to know if the functions run until the end.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{var\_in} -- the QlineEdit which contains the data (so var\_in.text is a string)

\item[{Returns}] \leavevmode
the tested variable var\_in

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ShowImageW (class in src\_GUI.Main\_windows\_1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.ShowImageW}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.Main\_windows\_1.}\sphinxbfcode{ShowImageW}}{\emph{path\_prj}, \emph{name\_prj}}{}
The widget which shows the saved images. Used only to show all the saved figure together iwhtout zoom or other
options. Not really used anymore in HABBY but it still there as it can be useful in the future.

\sphinxstylestrong{Technical comments}

The ShowImageW() class is used to show all the figures created by HABBY. It is a class which can only be
called from the menu (In Option/Option Image). This is not the usual way of opening a figure which is usually done
by plt.show from matplotlib. This is the way to look at all figures  together, which can be useful, even if zooming
is not possible anymore.

To show all image, HABBY open a separate window and show the saved image in .png format.  Currently, the figures
shown are in .png, but other formats could be used. For this, one can change the variable self.imtype.

An important point for the ShowImageW  class  is where the images were saved by the functions which created them.
In HABBY, all figures are saved in the same folder called “path\_im”. One “path\_im” is chosen at the start of each
project. By default, it is the folder “Figure\_Habby”, but the user can modify this folder in the window created by
ShowImageW(). The function for this is called “change\_folder”, also in ShowImageW(). The path\_im is written in
the xml project file. The different functions which create image read this path and send the figure created
to this folder. ShowImageW() reads all  figure of “.png” type in the” path\_im” folder and show the most recent
figure. The user can use the drop-down menu to choose to see another figure. The names of the figure are added to
the drop-down menu in the function update\_namefig. The function ``selectionchange'' changes the figure shown based
on the user action.
\index{change\_folder() (src\_GUI.Main\_windows\_1.ShowImageW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.ShowImageW.change_folder}}\pysiglinewithargsret{\sphinxbfcode{change\_folder}}{}{}
A function to change the folder where are stored the image (i.e., the path\_im)

\end{fulllineitems}

\index{init\_iu() (src\_GUI.Main\_windows\_1.ShowImageW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.ShowImageW.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
Used in the initialization.

\end{fulllineitems}

\index{selectionchange() (src\_GUI.Main\_windows\_1.ShowImageW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.ShowImageW.selectionchange}}\pysiglinewithargsret{\sphinxbfcode{selectionchange}}{\emph{i}}{}
A function to change the figure shown by ShowImageW()
:return:

\end{fulllineitems}

\index{send\_log (src\_GUI.Main\_windows\_1.ShowImageW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.ShowImageW.send_log}}\pysigline{\sphinxbfcode{send\_log}}
A PyQt signal used to write the log

\end{fulllineitems}

\index{update\_namefig() (src\_GUI.Main\_windows\_1.ShowImageW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.ShowImageW.update_namefig}}\pysiglinewithargsret{\sphinxbfcode{update\_namefig}}{}{}
This function add the different figure name to the drop-down list.

\end{fulllineitems}


\end{fulllineitems}

\index{WelcomeW (class in src\_GUI.Main\_windows\_1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.WelcomeW}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.Main\_windows\_1.}\sphinxbfcode{WelcomeW}}{\emph{path\_prj}, \emph{name\_prj}}{}
The class WeLcomeW()  creates the first tab of HABBY (the tab called “General”). This tab is there to create
a new project or to change the name, path, etc. of a project.
\index{change\_name (src\_GUI.Main\_windows\_1.WelcomeW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.WelcomeW.change_name}}\pysigline{\sphinxbfcode{change\_name}}
A signal to change the name of the project for MainWindows

\end{fulllineitems}

\index{init\_iu() (src\_GUI.Main\_windows\_1.WelcomeW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.WelcomeW.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
Used in the initialization of a new instance of the class WelcomeW()

\end{fulllineitems}

\index{new\_proj\_signal (src\_GUI.Main\_windows\_1.WelcomeW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.WelcomeW.new_proj_signal}}\pysigline{\sphinxbfcode{new\_proj\_signal}}
A PyQt signal used to open a new project

\end{fulllineitems}

\index{open\_example() (src\_GUI.Main\_windows\_1.WelcomeW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.WelcomeW.open_example}}\pysiglinewithargsret{\sphinxbfcode{open\_example}}{}{}
This function will be used to open a project example for HABBY, but the example is not prepared yet

\end{fulllineitems}

\index{open\_proj (src\_GUI.Main\_windows\_1.WelcomeW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.WelcomeW.open_proj}}\pysigline{\sphinxbfcode{open\_proj}}
A signal for MainWindows to open an exisiting project

\end{fulllineitems}

\index{save\_info\_signal (src\_GUI.Main\_windows\_1.WelcomeW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.WelcomeW.save_info_signal}}\pysigline{\sphinxbfcode{save\_info\_signal}}
A signal to change the user name and the description of the project

\end{fulllineitems}

\index{save\_signal (src\_GUI.Main\_windows\_1.WelcomeW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.WelcomeW.save_signal}}\pysigline{\sphinxbfcode{save\_signal}}
A PyQt signal used to save the project

\end{fulllineitems}

\index{send\_log (src\_GUI.Main\_windows\_1.WelcomeW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.WelcomeW.send_log}}\pysigline{\sphinxbfcode{send\_log}}
A PyQt signal used to write the log

\end{fulllineitems}

\index{setfolder2() (src\_GUI.Main\_windows\_1.WelcomeW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.Main_windows_1.WelcomeW.setfolder2}}\pysiglinewithargsret{\sphinxbfcode{setfolder2}}{}{}
This function is used by the user to select the folder where the xml project file will be located.
This is used in the case where the project exist already. A similar function is in the class CreateNewProject()
for the case where the project is new.

\end{fulllineitems}


\end{fulllineitems}



\section{Hydrological information - GUI}
\label{\detokenize{index:hydrological-information-gui}}
in src\_GUI/hydro\_GUI\_2.py

This python module contains the class which forms the hydrological tab in HABBY.
It contains the information for the graphical interface and make the link with the scripts
used for the hydrological calculations.
\phantomsection\label{\detokenize{index:module-src_GUI.hydro_GUI_2}}\index{src\_GUI.hydro\_GUI\_2 (module)}\index{FreeSpace (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.FreeSpace}}\pysigline{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{FreeSpace}}
Bases: \sphinxcode{PyQt5.QtWidgets.QWidget}

Simple class with empty space, just to have only Qwidget in the stack.

\sphinxstylestrong{Technical comment}

The idea of this class is that the user see a free space when it opens the “Hydro” Tab instead
of directly seeing one of the hydraulic model. The goal is to avoid the case where a user tries to load data before
selecting the real model. For example, if a user wants to load mascaret data and that an item is selected by
default in the stack of classes related to hydrology (such as HEC-RAS1D), it might be logical for the user to try
to load masacret data using the HEC-RAS class. Because of the FreeSpace class, he actually has to select
the model he wants to load.

\end{fulllineitems}

\index{HEC\_RAS1D (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HEC_RAS1D}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{HEC\_RAS1D}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: {\hyperref[\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW}]{\sphinxcrossref{\sphinxcode{src\_GUI.hydro\_GUI\_2.SubHydroW}}}}

The class Hec\_ras 1D is there to manage the link between the graphical interface and the functions in
src/hec\_ras06.py which loads the hec-ras data in 1D. The class HEC\_RAS1D inherits from SubHydroW() so it have all
the methods and the variables from the class ubHydroW(). The class hec-ras 1D is added to the self.stack of Hydro2W().
So the class Hec-Ras 1D is called when the user is on the hydrological tab and click on hec-ras1D as hydrological
model.
\index{init\_iu() (src\_GUI.hydro\_GUI\_2.HEC\_RAS1D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HEC_RAS1D.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
This function is called by \_\_init\_\_() durring the initialization.

\sphinxstylestrong{Technical comment}

The self.attributexml variable is the name of the attribute in the xml file. To load a hec-ras file, one needs
to give to HABBY one file containing the geometry data and one file containing the simulation result. The name
and path to  these two file are saved in the xml project file under the attribute given in
the self.attributexml variable.

The variable self.extension is a list of list of the accepted file type. The first list is for the file
with geometry data. The second list is the extension of the files containing the simulation results.

Using the function self.was\_model\_loaded\_before, HABBY write the name of the hec-ras files which were loaded
in HABBY in the same project before.

Hec-Ras is a 1.5D model and so HABBY create a 2D grid based on the 1.5D input. The user can choose the interpolation
type and the number of extra profile. If the interpolation type is “interpolation by block”, the number of extra
profile will always be one. See manage\_grid.py for more information on how to create a grid.

We add a QLineEdit with the proposed name for the created hdf5 file. The user can modified this name if wished so.

\end{fulllineitems}

\index{load\_hec\_ras\_gui() (src\_GUI.hydro\_GUI\_2.HEC\_RAS1D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HEC_RAS1D.load_hec_ras_gui}}\pysiglinewithargsret{\sphinxbfcode{load\_hec\_ras\_gui}}{}{}
A function to execute the loading and saving of the HEC-ras file using Hec\_ras.py

\sphinxstylestrong{Technical comments}

This function is called when the user press on the button self.load\_b. It is the function which really
calls the load function for hec\_ras. First, it updates the xml project file. It adds the name of the new file
to xml project file under the attribute indicated by self.attributexml. It also gets the path\_im by reading the
path\_im in the xml project file. If we want to create the 1D figure, the option show\_all\_fig
should be selected in the figure option. It also manages the log as explained in the section about the log.
It loads the hec-ras data as explained in the section on hec\_ras06.py and creates the grid as explained
in the manage\_grid.py based on the interpolation type wished by the user (linear, nearest neighbor or by block).
The variable self.name\_hdf5() is taken from the GUI.

\end{fulllineitems}

\index{propose\_next\_file() (src\_GUI.hydro\_GUI\_2.HEC\_RAS1D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HEC_RAS1D.propose_next_file}}\pysiglinewithargsret{\sphinxbfcode{propose\_next\_file}}{}{}
This function proposes the second hec-ras file when the first is selected.  Indeed, to load hec-ras, we need
one file with the geometry data and one file with the simulation results. If the user selects a file, this
function looks if a file with the same name but with the extension of the other file type exists in the
selected folder. Careful, when using hec-ras more than one extension type is possible.

\end{fulllineitems}


\end{fulllineitems}

\index{HEC\_RAS2D (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HEC_RAS2D}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{HEC\_RAS2D}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: {\hyperref[\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW}]{\sphinxcrossref{\sphinxcode{src\_GUI.hydro\_GUI\_2.SubHydroW}}}}

The class hec\_RAS2D is there to manage the link between the graphical interface and the functions in src/hec\_ras2D.py
which loads the hec\_ras2D data in 2D. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW(). It is very similar to RUBAR2D class and it has the same problem about node/cell
which will need to be corrected.
\index{init\_iu() (src\_GUI.hydro\_GUI\_2.HEC\_RAS2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HEC_RAS2D.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
This method is used to by \_\_init\_\_() during the initialization.

\end{fulllineitems}

\index{load\_hec\_2d\_gui() (src\_GUI.hydro\_GUI\_2.HEC\_RAS2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HEC_RAS2D.load_hec_2d_gui}}\pysiglinewithargsret{\sphinxbfcode{load\_hec\_2d\_gui}}{}{}
This function calls the function which load hecras 2d and save the names of file in the project file.
It is similar to the function to load\_rubar2D. It open a second thread to avoid freezing the GUI.

When this function starts, it also starts a timer. Every three seconds, the timer run the function send\_data()
which is the class SubHydroW(). This function checks if the thread is finished and, it is finished, manage
figure and errors.

\end{fulllineitems}


\end{fulllineitems}

\index{HabbyHdf5 (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HabbyHdf5}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{HabbyHdf5}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: {\hyperref[\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW}]{\sphinxcrossref{\sphinxcode{src\_GUI.hydro\_GUI\_2.SubHydroW}}}}

This class is used to load hdf5 hydrological file done by HABBY on another project. If the project was lost,
it is there possible to just add a along hdf5 file to the current project without having to pass to the original
hydrological files.
\index{add\_new\_hdf5\_to\_xml() (src\_GUI.hydro\_GUI\_2.HabbyHdf5 method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HabbyHdf5.add_new_hdf5_to_xml}}\pysiglinewithargsret{\sphinxbfcode{add\_new\_hdf5\_to\_xml}}{}{}
This function is used to add the new hdf5 to the xml project file

\end{fulllineitems}

\index{add\_two\_hdf5() (src\_GUI.hydro\_GUI\_2.HabbyHdf5 method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HabbyHdf5.add_two_hdf5}}\pysiglinewithargsret{\sphinxbfcode{add\_two\_hdf5}}{\emph{merge}}{}
This functions is used to merge together two hydro/merge hdf5. For tis, it call the function `addition\_hdf5'
from load\_hdf5.py
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{merge} -- A boolean which say if we load an hydrological or a merge file

\end{description}\end{quote}

\end{fulllineitems}

\index{drop\_merge (src\_GUI.hydro\_GUI\_2.HabbyHdf5 attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HabbyHdf5.drop_merge}}\pysigline{\sphinxbfcode{drop\_merge}}
A pyqtsignal which signal that new merge data is ready as it also possible to import merge data here.

\end{fulllineitems}

\index{get\_new\_hydro\_hdf5() (src\_GUI.hydro\_GUI\_2.HabbyHdf5 method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HabbyHdf5.get_new_hydro_hdf5}}\pysiglinewithargsret{\sphinxbfcode{get\_new\_hydro\_hdf5}}{}{}
This is a function which allows the user to select an hdf5 file containing the hydrological
data from a previous project and add it to the current project. It modifies the xml project file and test
that the data is in correct form by loading it. The hdf5 should have the same form than the hydrological data
created by HABBY in the method save\_hdf5 of the class SubHydroW.

\end{fulllineitems}

\index{get\_new\_merge\_hdf5() (src\_GUI.hydro\_GUI\_2.HabbyHdf5 method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HabbyHdf5.get_new_merge_hdf5}}\pysiglinewithargsret{\sphinxbfcode{get\_new\_merge\_hdf5}}{}{}
This is a function which allows the user to select an hdf5 file containing the hydrological and the substrate
data from a previous project and add it to the current project. It modifies the xml project file and test
that the data is in correct form by loading it. The hdf5 should have the same form than the merge data
created by HABBY in the method save\_hdf5 of the class SubHydroW.

\end{fulllineitems}

\index{init\_iu() (src\_GUI.hydro\_GUI\_2.HabbyHdf5 method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.HabbyHdf5.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
Used in the initialization by \_\_init\_\_()

\end{fulllineitems}


\end{fulllineitems}

\index{Hydro2W (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Hydro2W}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{Hydro2W}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: \sphinxcode{PyQt5.QtWidgets.QWidget}

The class Hydro2W is the second tab of HABBY. It is the class containing all the classes/Widgets which are used
to load the hydrological data.

List of model supported by Hydro2W:
files separetly. However, sometime the file was not found
*   Telemac (2D)
*   Hec-Ras (1.5D et 2D)
*   Rubar BE et 2(1D et 2D)
*   Mascaret (1D)
*   River2D (2D)

\sphinxstylestrong{Technical comments}

To call the different classes used to load the hydrological data, the user selects the name of the hydrological
model from a QComboBox call self.mod. The method ‘selection\_change” calls the class that the user chooses in
self.mod. All the classes used to load the
hydrological data are created when HABBY starts and are kept in a stack called self.stack. The function
selection\_change() just changes the selected item of the stack based on the user choice on self.mod.

Any new hydrological model should also be added to the stack and to the list of models contained in self.mod
(name of the list: self.name\_model).

In addition to the stack containing the hydrological information, hydro2W has two buttons. One button open
a QMessageBox() which give information about the models, using the method “give\_info\_model”.  It is useful if a
special type of file is needed to load the data from a model or to give extra information about one hydrological
model. The text which is shown on the QMessageBox is given in one text file for each model.
These text file are contained in the folder ‘model\_hydro” which is in the HABBY folder. For the moment,
there are models for which no text files have been prepared. The text file should have the following format:
\begin{itemize}
\item {} 
A short sentence with general info

\item {} 
The keyword:  MORE INFO

\item {} 
All other infomation which are needed.

\end{itemize}

The second button allows the user to load an hdf5 file containing hydrological data from another project.
As long as the hdf5 is in the right format, it does not matter from which hydrological model it was loaded from
or even if this hydrological model is supported by HABBY.
\index{give\_info\_model() (src\_GUI.hydro\_GUI\_2.Hydro2W method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Hydro2W.give_info_model}}\pysiglinewithargsret{\sphinxbfcode{give\_info\_model}}{}{}
A function to show extra information about each hydrological model.
The information should be in a text file with the same name as the model in the model\_hydo folder.
General info goes as the start of the text file. If the text is too long, add the keyword ``MORE INFO''
and add the longer text afterwards. The message box will show the supplementary information only if the user
asks for detailed information.

This functins is not used anymore as it was long to maintain it and not very useful to the user. But I let it
here is case, it becomes necessary again

\end{fulllineitems}

\index{init\_iu() (src\_GUI.hydro\_GUI\_2.Hydro2W method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Hydro2W.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
Used in the initialization by \_\_init\_\_()

\end{fulllineitems}

\index{selectionchange() (src\_GUI.hydro\_GUI\_2.Hydro2W method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Hydro2W.selectionchange}}\pysiglinewithargsret{\sphinxbfcode{selectionchange}}{\emph{i}}{}
Change the shown widget which represents each hydrological model (all widget are in a stack)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{i} -- the number of the model (0=no model, 1=hecras1d, 2= hecras2D,...)

\end{description}\end{quote}

\end{fulllineitems}

\index{send\_log (src\_GUI.hydro\_GUI\_2.Hydro2W attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Hydro2W.send_log}}\pysigline{\sphinxbfcode{send\_log}}
A PyQt signal to send the log.

\end{fulllineitems}


\end{fulllineitems}

\index{LAMMI (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.LAMMI}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{LAMMI}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: {\hyperref[\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW}]{\sphinxcrossref{\sphinxcode{src\_GUI.hydro\_GUI\_2.SubHydroW}}}}

The class LAMMI is there to manage the link between the graphical interface and the functions in src/lammi.py
which loads the lammi data. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW().
\index{drop\_merge (src\_GUI.hydro\_GUI\_2.LAMMI attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.LAMMI.drop_merge}}\pysigline{\sphinxbfcode{drop\_merge}}
A pyqtsignal which signal that hydro data from lammi is ready. The signal is for the bioinfo\_tab and is collected
by MainWindows1.py. Data from lammi contains substrate data.

\end{fulllineitems}

\index{init\_iu() (src\_GUI.hydro\_GUI\_2.LAMMI method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.LAMMI.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
Used by \_\_init\_\_() during the initialization.

\end{fulllineitems}

\index{load\_lammi\_gui() (src\_GUI.hydro\_GUI\_2.LAMMI method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.LAMMI.load_lammi_gui}}\pysiglinewithargsret{\sphinxbfcode{load\_lammi\_gui}}{}{}
This function loads the lammi data, save the text file to the xml project file and create the grid

\end{fulllineitems}

\index{show\_dialog\_lammi() (src\_GUI.hydro\_GUI\_2.LAMMI method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.LAMMI.show_dialog_lammi}}\pysiglinewithargsret{\sphinxbfcode{show\_dialog\_lammi}}{\emph{i=0}}{}
When using lammi data, the user selects a directory and not a file. Hence, we need to modify the ususal
show\_dialog function. Hence, function the show\_dilaog\_lammi() obtain the directory chosen by the user.
This method open a dialog so that the user select a directory. The files are NOT loaded here. The name and path
to the files are saved in an attribute.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{i} -- If i ==0, we obtain the Entree dirctory, if i == 1, the Resu directory.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Mascaret (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Mascaret}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{Mascaret}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: {\hyperref[\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW}]{\sphinxcrossref{\sphinxcode{src\_GUI.hydro\_GUI\_2.SubHydroW}}}}

The class Mascaret is there to manage the link between the graphical interface and the functions in src/mascaret.py
which loads the Masacret data in 1D. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW(). It is similar to the HEC-Ras1D class (see this class for more information). However, mascaret is 1D model, so the loading
of mascaret has one additional step compared to the hec-ras load: The velocity must be distributed along the
profile. For this, the load\_masacret\_gui call the self.distrbute \_velocity function. In addition, it prepares
the manning value which is necessary to distribute the velocity. The user has two choices to input the manning
value. The easiest one is just to give a value constant for the whole river. In the second choice, the user loads
a text file with a serie of lines with the following info: p, dist, n where p is the profile number
(starting at zero), dist is the distance in meter along the profile and n in the manning value (see the method
load\_manning\_text of the class SubHydroW for more information)
\index{init\_iu() (src\_GUI.hydro\_GUI\_2.Mascaret method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Mascaret.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
Used in the initialization by \_\_init\_\_()

\end{fulllineitems}

\index{load\_mascaret\_gui() (src\_GUI.hydro\_GUI\_2.Mascaret method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Mascaret.load_mascaret_gui}}\pysiglinewithargsret{\sphinxbfcode{load\_mascaret\_gui}}{}{}
The function is used to load the mascaret data, calling the function contained in the script mascaret.py.
It also create a 2D grid from the 1D data and distribute the velocity.
All of theses tasks are done on a second thread to avoid freezing the GUI.

\end{fulllineitems}

\index{propose\_next\_file() (src\_GUI.hydro\_GUI\_2.Mascaret method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Mascaret.propose_next_file}}\pysiglinewithargsret{\sphinxbfcode{propose\_next\_file}}{}{}
This function proposes the two other mascaret when the first is selected. If the user selects the first file,
this function looks if a file with the same name but with the extension of the other file types exists in the
selected folder.

\end{fulllineitems}


\end{fulllineitems}

\index{River2D (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.River2D}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{River2D}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: {\hyperref[\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW}]{\sphinxcrossref{\sphinxcode{src\_GUI.hydro\_GUI\_2.SubHydroW}}}}

The class River2D t is there to manage the link between the graphical interface and the functions in src/river2D.py
which loads the River2D data in 2D.

\sphinxstylestrong{Technical comments}
\begin{quote}

The class River2D inherits from SubHydroW() so it have all the methods and the variables from the class SubHydroW().
It is similar generally to the hec-ras2D class. However, the hydrological model River2D create one file per time step.
Hence, it is necessary to have a way to load all the files automatically. Loading one file after one file would be
annoying. There are four functions to manage the large number of file:
\begin{itemize}
\item {} 
add\_all\_file: find all files in a folder selected by the user.

\item {} 
add\_file\_river2D: add just one selected file

\item {} 
Remove\_all\_file: remove all selected files

\item {} 
Remove\_file: remove one selected file

\end{itemize}

None of this four functions load the data, it just add the name and path of the files to be loaded to
self.namefile and self.pathfile. Generally, in HABBY, we load hydrological data in two steps: a) select the files,
b) load the data. For river2D, the step b) is done by the function load\_river2d\_gui().
This function is similar to the one used by Rubar2D. It has the same problem about the grid which
is identical for all time steps and which contains all reaches together. So a temporary correction was applied.
Data in River2D is given on the nodes as in HABBY.
\end{quote}
\index{add\_all\_file() (src\_GUI.hydro\_GUI\_2.River2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.River2D.add_all_file}}\pysiglinewithargsret{\sphinxbfcode{add\_all\_file}}{}{}
The function finds all .cdg file in one directory to add there names to the list of files to be loaded

\end{fulllineitems}

\index{add\_file\_river2d() (src\_GUI.hydro\_GUI\_2.River2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.River2D.add_file_river2d}}\pysiglinewithargsret{\sphinxbfcode{add\_file\_river2d}}{}{}
This function is used to add one file to the list of file to be loaded.
It let the user select one or more than one file, prepare some data for it and update the QWidgetList with
the name of the file containted in the variable self.namefile.

We can not call show\_dialog() direclty here as the user can select more than one file

\end{fulllineitems}

\index{add\_file\_to\_list() (src\_GUI.hydro\_GUI\_2.River2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.River2D.add_file_to_list}}\pysiglinewithargsret{\sphinxbfcode{add\_file\_to\_list}}{}{}
This function to add all file contained in self.namefile to the QWidgetlist. Called by add\_file\_river2D and
add\_all\_file.

\end{fulllineitems}

\index{init\_iu() (src\_GUI.hydro\_GUI\_2.River2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.River2D.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
used by \_\_init\_\_ in the initialization

\end{fulllineitems}

\index{load\_river2d\_gui() (src\_GUI.hydro\_GUI\_2.River2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.River2D.load_river2d_gui}}\pysiglinewithargsret{\sphinxbfcode{load\_river2d\_gui}}{}{}
This function is used to load the river 2d data. It use a second thread to avoid freezing the GUI

\end{fulllineitems}

\index{remove\_all\_file() (src\_GUI.hydro\_GUI\_2.River2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.River2D.remove_all_file}}\pysiglinewithargsret{\sphinxbfcode{remove\_all\_file}}{}{}
This function removes all files from the list of files to be loaded and from the QlistWidget.

\end{fulllineitems}

\index{remove\_file() (src\_GUI.hydro\_GUI\_2.River2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.River2D.remove_file}}\pysiglinewithargsret{\sphinxbfcode{remove\_file}}{}{}
This is small function to remove one or more .cdg file from the list of files to be loaded and from
the QlistWidget.

\sphinxstylestrong{Technical Comments}

The function selectedIndexes does not return an int but an object called QModelIndex. We should start removing
object from the end of the list to avoid problem. However, it is not possible to sort QModelIndex. Hence,
It is necessary to use the row() function to get the index as int.

\end{fulllineitems}


\end{fulllineitems}

\index{Rubar1D (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Rubar1D}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{Rubar1D}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: {\hyperref[\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW}]{\sphinxcrossref{\sphinxcode{src\_GUI.hydro\_GUI\_2.SubHydroW}}}}

The class Rubar1D is there to manage the link between the graphical interface and the functions in src/rubar.py
which loads the Rubar1D data in 1D. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW(). It is very similar to Mascaret class.
\index{init\_iu() (src\_GUI.hydro\_GUI\_2.Rubar1D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Rubar1D.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
Used in the initalizatin by \_\_init\_\_()

\end{fulllineitems}

\index{load\_rubar1d() (src\_GUI.hydro\_GUI\_2.Rubar1D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Rubar1D.load_rubar1d}}\pysiglinewithargsret{\sphinxbfcode{load\_rubar1d}}{}{}
A function to execute the loading and saving the the rubar file using rubar.py. After loading the data,
it distribute the velocity along the profiles by calling self.distribute\_velocity() and it created the 2D grid
by calling the method self.grid\_and\_interpo.

\end{fulllineitems}

\index{propose\_next\_file() (src\_GUI.hydro\_GUI\_2.Rubar1D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Rubar1D.propose_next_file}}\pysiglinewithargsret{\sphinxbfcode{propose\_next\_file}}{}{}
This function proposes the other rubar file when the first is selected. If the user selects the first file,
this function looks if a file of the form profil.name exist

\end{fulllineitems}


\end{fulllineitems}

\index{Rubar2D (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Rubar2D}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{Rubar2D}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: {\hyperref[\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW}]{\sphinxcrossref{\sphinxcode{src\_GUI.hydro\_GUI\_2.SubHydroW}}}}

The class Rubar2D is there to manage the link between the graphical interface and the functions in src/rubar.py
which loads the RUBAR data in 2D. It inherits from SubHydroW() so it have all the methods and the variables from
the class SubHydroW(). The form of the function is similar to hec-ras, but it does not have the part about the grid
creation as we look here as the data created in 2D by RUBAR.
\index{init\_iu() (src\_GUI.hydro\_GUI\_2.Rubar2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Rubar2D.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
used by \_\_\_init\_\_() in the initialization.

\end{fulllineitems}

\index{load\_rubar() (src\_GUI.hydro\_GUI\_2.Rubar2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Rubar2D.load_rubar}}\pysiglinewithargsret{\sphinxbfcode{load\_rubar}}{}{}
A function to execture the loading and saving the the rubar file using rubar.py. It is similar to the
load\_hec\_ras\_gui() function. Obviously, it calls rubar and not hec\_ras this time. A small difference is that
the rubar2D outputs are only given in one grid for all time steps and all reaches. Moreover, it is
necessary to cut the grid for each time step as a function of the wetted area and maybe to separate the
grid by reaches.  Another problem is that the data of Rubar2D is given on the cells of the grid and not the
nodes. So we use linear interpolation to correct for this.

A second thread is used to avoid ``freezing'' the GUI.

\end{fulllineitems}

\index{propose\_next\_file() (src\_GUI.hydro\_GUI\_2.Rubar2D method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.Rubar2D.propose_next_file}}\pysiglinewithargsret{\sphinxbfcode{propose\_next\_file}}{}{}
This function proposes the second RUBAR file when the first is selected.  Indeed, to load rubar, we need
one file with the geometry data and one file with the simulation results. If the user selects a file, this
function looks if a file with the same name but with the extension of the other file type exists in the
selected folder.

\end{fulllineitems}


\end{fulllineitems}

\index{SubHydroW (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{SubHydroW}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: \sphinxcode{PyQt5.QtWidgets.QWidget}

SubHydroW is class which is the parent of the classes which can be used to open the hydrological models. This class
is a bit special. It is not called directly by HABBY but by the classes which load the hydrological data and which
inherits from this class. The advantage of this architecture is that all the children classes can use the methods
written in SubHydroW(). Indeed, all the children classes load hydrological data and therefore they are similar and
can use similar functions.

In other word, there are MainWindows() which provides the windows around the widget and Hydro2W which provide the
widget for the hydrological Tab and one class by hydrological model to really load the model. The latter classes
have various methods in common, so they inherit from SubHydroW, this class.
\index{create\_image() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.create_image}}\pysiglinewithargsret{\sphinxbfcode{create\_image}}{\emph{save\_fig=True}, \emph{show\_info=False}}{}
This function is used to create the images related to the grid and the hydrology. It is called by send\_data
and recreate\_image. This function exists because the two functions above have similar needs and that we do not
copy too much codes. It can also show basic information about the data in the log windows and in the log file
if the variable show\_info is True.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{save\_fig} -- a boolean to save the figure or not

\item {} 
\sphinxstyleliteralstrong{show\_info} -- If True, basic information about the data will be displayed into the log window.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{dis\_enable\_nb\_profile() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.dis_enable_nb_profile}}\pysiglinewithargsret{\sphinxbfcode{dis\_enable\_nb\_profile}}{}{}
This function enable and disable the QLineEdit where the user gives the number of additional profile needed to
create the gird and the related QLabel. If the user choose the interpolation by bloc, the QLineEdit will be
disabled. If it chooses linear or nearest neighbour interpolation, it will be enabled. Careful, this function
only works with 1D and 1.5D model.

\end{fulllineitems}

\index{drop\_hydro (src\_GUI.hydro\_GUI\_2.SubHydroW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.drop_hydro}}\pysigline{\sphinxbfcode{drop\_hydro}}
A PyQtsignal signal for the substrate tab so it can account for the new hydrological info.

\end{fulllineitems}

\index{find\_path\_hdf5() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.find_path_hdf5}}\pysiglinewithargsret{\sphinxbfcode{find\_path\_hdf5}}{}{}
A function to find the path where to save the hdf5 file. Careful a simialar one is in estimhab\_GUI.py. By default,
path\_hdf5 is in the project folder in the folder `fichier\_hdf5'.

\end{fulllineitems}

\index{find\_path\_im() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.find_path_im}}\pysiglinewithargsret{\sphinxbfcode{find\_path\_im}}{}{}
A function to find the path where to save the figues. Careful a simialar one is in estimhab\_GUI.py. By default,
path\_im is in the project folder in the folder `figure'.

This is practical to have in a function form as it should be called repeatably (in case the project have been
changed since the last start of HABBY).

\end{fulllineitems}

\index{find\_path\_input() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.find_path_input}}\pysiglinewithargsret{\sphinxbfcode{find\_path\_input}}{}{}
A function to find the path where to save the input file. Careful a simialar one is in estimhab\_GUI.py. By default,
path\_input indicates the folder `input' in the project folder.

\end{fulllineitems}

\index{gethdf5\_name\_gui() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.gethdf5_name_gui}}\pysiglinewithargsret{\sphinxbfcode{gethdf5\_name\_gui}}{}{}
This function get the name of the hdf5 file for the hydrological and write down in the QLineEdit on the GUI.
It is possible to have more than one hdf5 file for a model type. For example, we could have created two hdf5
based on hec-ras output. The default here is to write the last model loaded. It is the same default behaviour
than for the function was\_model\_loaded\_before(). To keep the coherence between the filename and hdf5 name,
a change in this behaviour should be reflected in both function.

This function calls the function get\_hdf5\_name in the load\_hdf5.py file

\end{fulllineitems}

\index{load\_manning\_text() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.load_manning_text}}\pysiglinewithargsret{\sphinxbfcode{load\_manning\_text}}{}{}
This function loads the manning data in case where manning number is not simply a constant. In this case, the manning
parameter is given in a .txt file.
The manning parameter used by 1D model such as mascaret or Rubar BE to distribute velocity along the profiles.
The format of the txt file is ``p, dist, n'' where  p is the profile number (start at zero), dist is the distance
along the profile in meter and n is the manning value (in SI unit). One point per line so something like:

0, 150, 0.035

0, 200, 0.025

1, 120, 0.035, etc.

White space is neglected and a line starting with the character \# is also neglected.

A very similar function to this ones exists in func\_for\_cmd. It is used to so the same thing but called
from the cmd. Changes should be copied in both functions if necessary.

\end{fulllineitems}

\index{read\_attribute\_xml() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.read_attribute_xml}}\pysiglinewithargsret{\sphinxbfcode{read\_attribute\_xml}}{\emph{att\_here}}{}
A function to read the text of an attribute in the xml project file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{att\_here} -- the attribute name (string).

\end{description}\end{quote}

\end{fulllineitems}

\index{recreate\_image() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.recreate_image}}\pysiglinewithargsret{\sphinxbfcode{recreate\_image}}{}{}
This function is used to recreate the images related to the grid and the hydrology. We do not call create\_image
directly as we might add other command here.

\end{fulllineitems}

\index{save\_xml() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.save_xml}}\pysiglinewithargsret{\sphinxbfcode{save\_xml}}{\emph{i=0}, \emph{append\_name=False}}{}
A function to save the loaded data in the xml file.

This function adds the name and the path of the newly chosen hydrological data to the xml project file. First,
it open the xml project file (and send an error if the project is not saved, or if it cannot find the project
file). Then, it opens the xml file and add the path and name of the file to this xml file. If the model data was
already loaded, it adds the new name without erasing the old name IF the switch append\_name is True. Otherwise,
it erase the old name and replace it by a new name. The variable “i” has the same role than in show\_dialog.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{i} -- a int for the case where there is more than one file to load

\item {} 
\sphinxstyleliteralstrong{append\_name} -- A boolean. If True, the name found will be append to the existing name in the xml file,
instead of remplacing the old name by the new name.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{send\_data() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.send_data}}\pysiglinewithargsret{\sphinxbfcode{send\_data}}{}{}
This function is call regularly by the methods which have a second thread (so moslty the function
to load the hydrological data). To call this functin regularly, the variable self.timer of QTimer type is used.
The variable self.timer is connected to this function in the initiation of SubHydroW() and so in the initation
of all class which inherits from SubHydroW().

This function just wait while the thread is alive. When it has terminated, it creates the figure and the error
messages.

\end{fulllineitems}

\index{send\_err\_log() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.send_err_log}}\pysiglinewithargsret{\sphinxbfcode{send\_err\_log}}{\emph{check\_ok=False}}{}
This function sends the errors and the warnings to the logs.
The stdout was redirected to self.mystdout before calling this function. It only sends the hundred first errors
to avoid freezing the GUI. A similar function exists in estimhab\_GUI.py. Correct both if necessary.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{check\_ok} -- This is an optional paramter. If True, it checks if the function returns any error

\end{description}\end{quote}

\end{fulllineitems}

\index{send\_log (src\_GUI.hydro\_GUI\_2.SubHydroW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.send_log}}\pysigline{\sphinxbfcode{send\_log}}
A Pyqtsignal to write the log.

\end{fulllineitems}

\index{show\_dialog() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.show_dialog}}\pysiglinewithargsret{\sphinxbfcode{show\_dialog}}{\emph{i=0}}{}
A function to obtain the name of the file chosen by the user. This method open a dialog so that the user select
a file. This file is NOT loaded here. The name and path to this file is saved in an attribute. This attribute
is then used to loaded the file in other function, which are different for each children class. Based on the
name of the chosen file, a name is proposed for the hdf5 file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{i} -- a int for the case where there is more than one file to load

\end{description}\end{quote}

\end{fulllineitems}

\index{show\_fig (src\_GUI.hydro\_GUI\_2.SubHydroW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.show_fig}}\pysigline{\sphinxbfcode{show\_fig}}
A PyQtsignal to show the figure.

\end{fulllineitems}

\index{was\_model\_loaded\_before() (src\_GUI.hydro\_GUI\_2.SubHydroW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW.was_model_loaded_before}}\pysiglinewithargsret{\sphinxbfcode{was\_model\_loaded\_before}}{\emph{i=0}, \emph{many\_file=False}}{}
A function to test if the model loaded before. If yes, it updates the attibutes anf the widgets of the
hydrological model on consideration.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{i} -- an int used in cases where there is more than one file to load (geometry and output for example)

\item {} 
\sphinxstyleliteralstrong{many\_file} -- A bollean. If true this function will load more than one file, separated by `,'. If False,
it will only loads the file of one model (see the comment below).

\end{itemize}

\end{description}\end{quote}

\sphinxstylestrong{Technical comment}

This method opens the xml project file and look in the attribute of the xml file to see if data from the
hydrological model have been loaded before. If yes, the name of the data is written on the GUI of HABBY in the
Widget related to the hydrological model. Now, there are often more than one data loaded. This method allows
choosing what should be written. There are two different case to be separated: a) We have loaded two different
models (like two rivers modeled by HEC-RAS) b) One model type needs two data file (like HEC-RAS would need a
geometry and output data). For the case a), the default is to write only the last model loaded. If this
default behaviour is changed, the behaviour of gethdf5\_name\_GUI should also be changed. If we wish to
write all data, the switch “many\_file” should be True. This switch is also useful for the river2D model, because
this model create one output file per time step. For the case b), the argument “i”(which is an int) allows us to
choose which data type should be shown. “i” is in the order of the self.attributexml variable. The definition of
this order is given in the definition of the class of each hydrological model.

\end{fulllineitems}


\end{fulllineitems}

\index{SubstrateW (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{SubstrateW}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: {\hyperref[\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW}]{\sphinxcrossref{\sphinxcode{src\_GUI.hydro\_GUI\_2.SubHydroW}}}}

This is the widget used to load the substrate. It is practical to re-use some of the method from SubHydroW.
So this class inherit from SubHydroW.
\index{add\_const\_widgets() (src\_GUI.hydro\_GUI\_2.SubstrateW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.add_const_widgets}}\pysiglinewithargsret{\sphinxbfcode{add\_const\_widgets}}{}{}
This function shows the widgets realted to the loading of constatns subtrate

\end{fulllineitems}

\index{add\_file\_widgets() (src\_GUI.hydro\_GUI\_2.SubstrateW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.add_file_widgets}}\pysiglinewithargsret{\sphinxbfcode{add\_file\_widgets}}{}{}
This functions shows the widgets

\end{fulllineitems}

\index{btnstate() (src\_GUI.hydro\_GUI\_2.SubstrateW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.btnstate}}\pysiglinewithargsret{\sphinxbfcode{btnstate}}{\emph{rb\_sel}, \emph{rb\_del}}{}
This function is used to select and deslect radiobutton
:param rb\_sel: the radio button which was just selected
:param rb\_del: the radio button which should be deselected

\end{fulllineitems}

\index{drop\_merge (src\_GUI.hydro\_GUI\_2.SubstrateW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.drop_merge}}\pysigline{\sphinxbfcode{drop\_merge}}
A pyqtsignal which signal that merged hydro data is ready. The signal is for the bioinfo\_tab and is collected
by MainWindows1.py.

\end{fulllineitems}

\index{get\_att\_name() (src\_GUI.hydro\_GUI\_2.SubstrateW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.get_att_name}}\pysiglinewithargsret{\sphinxbfcode{get\_att\_name}}{}{}
A function to get the attribute name of the shapefile which contains the substrate data. it is given by the user
in the GUI.

\end{fulllineitems}

\index{get\_attribute\_from\_shp() (src\_GUI.hydro\_GUI\_2.SubstrateW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.get_attribute_from_shp}}\pysiglinewithargsret{\sphinxbfcode{get\_attribute\_from\_shp}}{}{}
This function opens a shapefile and obtain the attribute. It then update the GUI
to reflect this and also update the label as needed.

\end{fulllineitems}

\index{init\_iu() (src\_GUI.hydro\_GUI\_2.SubstrateW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
Used in the initialization by \_\_init\_\_().

\end{fulllineitems}

\index{load\_sub\_gui() (src\_GUI.hydro\_GUI\_2.SubstrateW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.load_sub_gui}}\pysiglinewithargsret{\sphinxbfcode{load\_sub\_gui}}{\emph{const\_sub=False}}{}
This function is used to load the substrate data. The substrate data can be in two forms: a) in the form of a shp
file form ArGIS (or another GIS-program). b) in the form of a text file (x,y, substrate data line by line).
Generally this function has some similarities to the functions used to load the hydrological data and it re-uses
some of the methods developed for them.

It is possible to have a constant substrate if const\_sub= True. In this
case, an hdf5 is created with only the default value marked. This form of hdf5 file is then managed by the merge
function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{const\_sub} -- If True, a constant substrate is being loaded. Usually it is set to False.

\end{description}\end{quote}

\end{fulllineitems}

\index{log\_txt() (src\_GUI.hydro\_GUI\_2.SubstrateW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.log_txt}}\pysiglinewithargsret{\sphinxbfcode{log\_txt}}{\emph{code\_type}}{}
This function gives the log for the substrate in text form. this is in a function because it is used twice in
the function load\_sub\_gui()

\end{fulllineitems}

\index{name\_last\_merge() (src\_GUI.hydro\_GUI\_2.SubstrateW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.name_last_merge}}\pysiglinewithargsret{\sphinxbfcode{name\_last\_merge}}{}{}
This function opens the xml project file to find the name of the last hdf5 merge file and to add it
to the GUI on the QLabel self.lm2. It also add a QToolTip with the name of substrate and hydraulic files used
to create this merge file. If there is no file found, this function do nothing.

\end{fulllineitems}

\index{recreate\_image\_sub() (src\_GUI.hydro\_GUI\_2.SubstrateW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.recreate_image_sub}}\pysiglinewithargsret{\sphinxbfcode{recreate\_image\_sub}}{\emph{save\_fig=False}}{}
This function is used to recreate the image linked with the subtrate. So this is not the figure for the ``merge''
part, but only to show the substrat alone.
\begin{quote}\begin{description}
\item[{Param}] \leavevmode
save\_fig: A boolean to save or not the figure

\end{description}\end{quote}

\end{fulllineitems}

\index{send\_merge\_grid() (src\_GUI.hydro\_GUI\_2.SubstrateW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.send_merge_grid}}\pysiglinewithargsret{\sphinxbfcode{send\_merge\_grid}}{}{}
This function calls the function merge grid in substrate.py. The goal is to have the substrate and hydrological
data on the same grid. Hence, the hydrological grid will need to be cut to the form of the substrate grid.

This function can be slow so it call on a second thread.

\end{fulllineitems}

\index{update\_sub\_hdf5\_name() (src\_GUI.hydro\_GUI\_2.SubstrateW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.SubstrateW.update_sub_hdf5_name}}\pysiglinewithargsret{\sphinxbfcode{update\_sub\_hdf5\_name}}{}{}
This function update the QComBox on substrate data which is on the substrate tab. The similiar function
for hydrology is in Main\_Windows\_1.py as it is more practical to have it there to collect all the signals.

\end{fulllineitems}


\end{fulllineitems}

\index{TELEMAC (class in src\_GUI.hydro\_GUI\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.TELEMAC}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.hydro\_GUI\_2.}\sphinxbfcode{TELEMAC}}{\emph{path\_prj}, \emph{name\_prj}}{}
Bases: {\hyperref[\detokenize{index:src_GUI.hydro_GUI_2.SubHydroW}]{\sphinxcrossref{\sphinxcode{src\_GUI.hydro\_GUI\_2.SubHydroW}}}}

The class Telemac is there to manage the link between the graphical interface and the functions in src/selafin\_habby1.py
which loads the Telemac data in 2D. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW(). It is very similar to RUBAR2D class, but data from Telemac is on the node as in HABBY.
\index{init\_iu() (src\_GUI.hydro\_GUI\_2.TELEMAC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.TELEMAC.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
Used by \_\_init\_\_() during the initialization.

\end{fulllineitems}

\index{load\_telemac\_gui() (src\_GUI.hydro\_GUI\_2.TELEMAC method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.hydro_GUI_2.TELEMAC.load_telemac_gui}}\pysiglinewithargsret{\sphinxbfcode{load\_telemac\_gui}}{}{}
The function which call the function which load telemac and save the name of files in the project file

\end{fulllineitems}


\end{fulllineitems}



\section{Figure Option - GUI}
\label{\detokenize{index:figure-option-gui}}
in src\_GUI/output\_fig\_GUI.py

This python module lets the user select various options to create the figures, notably the colormap or the size of the text.
It is also wehre the user select the needed outputs.
\phantomsection\label{\detokenize{index:module-src_GUI.output_fig_GUI}}\index{src\_GUI.output\_fig\_GUI (module)}\index{create\_default\_figoption() (in module src\_GUI.output\_fig\_GUI)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.output_fig_GUI.create_default_figoption}}\pysiglinewithargsret{\sphinxcode{src\_GUI.output\_fig\_GUI.}\sphinxbfcode{create\_default\_figoption}}{}{}
This function creates the default dictionnary of option for the figure.

\end{fulllineitems}

\index{load\_fig\_option() (in module src\_GUI.output\_fig\_GUI)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.output_fig_GUI.load_fig_option}}\pysiglinewithargsret{\sphinxcode{src\_GUI.output\_fig\_GUI.}\sphinxbfcode{load\_fig\_option}}{\emph{path\_prj}, \emph{name\_prj}}{}
This function loads the figure option saved in the xml file and create a dictionnary will be given to the functions
which create the figures to know the different options chosen by the user. If the options are not written, this
function uses data by default which are in the fonction create\_default\_fig\_options().
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path to the xml project file

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- the name to this file

\end{itemize}

\item[{Returns}] \leavevmode
the dictionary containing the figure options

\end{description}\end{quote}

\end{fulllineitems}

\index{outputW (class in src\_GUI.output\_fig\_GUI)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.output_fig_GUI.outputW}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.output\_fig\_GUI.}\sphinxbfcode{outputW}}{\emph{path\_prj}, \emph{name\_prj}}{}
The class which support the creation and management of the output. It is notably used to select the options to
create the figures.
\index{check\_uncheck() (src\_GUI.output\_fig\_GUI.outputW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.output_fig_GUI.outputW.check_uncheck}}\pysiglinewithargsret{\sphinxbfcode{check\_uncheck}}{\emph{main\_checkbox}, \emph{other\_checkbox}}{}
This function is used to check a box when the user clied on it and unckeked another passed as parameter
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{main\_checkbox} -- A QCheckBox which sould by selected

\item {} 
\sphinxstyleliteralstrong{other\_checkbox} -- A QCheckbox which should be ``unticked'' when main\_checkbox is selected by the user

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{init\_iu() (src\_GUI.output\_fig\_GUI.outputW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.output_fig_GUI.outputW.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
\end{fulllineitems}

\index{save\_option\_fig() (src\_GUI.output\_fig\_GUI.outputW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.output_fig_GUI.outputW.save_option_fig}}\pysiglinewithargsret{\sphinxbfcode{save\_option\_fig}}{}{}
A function which save the options for the figures in the xlm project file. The options for the figures are
contained in a dictionnary. The idea is to give this dictinnory in argument to all the fonction which create
figures. In the xml project file, the options for the figures are saved under the attribute ``Figure\_Option''.

If you change things here, it is necessary to start a new project as the old projects will not be compatible.
For the new version of HABBY, it will be necessary to insure compatibility by adding xml attribute.

\end{fulllineitems}

\index{send\_log (src\_GUI.output\_fig\_GUI.outputW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.output_fig_GUI.outputW.send_log}}\pysigline{\sphinxbfcode{send\_log}}
A PyQtsignal used to write the log.

\end{fulllineitems}


\end{fulllineitems}

\index{set\_lang\_fig() (in module src\_GUI.output\_fig\_GUI)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.output_fig_GUI.set_lang_fig}}\pysiglinewithargsret{\sphinxcode{src\_GUI.output\_fig\_GUI.}\sphinxbfcode{set\_lang\_fig}}{\emph{nb\_lang}, \emph{path\_prj}, \emph{name\_prj}}{}
This function write in the xml file in which langugage the figures should be done. This is kept in the
group of attribute in the Figure\_Option
:param lang: An int indicating the langugage (0 for english, 1 for french,...)
:param path\_prj: the path to the project
:param name\_prj: the name of the project

\end{fulllineitems}



\section{The Stathab model - GUI}
\label{\detokenize{index:the-stathab-model-gui}}
in src\_GUI/stathab\_GUI.py
\phantomsection\label{\detokenize{index:module-src_GUI.stathab_GUI}}\index{src\_GUI.stathab\_GUI (module)}\index{StathabW (class in src\_GUI.stathab\_GUI)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.stathab\_GUI.}\sphinxbfcode{StathabW}}{\emph{path\_prj}, \emph{name\_prj}}{}
The class to load and manage the widget controlling the Stathab model.

\sphinxstylestrong{Technical comments}

The class StathabW makes the link between the data prepared by the user for Stathab and  the Stathab model
which is in the src folder (stathab\_c.py) using the graphical interface.  Most of the Stathab input are given in
form of text file. For more info on the preparation of text files for stathab, read the document called
`stathabinfo.pdf''.  To use Stathab in HABBY, all Stathab input should be in the same directory. The user select
this directory (using the button “loadb”) and HABBY tries to find the file it needs. All found files are added to
the list called “file found”. If file are missing, they are added to the “file still needed” list.  The user can then
select the fishes on which it wants to run stathab, then it run it by pressing on the “runb” button.

If file where loaded before by the user in the same project, StathabW looks for them and load them again. Here we
can have two cases: a) the data was saved in hdf5 format (as it is done when a stathab run was done) and the path
to this file noted in the xml project file. b) Only the name of the directory was written in the xml project file,
indicated that data was loaded but not saved in hdf5 yet. HABBY manages both cases.

Next, we check in the xml project file where the folder to save the figure (path\_im) is. In case, there are
no path\_im saved, Stathab create one folder to save the figure outputs. This should not be the usual case. Generally,
path\_im is created with the xml project file, but you cannot be sure.

There is a list of error message which are there for the case where the data which was loaded before do not exist
anymore. For example, somebody erased the directory with the Stathab data in the meantime.  In this case,
a pop-up message open and warn the user.

An important attribute of StathabW() is self.mystathab. This is an object fo the stahab class. The stathab model,
which is in the form of a class and not a function, will be run on this object.

StathabW inherit StatModUseful, which is a class mostly used to manage the exchange of the fish name between the
two QListWidget (selected fish and available fish).
\index{add\_all\_fish() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.add_all_fish}}\pysiglinewithargsret{\sphinxbfcode{add\_all\_fish}}{}{}
This function add the name of all known fish (the ones in Pref.txt) to the QListWidget. Careful,
a similar function exists in Fstress\_GUI. Modify both if needed.

\end{fulllineitems}

\index{change\_riv\_type() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.change_riv_type}}\pysiglinewithargsret{\sphinxbfcode{change\_riv\_type}}{}{}
This function manage the changes which needs to happends to the GUI when the user want to pass from
tropical river to temperate river and vice-versa. Indeed the fish species and the input files are not
the same for tropical and temperate river.

\end{fulllineitems}

\index{init\_iu() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
\end{fulllineitems}

\index{load\_from\_hdf5\_gui() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.load_from_hdf5_gui}}\pysiglinewithargsret{\sphinxbfcode{load\_from\_hdf5\_gui}}{}{}
This function calls from the GUI the load\_stathab\_from\_hdf5 function. In addition to call the function to load
the hdf5, it also updates the GUI according to the info contained in the hdf5.

\sphinxstylestrong{Technical comments}

This functino updates the Qlabel similarly to the function “load\_from\_txt\_gui()”.
It also loads the data calling the load\_stathab\_from\_hdf5 function from the Stathab class in src. The info
contains in the hdf5 file are now in the memory in various variables called self.mystathab.”something”.
HABBY used them to update the GUI. First, it updates the list which contains the name of the reaches
(self.list\_re.). Next, it checks that each of the variable needed exists and that they contain some data.
Afterwards, HABBY looks which preference file to use. Either, it will use the default preference file
(contained in HABBY/biology) or a custom preference prepared by the user. This custom preference
file should be in the same folder than the hdf5 file. When the preference file was found, HABBY reads all
the fish type which are described and add their name to the self.list\_f list which show the available fish
to the user in the GUI. Finally it checks if all the variables were found or if some were missing

\end{fulllineitems}

\index{load\_from\_txt\_gui() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.load_from_txt_gui}}\pysiglinewithargsret{\sphinxbfcode{load\_from\_txt\_gui}}{}{}
The main roles of load\_from\_text\_gui() are to call the load\_function of the stathab class (which is in
stathab\_c.py in the folder src) and to call the function which create an hdf5 file. However, it does some
modifications to the GUI before.

\sphinxstylestrong{Technical comments}

Here is the list of the modifications done to the graphical user interface before calling the load\_function of
Stathab.

First, it updates the label. Because a new directory was selected, we need to update the label containing the
directory’s name. We only show the 30 last character of the directory name. In addition, we also need to update
the other label. Indeed, it is possible that the data used by Stathab would be loaded from an hdf5 file.
In this case, the labels on the top of the list of file are slightly modified. Here, we insure that we are in
the “text” version since we will load the data from text file.

Next, it gets the name of all the reach and adds them to the list of reach name. For this, it calls a function
from the stathab class (in src). Then, it looks which files are present and add them to the list which contains
the reach name called self.list\_re.

Afterwards, it checks if the files needed by Stathab are here. The list of file is given in the
self.end\_file\_reach list. The form of the file is always the name of the reach + one item of
self.end\_file\_reach. If it does not find all files, it add the name of the files not found to self.list\_needed,
so that the user can be aware of which file he needs. The exception is Pref.txt. If HABBY do not find it in the
directory, it uses the default “Pref.txt”. All files (apart from Pref.txt) should be in the same directory.
If the river is temperate, the files needed are not the same than if the river is in the tropic. This is
accounted using the variable rivint. If rivint is zero, the river is temparate and this function looks for the
file needed for temperate type (list of file contained in self.end\_file\_reach and self.name\_file\_allreach).
If riverin is equal to 1 or 2, the river is tropical (list of file contained in self.end\_file\_reach\_top and
biological data in the stathab folder in the biology folder (many files). If the river is temperate,
all preference coeff are in one file called Pref.txt (also in the stathab folder of the biology folder).

Then, it calls a method of the Stathab class (in src) which reads the “pref.txt” file and adds the name
of the fish to the GUI. If the ``tropical river'' option is selected, it looks which preference file are present
in self.path\_bio\_stathab. The name of the tropical preference file needs to be in this form: YuniYh\_XXX.csv and
YuniYh\_XX.csv for the univariate case and YbivYXXX.csv for the bivarate where XX is the three letter fish code
from ONEMA and Y is whatever string. The form of the preference file is the form from the R version of
stathab 2.

Next, if all files are present, it loads the data using the method written in Stathab
(in the src folder). When the data is loaded, it creates an hdf5 file from this data and save the name of this
new hdf5 file in the xml project file (also using a method in the stathab class).

Finally, it sends the log info as explained in the log section of the documentation

\end{fulllineitems}

\index{reach\_selected() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.reach_selected}}\pysiglinewithargsret{\sphinxbfcode{reach\_selected}}{}{}
A function which indcates which files are linked with which reach.

\sphinxstylestrong{Technical comment}

This is a small function which only impacts the GUI. When a Stathab model has more than one reach,
the user can click on the name of the reach. When he does this, HABBY selects the first file linked
with this reach and shows it in self.list\_f. This first file is highlighted and the list is scrolled
down so that the files linked with the selected reach are shown. This function manages this. It is connected
with the list self.list\_re, which is the list with the name of the reaches.

\end{fulllineitems}

\index{recreate\_image() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.recreate_image}}\pysiglinewithargsret{\sphinxbfcode{recreate\_image}}{}{}
This function redo the figures from Stahtab

\end{fulllineitems}

\index{run\_stathab\_gui() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.run_stathab_gui}}\pysiglinewithargsret{\sphinxbfcode{run\_stathab\_gui}}{}{}
This is the function which calls the function to run the Stathab model.  First it read the list called
self.list\_s. This is the list with the fishes selected by the user. Then, it calls the function to run
stathab and the one to create the figure if the figures were asked by the user. Finally, it writes the log.

\end{fulllineitems}

\index{select\_dir() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.select_dir}}\pysiglinewithargsret{\sphinxbfcode{select\_dir}}{}{}
This function is used to select the directory and find the files to laod stathab from txt files. It calls
load\_from\_txt\_gui() when done.

\end{fulllineitems}

\index{select\_hdf5() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.select_hdf5}}\pysiglinewithargsret{\sphinxbfcode{select\_hdf5}}{}{}
This function allows the user to choose an hsdf5 file as input from Stathab.

\sphinxstylestrong{Technical comment}

This function is for example useful if the user would have created an hdf5 file for a Stathab model in another
project and he would like to send the same model on other fish species.

This function writes the name of the new hdf5 file in the xml project file. It also notes that the last data
loaded was of hdf5 type. This is useful when HABBY is restarting because it is possible to have a
directory name and the address of an hdf5 file in the part of the xml project file concerning Stathab.
HABBY should know if the last file loaded was this hdf5 or the files in the directory.
Finally, it calls the function to load the hdf5 called load\_from\_hdf5\_gui.

\end{fulllineitems}

\index{send\_err\_log() (src\_GUI.stathab\_GUI.StathabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.send_err_log}}\pysiglinewithargsret{\sphinxbfcode{send\_err\_log}}{}{}
Send the errors and warnings to the logs. It is useful to note that the stdout was redirected to self.mystdout.

\end{fulllineitems}

\index{send\_log (src\_GUI.stathab\_GUI.StathabW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.send_log}}\pysigline{\sphinxbfcode{send\_log}}
A PyQtsignal used to write the log.

\end{fulllineitems}

\index{show\_fig (src\_GUI.stathab\_GUI.StathabW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.stathab_GUI.StathabW.show_fig}}\pysigline{\sphinxbfcode{show\_fig}}
A PyQtsignal used to show the figures.

\end{fulllineitems}


\end{fulllineitems}



\section{FStress model - GUI}
\label{\detokenize{index:fstress-model-gui}}
in src\_GUI/fstress\_GUI.py
\phantomsection\label{\detokenize{index:module-src_GUI.fstress_GUI}}\index{src\_GUI.fstress\_GUI (module)}\index{FstressW (class in src\_GUI.fstress\_GUI)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.fstress_GUI.FstressW}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.fstress\_GUI.}\sphinxbfcode{FstressW}}{\emph{path\_prj}, \emph{name\_prj}}{}
This class provides the graphical user interface for the habby version of Fstress. The Fstress model is described in
fstress.py. FstressW just loads the data given by the user. He/She can write this data in the GUI or loads it
from files. The following files are needed:
\begin{itemize}
\item {} 
listriv.txt the list of the river (if the file does not exist, the river is called river1).

\item {} 
rivqwh.txt discharge, width, height for two discharge (measured) for each rivers.

\item {} 
rivdeb.txt max and min discharge.

\end{itemize}

FStress inherits from the class StatModUseful. This class is a ``parent'' class with some functions which are the same
for estimhab and fstress. Hence, we can re-use these function without re.writing them (a bit like SubHydroW)
\index{add\_all\_fish() (src\_GUI.fstress\_GUI.FstressW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.fstress_GUI.FstressW.add_all_fish}}\pysiglinewithargsret{\sphinxbfcode{add\_all\_fish}}{}{}
This function add the name of all known fish (the ones in Pref.txt) to the QListWidget. This function
was copied from the one in SStathab\_GUI.py

\end{fulllineitems}

\index{erase\_name() (src\_GUI.fstress\_GUI.FstressW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.fstress_GUI.FstressW.erase_name}}\pysiglinewithargsret{\sphinxbfcode{erase\_name}}{}{}
This function erases the data from the river selected by the user.

\end{fulllineitems}

\index{init\_iu() (src\_GUI.fstress\_GUI.FstressW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.fstress_GUI.FstressW.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
This function is used to initialized an instance of the FstressW() class. It is called by \_\_init\_\_().
It is very similar to EstihabW but it is possible to get more than one river and it can load the data from
folder.

\end{fulllineitems}

\index{load\_all\_fish() (src\_GUI.fstress\_GUI.FstressW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.fstress_GUI.FstressW.load_all_fish}}\pysiglinewithargsret{\sphinxbfcode{load\_all\_fish}}{}{}
This function find the preference file, load the preference coefficient for each invertebrate and show their name
on QListWidget. it is run at the start of the program. FStress cannot be run as long as a preference file is not
found.

\end{fulllineitems}

\index{load\_data\_fstress() (src\_GUI.fstress\_GUI.FstressW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.fstress_GUI.FstressW.load_data_fstress}}\pysiglinewithargsret{\sphinxbfcode{load\_data\_fstress}}{\emph{rind}}{}
This function loads the data for fstress and add it to the variable self.qrange and self.qhw for the river
rind.
:param rind: The indices of the river is self.river\_name. So it is which river should be loaded

\end{fulllineitems}

\index{load\_hdf5\_fstress() (src\_GUI.fstress\_GUI.FstressW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.fstress_GUI.FstressW.load_hdf5_fstress}}\pysiglinewithargsret{\sphinxbfcode{load\_hdf5\_fstress}}{}{}
This function loads an hdf5 file in the fstress format and add it to the project. This hdf5 file was not part of
the project previously.

\end{fulllineitems}

\index{load\_txt() (src\_GUI.fstress\_GUI.FstressW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.fstress_GUI.FstressW.load_txt}}\pysiglinewithargsret{\sphinxbfcode{load\_txt}}{}{}
In this function, the user select a qhw.txt or a listriv.txt file. This files are loaded and written on the GUI.
If a listriv.txt is selected, the river in lisriv.txt are loaded. If a qhw.txt is loaded and if there are
more than one qhw.txt in the folder, we ask the user if all files must be loaded. The needed text files are
the following:
\begin{itemize}
\item {} 
listriv.txt is a text file with one river name by line (not necessary)

\item {} 
rivnameqhw.txt is a text file with minimum two lines which the measured discharge, height and width for
2 measureement (necessary)

\item {} 
rivernamedeb.txt is a text file which has two lines. The first line is the minimum discharge and the second is
the maximum discharge to be modelled. It is chosen by the user (necessary to run, but can be given by the user
on the GUI)

\end{itemize}

All data should be in SI unit.

\end{fulllineitems}

\index{modify\_name() (src\_GUI.fstress\_GUI.FstressW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.fstress_GUI.FstressW.modify_name}}\pysiglinewithargsret{\sphinxbfcode{modify\_name}}{}{}
This function is used to modify the name of a river. It will only be saved if FStress is run. Otherwise it
is not kept in the data.

\end{fulllineitems}

\index{runsave\_fstress() (src\_GUI.fstress\_GUI.FstressW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.fstress_GUI.FstressW.runsave_fstress}}\pysiglinewithargsret{\sphinxbfcode{runsave\_fstress}}{}{}
This function save the data related to FStress and call the model Fstress. It is the method which makes the
link between the GUI and fstress.py.

\end{fulllineitems}

\index{save\_river\_data() (src\_GUI.fstress\_GUI.FstressW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.fstress_GUI.FstressW.save_river_data}}\pysiglinewithargsret{\sphinxbfcode{save\_river\_data}}{}{}
This function save the data for one river based on the data from the GUI (i.e., after modification by the user).
It can be used to save the data given directely by the user or modified by him.

\end{fulllineitems}

\index{show\_data\_one\_river() (src\_GUI.fstress\_GUI.FstressW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.fstress_GUI.FstressW.show_data_one_river}}\pysiglinewithargsret{\sphinxbfcode{show\_data\_one\_river}}{}{}
This function shows the qhw and the {[}qmin, qmax{]} data on the GUI for the river selected by the user.
The river must have been loaded before. It also show the selected fish

\end{fulllineitems}

\index{update\_list\_riv() (src\_GUI.fstress\_GUI.FstressW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.fstress_GUI.FstressW.update_list_riv}}\pysiglinewithargsret{\sphinxbfcode{update\_list\_riv}}{}{}
This function is a small function to update the QCombobox which contains the river name

\end{fulllineitems}

\index{was\_loaded\_before() (src\_GUI.fstress\_GUI.FstressW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.fstress_GUI.FstressW.was_loaded_before}}\pysiglinewithargsret{\sphinxbfcode{was\_loaded\_before}}{}{}
This function looks in the xml project file is an hdf5 exists already. If yes, it loads this data
and show it on the GUI.

\end{fulllineitems}


\end{fulllineitems}



\section{Estimhab - GUI}
\label{\detokenize{index:estimhab-gui}}
in src\_GUI/estimhab\_GUI.py
\phantomsection\label{\detokenize{index:module-src_GUI.estimhab_GUI}}\index{src\_GUI.estimhab\_GUI (module)}\index{EstimhabW (class in src\_GUI.estimhab\_GUI)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.EstimhabW}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.estimhab\_GUI.}\sphinxbfcode{EstimhabW}}{\emph{path\_prj}, \emph{name\_prj}}{}
The Estimhab class provides the graphical interface for the version of the Estimhab model written in HABBY.
The Estimhab model is described elsewhere. EstimhabW() just loads the data for Estimhab given by the user.
\index{change\_folder() (src\_GUI.estimhab\_GUI.EstimhabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.EstimhabW.change_folder}}\pysiglinewithargsret{\sphinxbfcode{change\_folder}}{}{}
A small method to change the folder which indicates where is the biological data

\end{fulllineitems}

\index{init\_iu() (src\_GUI.estimhab\_GUI.EstimhabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.EstimhabW.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
This function is used to initialized an instance of the EstimhabW() class. It is called by \_\_init\_\_().
\begin{quote}

\sphinxstylestrong{Technical comments and walk-through}

First we looked if some data for Estimhab was saved before by an user. If yes, we will fill the GUI with
the information saved before. Estimhab information is saved in hdf5 file format and the path/name of the
hdf5 file is saved in the xml project file. So we open the xml project file and look if the name of an hdf5
file was saved for Estimhab. If yes, the hdf5 file is read.

The format of hdf5 file is relatively simple. Each input data for Estimhab has its own dataset (qmes, hmes,
wmes, q50, qrange, and substrate).  Then, we have a list of string which are a code for the fish species which
were analyzed.  All the data contained in hdf5 file is loaded into variable.

The different label are written on the graphical interface. Then, two QListWidget are modified. The first
list contains all the fish species on which HABBY has info (see XML Estimhab format for more info).
The second list is the fish selected by the user on which Estimhab will be run. Here, we link these lists
with two functions so that the user can select/deselect fish using the mouse. The function name are add\_fish()
and remove\_fish().

Then, we fill the first list. HABBY look up all file of xml type in the “Path\_bio” folder (the one indicated in
the xml project file under the attribute “Path\_bio”).  The name are them modified so that the only the name of
species appears (and not the full path). We set the layout with all the different QLineEdit where the user
can write the needed data.

Estimhab model is saved using a function situated in MainWindows\_1.py  (frankly, I am not so sure why I did put
the save function there, but anyway). So the save button just send a signal to MainWindows
here, which save the data.
\end{quote}

\end{fulllineitems}

\index{open\_estimhab\_hdf5() (src\_GUI.estimhab\_GUI.EstimhabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.EstimhabW.open_estimhab_hdf5}}\pysiglinewithargsret{\sphinxbfcode{open\_estimhab\_hdf5}}{}{}
This function opens the hdf5 data created by estimhab

\end{fulllineitems}

\index{run\_estmihab() (src\_GUI.estimhab\_GUI.EstimhabW method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.EstimhabW.run_estmihab}}\pysiglinewithargsret{\sphinxbfcode{run\_estmihab}}{}{}
A function to execute Estimhab by calling the estimhab function.

\sphinxstylestrong{Technical comment}

This is the function making the link between the GUI and the source code proper. The source code for Estimhab
is in src/Estimhab.py.

This function loads in memory the data given in the graphical interface and call sthe Estimhab model.
The data could be written by the user now or it could be data which was saved in the hdf5 file before and
loaded when HABBY was open (and the init function called).  We check that all necessary data is present and
that the data given makes sense (e.g.,the minimum discharge should not be bigger than the maximal discharge,
the data should be a float, etc.). We then remove the duplicate fish species (in case the user select one
specie twice) and the Estimhab model is called. The log is then written (see the paragraph on the log for more
information). Next, the figures created by Estimmhab are shown. As there is only a short number of outputs
for Estimhab, we create a figure in all cases (it could be changed by adding a checkbox on the GUI like
in the Telemac or other hydrological class).

\end{fulllineitems}

\index{save\_signal\_estimhab (src\_GUI.estimhab\_GUI.EstimhabW attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.EstimhabW.save_signal_estimhab}}\pysigline{\sphinxbfcode{save\_signal\_estimhab}}
PyQtsignal to save the Estimhab data.

\end{fulllineitems}


\end{fulllineitems}

\index{StatModUseful (class in src\_GUI.estimhab\_GUI)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.StatModUseful}}\pysigline{\sphinxstrong{class }\sphinxcode{src\_GUI.estimhab\_GUI.}\sphinxbfcode{StatModUseful}}
This class is not called directly by HABBY, but it is the parent class of EstihabW and FstressW. As fstress and
estimhab have a similar graphical user interface, this architecture allows to re-use some functions between the
two classes, which saves a bit of coding.
\index{add\_fish() (src\_GUI.estimhab\_GUI.StatModUseful method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.StatModUseful.add_fish}}\pysiglinewithargsret{\sphinxbfcode{add\_fish}}{}{}
The function is used to select a new fish species (or inverterbrate)

\end{fulllineitems}

\index{add\_sel\_fish() (src\_GUI.estimhab\_GUI.StatModUseful method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.StatModUseful.add_sel_fish}}\pysiglinewithargsret{\sphinxbfcode{add\_sel\_fish}}{}{}
This function loads the xml file and check if some fish were selected before. If yes, we add them to the list

\end{fulllineitems}

\index{find\_path\_hdf5\_est() (src\_GUI.estimhab\_GUI.StatModUseful method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.StatModUseful.find_path_hdf5_est}}\pysiglinewithargsret{\sphinxbfcode{find\_path\_hdf5\_est}}{}{}
A function to find the path where to save the hdf5 file. Careful a simialar one is in hydro\_GUI\_2.py and in
stathab\_c. By default, path\_hdf5 is in the project folder in the folder `fichier\_hdf5'.

\end{fulllineitems}

\index{find\_path\_im\_est() (src\_GUI.estimhab\_GUI.StatModUseful method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.StatModUseful.find_path_im_est}}\pysiglinewithargsret{\sphinxbfcode{find\_path\_im\_est}}{}{}
A function to find the path where to save the figues. Careful there is similar function in hydro\_GUI\_2.py.
Do not mix it up
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
path\_im a string which indicates the path to the folder where are save the images.

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_path\_input\_est() (src\_GUI.estimhab\_GUI.StatModUseful method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.StatModUseful.find_path_input_est}}\pysiglinewithargsret{\sphinxbfcode{find\_path\_input\_est}}{}{}
A function to find the path where to save the input file. Careful a simialar one is in estimhab\_GUI.py. By default,
path\_input indicates the folder `input' in the project folder.

\end{fulllineitems}

\index{find\_path\_output\_est() (src\_GUI.estimhab\_GUI.StatModUseful method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.StatModUseful.find_path_output_est}}\pysiglinewithargsret{\sphinxbfcode{find\_path\_output\_est}}{\emph{att}}{}
A function to find the path where to save the shapefile, paraview files and other future format. Here, we gave
the xml attribute as argument so this functin can be used to find all path needed. However, it is less practical
to use as the function above as one should remember the xml tribute to call this function. However, it can be
practical to use to add new folder.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{att} -- the xml attribute (from the xml project file) linked to the path needed, without the .//

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_path\_text\_est() (src\_GUI.estimhab\_GUI.StatModUseful method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.StatModUseful.find_path_text_est}}\pysiglinewithargsret{\sphinxbfcode{find\_path\_text\_est}}{}{}
A function to find the path where to save the hdf5 file. Careful a simialar one is in estimhab\_GUI.py. By default,
path\_hdf5 is in the project folder in the folder `fichier\_hdf5'.

\end{fulllineitems}

\index{remove\_all\_fish() (src\_GUI.estimhab\_GUI.StatModUseful method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.StatModUseful.remove_all_fish}}\pysiglinewithargsret{\sphinxbfcode{remove\_all\_fish}}{}{}
This function removes all fishes from the selected fish

\end{fulllineitems}

\index{remove\_fish() (src\_GUI.estimhab\_GUI.StatModUseful method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.StatModUseful.remove_fish}}\pysiglinewithargsret{\sphinxbfcode{remove\_fish}}{}{}
The function is used to remove fish species (or inverterbates species)

\end{fulllineitems}

\index{send\_err\_log() (src\_GUI.estimhab\_GUI.StatModUseful method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.StatModUseful.send_err_log}}\pysiglinewithargsret{\sphinxbfcode{send\_err\_log}}{}{}
This function sends the errors and the warnings to the logs.
The stdout was redirected to self.mystdout before calling this function. It only sends the hundred first errors
to avoid freezing the GUI. A similar function exists in hydro\_GUI\_2.py. Correct both if necessary.

\end{fulllineitems}

\index{send\_log (src\_GUI.estimhab\_GUI.StatModUseful attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.StatModUseful.send_log}}\pysigline{\sphinxbfcode{send\_log}}
PyQtsignal to write the log.

\end{fulllineitems}

\index{show\_fig (src\_GUI.estimhab\_GUI.StatModUseful attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.estimhab_GUI.StatModUseful.show_fig}}\pysigline{\sphinxbfcode{show\_fig}}
PyQtsignal to show the figures.

\end{fulllineitems}


\end{fulllineitems}



\section{Information Biological and Run habitat}
\label{\detokenize{index:information-biological-and-run-habitat}}
in src\_GUI/bio\_info\_GUI.py

This python module is where the biological info is managed and shown to the user.
It is also where the user can run the habitat calculation.
\phantomsection\label{\detokenize{index:module-src_GUI.bio_info_GUI}}\index{src\_GUI.bio\_info\_GUI (module)}\index{BioInfo (class in src\_GUI.bio\_info\_GUI)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.bio_info_GUI.BioInfo}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src\_GUI.bio\_info\_GUI.}\sphinxbfcode{BioInfo}}{\emph{path\_prj}, \emph{name\_prj}, \emph{lang='French'}}{}
This class contains the tab with the biological information (the curves of preference). It inherites from
StatModUseful. StatModuseful is a QWidget, with some practical signal (send\_log and show\_fig) and some functions
to find path\_im and path\_bio (the path wher to save image) and to manage lists.
\index{get\_autocompletion() (src\_GUI.bio\_info\_GUI.BioInfo method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.bio_info_GUI.BioInfo.get_autocompletion}}\pysiglinewithargsret{\sphinxbfcode{get\_autocompletion}}{}{}
This function update the auto-complexton model as a function of the QComboxBox next to it

\end{fulllineitems}

\index{get\_list\_merge (src\_GUI.bio\_info\_GUI.BioInfo attribute)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.bio_info_GUI.BioInfo.get_list_merge}}\pysigline{\sphinxbfcode{get\_list\_merge}}
A Pyqtsignal which indicates to chronice\_GUI.py that the merge list should be changed. In Main\_Windows.py,
the new list of merge file is found and send to the ChonicleGui class.

\end{fulllineitems}

\index{init\_iu() (src\_GUI.bio\_info\_GUI.BioInfo method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.bio_info_GUI.BioInfo.init_iu}}\pysiglinewithargsret{\sphinxbfcode{init\_iu}}{}{}
Used in the initialization by \_\_init\_\_()

\end{fulllineitems}

\index{next\_completion() (src\_GUI.bio\_info\_GUI.BioInfo method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.bio_info_GUI.BioInfo.next_completion}}\pysiglinewithargsret{\sphinxbfcode{next\_completion}}{}{}
A small function to use the enter key to select the fish with auto-completion.
Adapted from \url{https://stackoverflow.com/questions/9044001/qcompleter-and-tab-key}
It would be nice to mek it work with tab also but it si quite complcated because it is quite complicated.

\end{fulllineitems}

\index{recreate\_fig() (src\_GUI.bio\_info\_GUI.BioInfo method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.bio_info_GUI.BioInfo.recreate_fig}}\pysiglinewithargsret{\sphinxbfcode{recreate\_fig}}{}{}
This function use show\_image\_hab() to recreate the habitat figures shown before

\end{fulllineitems}

\index{run\_habitat\_value() (src\_GUI.bio\_info\_GUI.BioInfo method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.bio_info_GUI.BioInfo.run_habitat_value}}\pysiglinewithargsret{\sphinxbfcode{run\_habitat\_value}}{}{}
This function runs HABBY to get the habitat value based on the data in a ``merged'' hdf5 file and the chosen
preference files.

We should not add a comma in the name of the selected fish.

\end{fulllineitems}

\index{select\_fish() (src\_GUI.bio\_info\_GUI.BioInfo method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.bio_info_GUI.BioInfo.select_fish}}\pysiglinewithargsret{\sphinxbfcode{select\_fish}}{}{}
This function select the fish which corresponds at the chosen criteria by the user. The type of criteria
is given in the list self.keys and the criteria is given in self.cond1. The condition should exactly
match the criteria. Sign such as * does not work.

\end{fulllineitems}

\index{show\_hydrosignature() (src\_GUI.bio\_info\_GUI.BioInfo method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.bio_info_GUI.BioInfo.show_hydrosignature}}\pysiglinewithargsret{\sphinxbfcode{show\_hydrosignature}}{}{}
This function make the link with function in bio\_info.py which allows to load and plot the data realted
to the hydrosignature.

\end{fulllineitems}

\index{show\_image\_hab() (src\_GUI.bio\_info\_GUI.BioInfo method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.bio_info_GUI.BioInfo.show_image_hab}}\pysiglinewithargsret{\sphinxbfcode{show\_image\_hab}}{}{}
This function is linked with the timer started in run\_habitat\_value. It is run regulary and
check if the function on the second thread have finised created the figures. If yes,
this function create the 1d figure for the HABBY GUI.

\end{fulllineitems}

\index{show\_info\_fish() (src\_GUI.bio\_info\_GUI.BioInfo method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.bio_info_GUI.BioInfo.show_info_fish}}\pysiglinewithargsret{\sphinxbfcode{show\_info\_fish}}{\emph{select=False}}{}
This function shows the useful information concerning the selected fish on the GUI.
\begin{description}
\item[{:param select:If False, the selected items comes from the QListWidgetcontaining the available fish.}] \leavevmode
If True, the items comes the QListWidget with the selected fish

\end{description}

\end{fulllineitems}

\index{show\_info\_fish\_avai() (src\_GUI.bio\_info\_GUI.BioInfo method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.bio_info_GUI.BioInfo.show_info_fish_avai}}\pysiglinewithargsret{\sphinxbfcode{show\_info\_fish\_avai}}{}{}
This function shows the useful information concerning the available fish on the GUI and
add the fish to  the selected fish This is what happens when the user click on the
first QListWidget (the one called available fish).

\end{fulllineitems}

\index{show\_info\_fish\_sel() (src\_GUI.bio\_info\_GUI.BioInfo method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.bio_info_GUI.BioInfo.show_info_fish_sel}}\pysiglinewithargsret{\sphinxbfcode{show\_info\_fish\_sel}}{}{}
This function shows the useful information concerning the already selected fish on the GUI and
remove the selected fish from the list of selected fish. This is what happens when the user click on the
second QListWidget (the one called selected fish and guild).

\end{fulllineitems}

\index{show\_pref() (src\_GUI.bio\_info\_GUI.BioInfo method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.bio_info_GUI.BioInfo.show_pref}}\pysiglinewithargsret{\sphinxbfcode{show\_pref}}{}{}
This function shows the image of the preference curve of the selected xml file. For this it calls, the functions
read\_pref and figure\_pref of bio\_info.py. Hence, this function justs makes the link between the GUI and
the functions effectively doing the image.

\end{fulllineitems}

\index{update\_merge\_list() (src\_GUI.bio\_info\_GUI.BioInfo method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src_GUI.bio_info_GUI.BioInfo.update_merge_list}}\pysiglinewithargsret{\sphinxbfcode{update\_merge\_list}}{}{}
This function goes in the projet xml file and gets all available merged data. Usually, it is called
by Substrate() (when finished to merge some data) or at the start of HABBY.

We add a ``tooltip'' which indicates the orginal hydraulic and substrate files.

\end{fulllineitems}


\end{fulllineitems}



\subsection{Biological data - Estimhab}
\label{\detokenize{index:biological-data-estimhab}}
The biological data, i.e., the preference curves of Estimhab, are saved in xml files
situated in the folder given by the path written in the xml project file under the
attribute Path\_bio. By default, it is HABBY/biology. It is possible to change this folder
using the GUI.

Estimhab is a statistical model, which functions using mathematical regressions.
The different regressions (or preference curve) of each fish are described in an xml file
whose format is given here.

Conceptually, the regressions R are of two types:
\begin{itemize}
\item {} 
Type 0          R = C * Q\textasciicircum{}\{m1\} * exp(m2*Q)

\item {} 
Type 1          R = C * (1+m1*exp(m2*Q))

\end{itemize}

Where Q is the discharge, m1 and m2 are coefficients which depend on the fish type, and C is a
constant which depends on the stream characteristic and the fish type.

The constant C is of the form C = a + sum ai * ln(Si) where a and ai are coefficients which depend on
the fish type. Si are particular stream characteristics. Which characteristics should be used is a
function of the fish type and is so given in the xml file. The value of S i is a function of the stream
and is calculated by the program.

In the xml file,
\begin{itemize}
\item {} 
Attribute coeff\_q: Give the main coefficients of the regression (m1 and m2)

\item {} 
Attribute func\_q : Give the type of regression R used.  Type 0 and type 1, as described above, are known by HABBY.

\item {} 
Attribute coeff\_const: Give the coefficient used to construct the constant C (a, a1, a2, a3,…). The number of coefficient differs for each fish, but should be at least one.

\item {} 
Attribute var\_const: Give which type of stream characteristics is used. This is not the value of the particular characteristic, but only which type is used. The following list of type is accepted:
\begin{itemize}
\item {} 
0 for Q50, natural median discharge

\item {} 
1 for H50, the height of the stream at q50

\item {} 
2 for L50, the width of the stream at q50

\item {} 
3 for V50, the velocity of the stream at q50

\item {} 
4 for Re50, the discharge divided by 10 times the width at Q50

\item {} 
5 for Fr50, the Froude number at Q50

\item {} 
6 for Dh50, the mean substrate height divided by h50

\item {} 
7 for Exp(Dh50). Erase the log() of this particular term of the constant

\end{itemize}

\end{itemize}


\chapter{Calculation of fish's habitat}
\label{\detokenize{index:calculation-of-fish-s-habitat}}
The src folder contains the python module which are not linked with the graphical user interface.
\phantomsection\label{\detokenize{index:module-src}}\index{src (module)}

\section{Hec-ras model 1D}
\label{\detokenize{index:hec-ras-model-1d}}
in src/Hec\_ras06.py

This module contains the functions used to load the outputs from the hec-ras model in 1.5D.
\phantomsection\label{\detokenize{index:module-src.Hec_ras06}}\index{src.Hec\_ras06 (module)}\index{coord\_profile\_non\_georeferenced() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.coord_profile_non_georeferenced}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{coord\_profile\_non\_georeferenced}}{\emph{data\_bank\_all}, \emph{data\_dist\_all}, \emph{data\_river\_all}, \emph{data\_profile\_all}, \emph{nb\_pro\_reach}}{}
This is a function to create the coordinates of the profile in the non-georeferenced case.
This function is called by open geo\_file(). Hypothesis: The profile are straight and perpendicular to the river.
The last profile is at the end of the river.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{data\_bank\_all} -- distance along the profile of bank station

\item {} 
\sphinxstyleliteralstrong{data\_dist\_all} -- the distance between the profile (left, center channel, right)

\item {} 
\sphinxstyleliteralstrong{data\_river\_all} -- the coordinate of the river

\item {} 
\sphinxstyleliteralstrong{data\_profile\_all} -- the (d,z) data of the profile

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- the number of profile by reach

\end{itemize}

\item[{Returns}] \leavevmode
the coordinates of the profile

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

For each profile, we create an array composed of five points: Start of profile, left bank, intersection between
river and profile, right bank and end of profile. The intersection with the river is directly given as input to
the function. Then we find the vector perpendicular to this river and we get the four other points on the same line.

To get the distance for these four other point, we must be careful to pass from the distance given in meter and the
distance in the model coordinates (scaled between {[}0, 1{]} usually). The way to go from one coordinate system to
another is to use the “alpha” variable.  We only need to correct distance, no problem with a system of coordinate
which would not be in the same direction (as the data is given along a profile). The river passes in the middle of
the right and left bank, so we can find where is left and right bank is. Because we know the total length of the
profile, we can also find the beginning and end of the profile.

\end{fulllineitems}

\index{figure\_xml() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.figure_xml}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{figure\_xml}}{\emph{data\_profile}, \emph{coord\_pro\_old}, \emph{coord\_r}, \emph{xy\_h\_all}, \emph{zone\_v\_all}, \emph{pro}, \emph{path\_im}, \emph{fig\_opt}, \emph{nb\_sim=0}, \emph{name\_profile='no\_name'}, \emph{coord\_p2=-99}}{}
A function to plot the results of the loading of hec-ras data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{data\_profile} -- (list with np.array)

\item {} 
\sphinxstyleliteralstrong{coord\_pro\_old} -- (x,y) data of the profile (list with np.array)

\item {} 
\sphinxstyleliteralstrong{coord\_r} -- (x,y) data of the river (list with np.array)

\item {} 
\sphinxstyleliteralstrong{xy\_h\_all} -- (x,y, h) for the height data for each simulation (list with np.array)

\item {} 
\sphinxstyleliteralstrong{zone\_v\_all} -- (x,y, v) for the velocity data. velocity is by zone of profile. for each simulation.
the (x,y) indicates the start of the zone which end with the next velocity

\item {} 
\sphinxstyleliteralstrong{pro} -- a list of int with the profile whcih should be ploted {[}2,3,4{]}

\item {} 
\sphinxstyleliteralstrong{nb\_sim} -- which simulation should be plotted. In fact, it often relates to the time step.

\item {} 
\sphinxstyleliteralstrong{name\_profile} -- a list of string with the name of the profiles

\item {} 
\sphinxstyleliteralstrong{coord\_p2} -- the data of the profile when non geo-referenced, optional

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where the figure should be saved (string)

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- the figure options

\end{itemize}

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

We first choose the size of the font to be written. At term, it should be given by the options.

Two main groups of figure will be done: One list of figure with the form of the profil, the water height, and the
velocity for the chosen profiles and one (x,y) view of the position of each profile.

We chose the time step to be written (the variable nb\_sim here). The variable pro is a list which says which
profiles are to be plotted. Hence, we get the velocity and water height for the time step and profile of interest.

To plot the velocity, we first get the distance along the profile where the water level cut the profile elevation.
This is the variable xint1 and xint2. We then get the velocity data for the region under the water. We add three
points for velocity at 0, xint1 and xint2. We then used the step function to plot the vecloity. Because of the added
point, we will have a zero velocity from 0 to xint1, then the velocity data, then again zeros from xint2 to the end.

To plot the elevation of the profile, we plot the variable xz and we use the function fill\_between to fill
in blue the region under water. This function creates a line at the water elevation and fills in blue between this
line and the profile elevation. We add some titles and save the figures.

For the second type of figure (view in x,y coordinates), We first plot the river position which is saved in the
coord\_r variable. Then we plot the coordinate of each profile and their names. If the name of the profile is not
known, we plot the profile number.  We also plot the position of each velocity data and height data (as it could be
useful). If the figure gets too complicated, this can be taken away by changing the two lines which finish
with height or velocity as comment.  We add some titles and save the figures.

\end{fulllineitems}

\index{find\_coord\_height\_velocity() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.find_coord_height_velocity}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{find\_coord\_height\_velocity}}{\emph{coord\_pro}, \emph{data\_profile}, \emph{vel}, \emph{wse}, \emph{nb\_sim}, \emph{max\_vel\_dist=0}}{}
This function finds the coordinates of the height/velocity. In hec-ras outputs the data are often written in the
form (profile, distance along the profile, data). This function passes this type of information in the usual
coordinate form.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the coordinate (x,y) of the profile. List of np.array.

\item {} 
\sphinxstyleliteralstrong{data\_profile} -- data concening the geometry of the profile, notably its elevation (x,z). List of np.array.

\item {} 
\sphinxstyleliteralstrong{vel} -- the velocity data. List of np.array.

\item {} 
\sphinxstyleliteralstrong{wse} -- the water surface elevation. List of np.array.

\item {} 
\sphinxstyleliteralstrong{nb\_sim} -- the number of simulation in case there is more than one

\item {} 
\sphinxstyleliteralstrong{max\_vel\_dist} -- the minimum number of velocity point by ten meter before a warnings appears

\end{itemize}

\item[{Returns}] \leavevmode
for each simulation, a list of np.array representing (x,y,v) and (x,y,h,)

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

This is a function called after having loaded the data. Hec-Ras present the data in (profil, distance along
profile, data) form for the height. For the velocity, it is similar but the distance is given by a number between
0 and 1 (0 is the start of the profile, 1 is the end of the profile). This function transforms this data in the form
(x,y, dist, data) using the (x,y) coordinates given in the coord\_pro variable. In other word,  we have the
coordinate of the profile, not of the coordinates of the height and velocity data.

First, we get the distance between all points in (x,y) system. Then, we get the length of the profile in
meter or feet. It is possible to have a (x,y) coordinate system in a different unit. Hence, the length of the profil
is valid for the (profile, distance along profile, data) view. We multiply the velocity distance data by this
length. Hence, the distance information is now in meter or feet along the profile for water height and velocity.

There are some lines added to account for the last and first points of the profile (annoying in hec-ras). We then
calculate the new coordinates. For each velocity and water height point, we find the last known point in the (x,y)
coordinates. We do a vectorial addition from this point plus the vector between this point and the next multiplied
by the distance from this point to the point that we tried to calculate.  The variable alpha is used to pass from
one coordinate system to the next one.

Careful the height is on the node and the velocity is by zone.

\end{fulllineitems}

\index{get\_rid\_of\_white\_space() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.get_rid_of_white_space}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{get\_rid\_of\_white\_space}}{\emph{stream\_str}}{}
This is a small fonction to get rid of white space at the end of name which could contain white space. Not used
anymore as str.strip() functions well. But, as it was done already, we let it here.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{stream\_str} -- the name of the string

\item[{Returns}] \leavevmode
the same name without white space.

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_xml() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.load_xml}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{load\_xml}}{\emph{xml\_file}, \emph{path}}{}
This is a function used by openxml\_file and opengml\_file to load an xml file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{xml\_file} -- the name of an xml file (string)

\item {} 
\sphinxstyleliteralstrong{path} -- the path where the xml file is (string)

\end{itemize}

\item[{Returns}] \leavevmode
the loaded data from the XML file in the form of the root of the xml file.

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.main}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{main}}{}{}
This is not the main() of HABBY. This function is used to test this module independently of the rest of HABBY.

\end{fulllineitems}

\index{open\_geofile() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.open_geofile}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{open\_geofile}}{\emph{geo\_file}, \emph{path}}{}
This function opens the geometry file (.g0X) from Hecr-rad. It extracts the (x,z) from each profile
and the (x,y) if georeferenced,
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{geo\_file} -- the name of the Hec-Ras geometry file (string)

\item {} 
\sphinxstyleliteralstrong{path} -- the path to the geo file (string)

\end{itemize}

\item[{Returns}] \leavevmode
A list with each river profile (each profile is represented by a numpy array with the x and the altitude
of each point in the profile), the coordinate of the profile (list of np.array),
the coordinate of the river and the name of the reaches/ river in the file order (list of string)

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

The geofile is a text file with contains the geographical information. Because it is written to be read by human,
it is complicated to load and regular expression are needed. It is written profile by profile.

Generally, to give a position, hec-ras indicates the profile number and the distance along this profile. In addition,
data can be georeferenced or not. If it is geo-referenced we have some data in an (x,y) form. Otherwise, we only
have geometrical data in the form (profile, dist).

First, for each profile, we get the elevation of the points forming each profile in the form (dist, elevation).
The list of elevation for each profile starts with the keyword “Sta/Elev”. The data found in the text file is in a
string format. We use the function pass\_in\_float\_from\_geo to pass it in float. It is usually done using the function
float. However, there are cases where there are no space between two number. However, in this case, the number of
character per number is constant. In this case, we separate the number first.

Then, we get the coordinate of the river. If no coordinate are available the river is assumed to be straight. Next,
we get the bank limit (even if we do not really used afterwards), and the name of the reach. It is also important
to save the order in which the names of the reach are given. Indeed, we want this order to be the same in all
functions, but they can be different between the geo file and the data output.

Next, we want to get the position (x,y) of each profile. If it is georeferenced, we will be able to get this
position directly from the file and put it in the data\_dist\_str variable. We will then pass it to float. If not,
we will use the function coord\_profil\_non\_georeferenced to estimate the position of the profile (see below).

If the profile is not georeferenced, it is important to have the distance between two profile, so we extract the
information from the geo file in all cases (georeferenced or not). The last profile of a reach does not have a
distance to the next (not existing) profile. However, if a profile does not have a distance to the next profile
and is not the last profile, we ignore this profile. It is usually not a problem because this profile is usually
not a “real” profile, but the representation of a bridge or a culvert.

\end{fulllineitems}

\index{open\_hec\_hec\_ras\_and\_create\_grid() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.open_hec_hec_ras_and_create_grid}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{open\_hec\_hec\_ras\_and\_create\_grid}}{\emph{name\_hdf5}, \emph{path\_hdf5}, \emph{name\_prj}, \emph{path\_prj}, \emph{model\_type}, \emph{namefile}, \emph{pathfile}, \emph{interpo\_choice}, \emph{path\_im}, \emph{save\_fig1d}, \emph{pro\_add=1}, \emph{q={[}{]}}, \emph{print\_cmd=False}, \emph{fig\_opt={[}{]}}}{}
This function open the hec\_ras data and creates the 2D grid from the 1.5 data. It is called by the class HEC\_RAS1D
in a second thread to not freeze the GUI.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{name\_hdf5} -- the name of the hdf5 to be created (string)

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- the path to the hdf5 to be created (string)

\item {} 
\sphinxstyleliteralstrong{model\_type} -- the name of the model (hec\_ras in most case, but given as argument in case we change
the form of the name)

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- the name of the project (string)

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path of the project

\item {} 
\sphinxstyleliteralstrong{namefile} -- the name of the geo file and the data file, which contains respectively geographical data and
the ouput data (see open\_hec\_ras() for more precision) -\textgreater{} list of string

\item {} 
\sphinxstyleliteralstrong{pathfile} -- the absolute path to the file chosen into namefile

\item {} 
\sphinxstyleliteralstrong{interpo\_choice} -- the interpolation type (int: 0,1,2 or 3). See grid\_and\_interpo() for mroe details.

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path to where to save the image

\item {} 
\sphinxstyleliteralstrong{save\_fig1d} -- create and save the figure related to the loading of the data (profile and so on)

\item {} 
\sphinxstyleliteralstrong{pro\_add} -- the number of addictional profile (one used for interpolation\_choice 1 and 2)

\item {} 
\sphinxstyleliteralstrong{q} -- used in the second thread

\item {} 
\sphinxstyleliteralstrong{print\_cmd} -- if True the print command is directed in the cmd, False if directed to the GUI

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- the options to crete the figure if save\_fig1d is True

\end{itemize}

\end{description}\end{quote}

** Technical comments**

This function redirect the sys.stdout. The point of doing this is because this function will be call by the GUI or
by the cmd. If it is called by the GUI, we want the output to be redirected to the windows for the log under HABBY.
If it is called by the cmd, we want the print function to be sent to the command line. We make the switch here.

\end{fulllineitems}

\index{open\_hecras() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.open_hecras}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{open\_hecras}}{\emph{geo\_file}, \emph{res\_file}, \emph{path\_geo}, \emph{path\_res}, \emph{path\_im}, \emph{save\_fig=False}, \emph{fig\_opt={[}{]}}}{}
This function will open HEC-RAS outputs, i.e. the .geo file and the outputs (either .XML, .sdf or .rep) from HEC-RAS.
All arguments from this function are string.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{geo\_file} -- the name of .goX (example .go3) file which is an output from hec-ras containg the profile data

\item {} 
\sphinxstyleliteralstrong{res\_file} -- the name of O0X.xml file for the name of the .sdf file  or the name of the .rep file (output data)

\item {} 
\sphinxstyleliteralstrong{path\_res} -- path to the result file

\item {} 
\sphinxstyleliteralstrong{path\_geo} -- path to the geo file

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path to the folder where the images should be saved

\item {} 
\sphinxstyleliteralstrong{save\_fig} -- if True image is saved

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- the figure option is save\_fig is True

\end{itemize}

\item[{Returns}] \leavevmode
coord\_pro (for each profile, x,y,elev, dist along the profile), vh\_pro
(for each profile, dist along the profile, water height, velocity). Both variable are a list of numpy array.

\end{description}\end{quote}

\sphinxstylestrong{How to obtain the input files}

To obtain the xml file in HEC-RAS version 4:
\begin{itemize}
\item {} 
open the project in HEC-RAS.

\item {} 
click on File , then export geometry and result (RAS Mapper), then OK

\end{itemize}

To obtain the sdf file in HEC-RAS version 5 which should be used if the model is georeferenced:
\begin{itemize}
\item {} 
click on File, then Export GIS data

\item {} 
Export all reaches (select Reaches to export -. Full List -\textgreater{} Ok)

\item {} 
Export all needed profile (select Profile to export -\textgreater{} Select all -\textgreater{} ok)

\end{itemize}

To obtain the report file .rep in HEC-RAS version which should be used if the model is NOT geo-referenced
\begin{itemize}
\item {} 
click on File, generate report

\item {} 
Select Flow data and Geometry data in input data and, in Specific Table, select Flow distribution and
Cross section Table

\end{itemize}

\sphinxstylestrong{Technical comments}

This is function which loads the hec\_ras inputs in 1D for the version 4 and 5 of HEC-RAS. It accepts different type
of hec-ras output as input and calls the appropriate sub-function for each input file.  The geometrical data is
always given in the geo file (with the extension g01, G01, g02, G02, g03, etc.). The output data can be in an xml
file for the hec-ras in the version 4, an sdf file for hec-ras in version 5 or a .rep file in the version 5 if the
model is not georeferenced. The xml file is the format which has been tested the most.

First, it loads the geometrical data. Then it select the function to load the output data and loads it. Then, it
transforms the loaded data in a (x,y) coordinates system. Indeed, most of the data in hec-ras is given by indicating
a profile (which crossed the modelled river) and the distance along this profile. For HABBY, it is better to get
(x,y) coordinates. Then it create figure if asked by the switch “save\_fig”. Finally, it updates the forms of the
output to be coherent with the dist\_velocity\_hecras function.  This way, in HABBY, the output from mascaret and
rubar after the velocity distribution have the same form than the output from hec-ras, which is useful afterwards
to save all these data in the hdf5 file.

\end{fulllineitems}

\index{open\_repfile() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.open_repfile}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{open\_repfile}}{\emph{report\_file}, \emph{reach\_name}, \emph{path}, \emph{data\_profile}, \emph{data\_bank}}{}
A function to open the report file (.rep) from HEC-RAS. To obtain the report file, see the doc of the function
open\_hecras.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{report\_file} -- a string with the name of the report file (.rep)

\item {} 
\sphinxstyleliteralstrong{reach\_name} -- a list of string containing the name of the reaches/rivers in the order of the geo file,
which might not be the order of the sdf file.

\item {} 
\sphinxstyleliteralstrong{path} -- the path where the report file is stored (string)

\item {} 
\sphinxstyleliteralstrong{data\_profile} -- the data from each profile from the geofile (output from the open\_geofile function)

\item {} 
\sphinxstyleliteralstrong{data\_bank} -- the position of the bank limit (output from the open\_geofile function)

\end{itemize}

\item[{Returns}] \leavevmode
velocity and the water surface elevation for each river profiles in a list of np.array,
the number of simulation (int) and the name of the river profile (list of string)

\end{description}\end{quote}

\sphinxstylestrong{Technical comments and walk-through}

This function is used to open output from models which were not geo-referenced in hec-ras v5. It cannot be used if
the model was georeferenced (or at least one should make some tests before).

First, we obtain the water height. Then, we obtain the number of time step (which is called the number of
simulation by hec-ras). To get the number of time step, we count each outputs given (one by profiles) and we
divided it by the number of profile in the river. It is a bit indirect, but I did not find a simpler solution.

We get the name of each profile and reach. Then, we get the velocity data. We have in a case which is not
geo-referenced. By consequence, there are only three velocities: one the left bank, one in the main river channel
and one the right bank.  Next we get the distance along the profile for these three velocities. Finally, we use
the function reoder\_reach for the same reason than in open\_sdffile and open\_xml.

\end{fulllineitems}

\index{open\_sdffile() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.open_sdffile}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{open\_sdffile}}{\emph{sdf\_file}, \emph{reach\_name}, \emph{path}}{}
This is a function to load .sdf file from HEC-RAS v5 used if the model is georeferenced. To find how to obtain the
sdf file, read the doc of open\_hecras.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{sdf\_file} -- the name of the sdf file (string)

\item {} 
\sphinxstyleliteralstrong{reach\_name} -- a list of string containing the name of the reaches/rivers in the order of the geo file
which might not be the one of the sdf file. Output from open\_geofile.

\item {} 
\sphinxstyleliteralstrong{path} -- the path where the file is stored (string)

\end{itemize}

\item[{Returns}] \leavevmode
velocity, water height, river\_name, number of  time step (nb\_sim)

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

To strat loading the sdf file, we open the sdf file. It is mostly a text file. Then we find velocity data and we
pass this velocity data from string to float. The process is a bit similar to the one used in the function
open\_geofile with a healthy dose of regular expressions. We do this again for height data.

We also extract the name of the river, reaches and profile. The number of simulation (nb\_sim) is a bit confusing
for a variable name. In fact, it is the number of time step. Hec-Ras considers that one simulation is the simulation
for one time step. Hence, nb\_sim is more or less nb\_timestep.

As in the xml file, we finally re-order the data as in the geo file. Indeed, it is possible to have different order
between the reaches in the geo file and in the sdf file. Here, we use the function reorder\_reach for this.

\end{fulllineitems}

\index{open\_xmlfile() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.open_xmlfile}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{open\_xmlfile}}{\emph{xml\_file}, \emph{reach\_name}, \emph{path}}{}
This function open the xml file from HEC-RAS v4 to get the velocity and water surface elevation. To know how to
obtain this xml file, read the doc of open\_hecras.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{xml\_file} -- the name of O0X.xml file from HEC-RAS. (string)

\item {} 
\sphinxstyleliteralstrong{reach\_name} -- a list of string containing the name of the reaches/rivers in the order of the geo file
which might not be the one of the xml file.

\item {} 
\sphinxstyleliteralstrong{path} -- path to the xml file (string)

\end{itemize}

\item[{Returns}] \leavevmode
velocity and the water surface elevation for each river profiles (list of np.array),
the number of simulation(int) and the name of the river profile (list of string)

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

To load the xml file, we first call the load\_xml function. It is a function which check that the xml file is well
formed and which return the “root” part fo the xml. With this “root”, it is possible to load other part of the xml
file using the Etree module.

Then, we load the velocity and water height data from the xml file. We also load the name of the profiles and of
the reach names.  Next, we pass the data into float. For each velocity of height point, we get its position along
the profile (see below for format) and the value at this point.

Finally, we re-order the data as in the geo file. Indeed, it is possible to have different order between the reaches
in the geo file and in the xml file. The last part of this function is there to order all the data as in the geo
file. There is a function reorder\_reach which does something similar, but could not be used by the output from the
xml file (it is slighty different). However the reorder\_reach function and this part of the open\_xml function is
very similar.

\end{fulllineitems}

\index{pass\_in\_float\_from\_geo() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.pass_in_float_from_geo}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{pass\_in\_float\_from\_geo}}{\emph{data\_str}, \emph{len\_number}}{}
This is a function to pass the string data into float for open\_geofile() and open\_sdffile(). It is in a function
because it is possible that two number are not separated by a space in the input data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{data\_str} -- the data in a string form

\item {} 
\sphinxstyleliteralstrong{len\_number} -- the number of digit for one number (int)

\end{itemize}

\item[{Returns}] \leavevmode
a np.array of float with 2 columns  (x,y) or (x,z)

\end{description}\end{quote}

\end{fulllineitems}

\index{reorder\_reach() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.reorder_reach}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{reorder\_reach}}{\emph{wse}, \emph{vel}, \emph{riv\_name}, \emph{reach\_name}, \emph{reach\_str}, \emph{stream\_str}, \emph{nb\_sim}}{}
The order of the reach in HABBY is in the order given in the geo file. However, it can be given in any order
in the other file. (xml, sdf, rep,...). This function re-order the reaches based on their name.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{wse} -- water height data (list of np.array for each profile)

\item {} 
\sphinxstyleliteralstrong{vel} -- velocity data (list of np.array for each profile)

\item {} 
\sphinxstyleliteralstrong{riv\_name} -- the name of the profile (yeah I know it is not really logical as a name)

\item {} 
\sphinxstyleliteralstrong{reach\_name} -- the name of the reach and stream (stream,reach) in the geo file order

\item {} 
\sphinxstyleliteralstrong{reach\_str} -- the name of the reach in the anaylsed file order

\item {} 
\sphinxstyleliteralstrong{stream\_str} -- the name of the stream in the anaylsed file order

\item {} 
\sphinxstyleliteralstrong{nb\_sim} -- the number of simulation

\end{itemize}

\item[{Returns}] \leavevmode
wse, vel, riv\_name all re-ordered

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

The reach name should not have white space at the end/start but can have white space into them.

\end{fulllineitems}

\index{update\_output() (in module src.Hec\_ras06)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.Hec_ras06.update_output}}\pysiglinewithargsret{\sphinxcode{src.Hec\_ras06.}\sphinxbfcode{update\_output}}{\emph{zone\_v}, \emph{coord\_pro\_old}, \emph{data\_profile}, \emph{xy\_h}, \emph{nb\_pro\_reach\_old}}{}
This function updates the form of the output so it is coherent with mascaret and rubar after the lateral
distribution of velocity for these two models. There are three important changes. First, coord\_pro contains dist along
the profile (x) and height in addition to the coordinates. Secondly, vh\_pro contains only height if height is above
or equal to zero. Thirdly, a point is created at the water limits and v and height are given at the same points.
nb\_pro\_reach is also modified as in mascaret. We want to modify it so it start by zero and is additive, i.e., that
it gives total number of profile before, not the number of profile by reach.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{zone\_v} -- (x,y, dist along profile, v) for each time step. However, the zone are the one from the models.
They are different than the one from xy\_h, which is unpractical for the rest of HABBY.

\item {} 
\sphinxstyleliteralstrong{coord\_pro\_old} -- the (x,y) coordinate for the profile

\item {} 
\sphinxstyleliteralstrong{data\_profile} -- the distance along the porfile and height of each profile

\item {} 
\sphinxstyleliteralstrong{xy\_h} -- the water height

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach\_old} -- the number of the profile by reach in the old form.

\end{itemize}

\item[{Returns}] \leavevmode
coord\_pro, vh\_pro, nb\_pro\_reach

\end{description}\end{quote}

{[}doc to be finished{]}

\end{fulllineitems}



\subsection{Notes on hec-ras outputs}
\label{\detokenize{index:notes-on-hec-ras-outputs}}\begin{itemize}
\item {} 
Data in HEC-RAS can be geo-referenced or not georeferenced. It is advised to geo-reference
all model in HEC-RAS. If the model is not geo-referenced, the function makes some assumptions to
load the data: 1) the river profile are straight and perpendicular to the river.
2) the last profile is at the end of the river.

\item {} 
To geo-reference a model in hec\_ras: In the “geometric data” window, GIS tool, GIS Cut Line, Accept Display location, choose all profile

\item {} 
Numerical data are sometime not separated (0.4556 0.3453233.454 05.343). In this case, the number of digit is assumed to be 8 for the profile and 16 for the river coordinates.

\item {} 
Part of the profile can be vertical: The function also functions in this case.

\item {} 
There is sometimes more than one reach in the modelled river and these reaches sometimes form loops: The function load each reach one after the other.

\item {} 
The river reaches are sometimes not in the same order in the xml file and in the .goX file. The order of the .goX is used by the function. Reach are automatically re-ordered.

\item {} 
If the river is straight, the coordinates of the river are given differently. The function try to load the river in the “straight” style if the usual style fail.

\item {} 
The .goX file includes data on bridges and culvert. Currently, the function neglects this information.

\item {} 
Sometimes distances between profiles are not given in the .goX file. The function neglects the distance data of this profile as long as it is not the last profile.

\item {} 
The velocity data for the end and the beginning of the river profile is indicated by a large number (example 1.23e35 or -1.234e36). The function considers that velocity info is situated at the start of the profile if x\textgreater{}-1e30 and at the end of the profile if x\textgreater{} 1e30.

\item {} 
There are two concepts called “profile” in HEC-RAS: The river profiles and the simulation profiles. The river profiles are the geometry perpendicular to the river and the simulation profile are the different simulations.

\item {} 
Data in many of the example cases of HEC-RAS are in foot and miles. 1 miles = 5280 foot, and not 1000 foot.

\end{itemize}


\section{Hec-ras model 2D}
\label{\detokenize{index:hec-ras-model-2d}}
in src/Hec\_ras2D.py

This module contains the functions used to load the outputs from the hec-ras model in 2D.
\phantomsection\label{\detokenize{index:module-src.hec_ras2D}}\index{src.hec\_ras2D (module)}\index{figure\_hec\_ras2d() (in module src.hec\_ras2D)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.hec_ras2D.figure_hec_ras2d}}\pysiglinewithargsret{\sphinxcode{src.hec\_ras2D.}\sphinxbfcode{figure\_hec\_ras2d}}{\emph{v\_all, h\_all, elev\_all, coord\_p\_all, coord\_c\_all, ikle\_all, path\_im, time\_step={[}0{]}, flow\_area={[}0{]}, max\_point=-99}}{}
This is a function to plot figure of the output from hec-ras 2D. This function is only used to debug, not directly by HABBY.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{v\_all} -- a list of np array representing the velocity at the center of the cells

\item {} 
\sphinxstyleliteralstrong{h\_all} -- a list of np array representing the water depth at the center of the cells

\item {} 
\sphinxstyleliteralstrong{elev\_all} -- a list of np array representing the mimium elevation of each cells

\item {} 
\sphinxstyleliteralstrong{coord\_p\_all} -- a list of np array representing the coordinates of the points of the grid

\item {} 
\sphinxstyleliteralstrong{coord\_c\_all} -- a list of np array representing the coordinates of the centers of the grid

\item {} 
\sphinxstyleliteralstrong{ikle\_all} -- a list of np array representing the connectivity table
one array by flow area

\item {} 
\sphinxstyleliteralstrong{time\_step} -- which time\_step should be plotted (default, the first one)

\item {} 
\sphinxstyleliteralstrong{flow\_area} -- which flow\_area should be plotted (default, the first one)

\item {} 
\sphinxstyleliteralstrong{max\_point} -- the number of cell to be drawn when reconstructing the grid (it might long)

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where the figure should be saved

\end{itemize}

\end{description}\end{quote}

\sphinxstylestrong{Technical comment}

This function creates three figures which represent: a) the grid of the loaded models b) the water height and
c) the velocity.

The two last figures will be modified when the data will be loaded by node and not by cells. So we will not explai
n them here as they should be re-written.

The first figure is used to plot the gird. If we would plot the grid by drawing one side of each triangle
separately, it would be very long to draw. To optimize the process, we use the prepare\_grid function.

\end{fulllineitems}

\index{get\_triangular\_grid\_hecras() (in module src.hec\_ras2D)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.hec_ras2D.get_triangular_grid_hecras}}\pysiglinewithargsret{\sphinxcode{src.hec\_ras2D.}\sphinxbfcode{get\_triangular\_grid\_hecras}}{\emph{ikle\_all}, \emph{coord\_c\_all}, \emph{point\_all}, \emph{h}, \emph{v}}{}
In Hec-ras, it is possible to have non-triangular cells, often rectangular cells This function transform the
``mixed'' grid to a triangular grid. For this,
it uses the centroid of each cell with more than three side and it create a triangle by side (linked with the
center of the cell). A similar function exists in rubar.py, but, as there are only one reach in rubar
and because ikle is different in hec-ras, it was hard to marge both functions together.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{ikle\_all} -- the connectivity table by reach (list of np.array)

\item {} 
\sphinxstyleliteralstrong{coord\_c\_all} -- the coordinate of the centroid of the cell by reach

\item {} 
\sphinxstyleliteralstrong{point\_all} -- the points of the grid

\item {} 
\sphinxstyleliteralstrong{h} -- data on water height by reach by time step

\item {} 
\sphinxstyleliteralstrong{v} -- data on velocity by reach by time step

\end{itemize}

\item[{Returns}] \leavevmode
the updated ikle, coord\_c (the center of the cell , must be updated ) and xy (the grid coordinate)

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_hec\_ras2d() (in module src.hec\_ras2D)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.hec_ras2D.load_hec_ras2d}}\pysiglinewithargsret{\sphinxcode{src.hec\_ras2D.}\sphinxbfcode{load\_hec\_ras2d}}{\emph{filename}, \emph{path}}{}
The goal of this function is to load 2D data from Hec-RAS in the version 5.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{filename} -- the name of the file containg the results of HEC-RAS in 2D. (string)

\item {} 
\sphinxstyleliteralstrong{path} -- the path where the file is (string)

\end{itemize}

\item[{Returns}] \leavevmode
velocity and height at the center of the cells, the coordinate of the point of the cells,
the coordinates of the center of the cells and the connectivity table. Each output is a list of numpy array
(one array by 2D flow area)

\end{description}\end{quote}

\sphinxstylestrong{How to obtain the input file}

The file neede as input is an hdf5 file (.hdf) created automatically by Hec-Ras. There are many .hdf created by
Hec-Ras. The one to choose is the one with the extension p0X.hdf (not g0x.hdf). It is usually the largest file in
the results folder.

\sphinxstylestrong{Technical comments}

Outputs from HEC-RAS in 2D are in the hdf5 format. However, it is not possible to directly use the output of HEC-RAS
as an hdf5 input for HABBY. Indeed, even if they are both in hdf5, the formats of the hdf5 files are different
(and would miss some important info for HABBY).  So we still need to load the HEC-RAS data in HABBY even if in 2D.

This function call the function get\_trianglar grid which is in rubar.py.

\sphinxstylestrong{Walk-through}

The name and path of the file is given as input to the load\_hec\_ras\_2D function. Usually this is done by the class
HEC\_RAS() in the GUI.  We load the file using the h5py module. This module opens and reads hdf5 file.

Then we can read different part of the hdf5 file when we know the address of it (this is a bit like a file system).
In hdf5 file of Hec-RAS, this first thing is to get the names of the flow area in “Geometry/2D Flow Area”. In
general, this is the name of each reach, but it could be lake or pond also. In an hdf5 file, to see the name of
the member in a group, use: list(``group''.keys())

Then, we go to “Geometry/2D Flow Area/\textless{}name\textgreater{}/FacePoint Coordinates” to get the points forming the grid.
We can also get the connectivity table (or ikle) to the path “Geometry/2D Flow Area/\textless{}name\textgreater{}/Cells Face Point Indexes”
We also get the elevations of the cells. However, this is just the minimum elevation of the cells, so it is
to be used only for a quick estimation. We then get the water depth by cell.
The velocity is given by face of the cells and is averaged to get it on the middle of the cells.

To get Hec-Ras data by nodes, it is necessary to intepolate the data. There is a function to do this in
manage\_grid\_8.

\end{fulllineitems}

\index{load\_hec\_ras\_2d\_and\_cut\_grid() (in module src.hec\_ras2D)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.hec_ras2D.load_hec_ras_2d_and_cut_grid}}\pysiglinewithargsret{\sphinxcode{src.hec\_ras2D.}\sphinxbfcode{load\_hec\_ras\_2d\_and\_cut\_grid}}{\emph{name\_hdf5}, \emph{filename}, \emph{path}, \emph{name\_prj}, \emph{path\_prj}, \emph{model\_type}, \emph{nb\_dim}, \emph{path\_hdf5}, \emph{q={[}{]}}, \emph{print\_cmd=False}, \emph{fig\_opt=\{\}}}{}
This function calls load\_hec\_ras\_2d and the cut\_2d\_grid function. Hence, it loads the data,
pass it from cell to node (as data output in hec-ras is by cells) and it cut the grid to
get only the wetted area. This was done before in the HEC\_RAS2D Class in hydro\_gui\_2.py, but it was necessary to
create a separate function to called this task in a second thread to avoid freezing the GUI.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{name\_hdf5} -- the base name of the created hdf5 (string)

\item {} 
\sphinxstyleliteralstrong{filename} -- the name of the file containg the results of HEC-RAS in 2D. (string)

\item {} 
\sphinxstyleliteralstrong{path} -- the path where the file is (string)

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- the name of the project (string)

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path of the project

\item {} 
\sphinxstyleliteralstrong{model\_type} -- the name of the model such as Rubar, hec-ras, etc. (string)

\item {} 
\sphinxstyleliteralstrong{nb\_dim} -- the number of dimension (model, 1D, 1,5D, 2D) in a float

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- A string which gives the adress to the folder in which to save the hdf5

\item {} 
\sphinxstyleliteralstrong{q} -- used by the second thread to get the error back to the GUI at the end of the thread

\item {} 
\sphinxstyleliteralstrong{print\_cmd} -- If True will print the error and warning to the cmd. If False, send it to the GUI.

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- the figure option, used here to get the minimum water height to have a wet node (can be \textgreater{} 0)

\end{itemize}

\end{description}\end{quote}

** Technical comments**

This function redirect the sys.stdout. The point of doing this is because this function will be call by the GUI or
by the cmd. If it is called by the GUI, we want the output to be redirected to the windoows for the log under HABBY.
If it is called by the cmd, we want the print function to be sent to the command line.

\end{fulllineitems}

\index{main() (in module src.hec\_ras2D)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.hec_ras2D.main}}\pysiglinewithargsret{\sphinxcode{src.hec\_ras2D.}\sphinxbfcode{main}}{}{}
Used to test this module independantly of HABBY.

\end{fulllineitems}

\index{prepare\_grid() (in module src.hec\_ras2D)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.hec_ras2D.prepare_grid}}\pysiglinewithargsret{\sphinxcode{src.hec\_ras2D.}\sphinxbfcode{prepare\_grid}}{\emph{ikle}, \emph{coord\_p}, \emph{max\_point=-99}}{}
This is a function to put in the new form the data forming the grid to accelerate the plotting of the grid. This function creates
a list of points of the grid which are re-ordered compared to the usual list of grid point (the variable coord\_p
here). These points are reordered so that it is possible to draw only one line to form the grid (one point can
appears more than once). The grid is drawn as one long line and not as a succession of small lines, which is
quicker. When this new list is created by prepare\_function(), it is send back to figure-hec\_ras\_2D and plotted.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{ikle} -- the connectivity table

\item {} 
\sphinxstyleliteralstrong{coord\_p} -- the coordinates of the point

\item {} 
\sphinxstyleliteralstrong{max\_point} -- if the grid is very big, it is possible to only plot the first points, up to max\_points (int)

\end{itemize}

\item[{Returns}] \leavevmode
a list of x and y coordinates ordered.

\end{description}\end{quote}

\end{fulllineitems}

\index{scatter\_plot() (in module src.hec\_ras2D)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.hec_ras2D.scatter_plot}}\pysiglinewithargsret{\sphinxcode{src.hec\_ras2D.}\sphinxbfcode{scatter\_plot}}{\emph{coord}, \emph{data}, \emph{data\_name}, \emph{my\_cmap}, \emph{s1}, \emph{t}}{}
The function to plot the scatter of the data. Will not be used in the final version, but can be useful to
plot data by cells.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord} -- the coordinates of the point

\item {} 
\sphinxstyleliteralstrong{data} -- the data to be plotted (np.array)

\item {} 
\sphinxstyleliteralstrong{data\_name} -- the name of the data (string)

\item {} 
\sphinxstyleliteralstrong{my\_cmap} -- the color map (string with matplotlib colormap name)

\item {} 
\sphinxstyleliteralstrong{s1} -- the size of the dot for the scatter

\item {} 
\sphinxstyleliteralstrong{t} -- the time step being plotted

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{Mascaret}
\label{\detokenize{index:mascaret}}
in src/mascaret.py

This module contains the functions used to load the outputs from the mascaret model.
\phantomsection\label{\detokenize{index:module-src.mascaret}}\index{src.mascaret (module)}\index{correct\_duplicate() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.correct_duplicate}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{correct\_duplicate}}{\emph{seq}, \emph{send\_warn}, \emph{idfun=None}}{}
It is possible to have a vertical line on a profile (different h, identical x). This is not possible for HABBY and
the 2D grid. So this function correct duplicates along the profile.

A similiar function exists in rubar, for the case where input is (x,y) coordinates and not distance along the profile.
This function is inspired by \url{https://www.peterbe.com/plog/uniqifiers-benchmark}

It should be tested more as manage\_grid sometime still send warning about duplicate data in profile.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{seq} -- the list to be corrected (list)

\item {} 
\sphinxstyleliteralstrong{send\_warn} -- a bool to avoid printing certains warning too many time

\item {} 
\sphinxstyleliteralstrong{idfun} -- support an optional transform function (not used)

\end{itemize}

\item[{Returns}] \leavevmode
the profile data without duplicate and the bollean which manages the warning.

\end{description}\end{quote}

\end{fulllineitems}

\index{define\_stream\_network() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.define_stream_network}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{define\_stream\_network}}{\emph{node\_number}, \emph{start\_node}, \emph{end\_node}, \emph{angles}, \emph{nb\_pro\_reach}, \emph{nb\_reach}, \emph{abcisse}}{}
This function extracts the stream network from the node and angle data. This is used if we have more than one
reach to define the geometry of the junction.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{node\_number} -- the start/end number of the reaches for each nodes (list of list)

\item {} 
\sphinxstyleliteralstrong{start\_node} -- the numbers indicating the start of each reach (list)

\item {} 
\sphinxstyleliteralstrong{end\_node} -- the numbers indicating the end of each reach

\item {} 
\sphinxstyleliteralstrong{angles} -- for each node the angle between the reach

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- the number of profile by reach

\item {} 
\sphinxstyleliteralstrong{nb\_reach} -- the number of reach

\item {} 
\sphinxstyleliteralstrong{abcisse} -- the distance along the river of each reach

\end{itemize}

\item[{Returns}] \leavevmode
the river coordinates and the unit vector indicating the river direction

\end{description}\end{quote}

\end{fulllineitems}

\index{figure\_mascaret() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.figure_mascaret}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{figure\_mascaret}}{\emph{coord\_pro, coord\_r, xhzv\_data, on\_profile, nb\_pro\_reach, fig\_opt, name\_pro, name\_reach, path\_im, pro, plot\_timestep={[}-1{]}, reach\_plot={[}0{]}}}{}
The function to plot the figures related to mascaret.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the cordinates (x,y,h, dist along the river) of the profiles

\item {} 
\sphinxstyleliteralstrong{coord\_r} -- the coordinate (x,y) of the river

\item {} 
\sphinxstyleliteralstrong{name\_pro} -- the name of the profile

\item {} 
\sphinxstyleliteralstrong{name\_reach} -- the name of the reach

\item {} 
\sphinxstyleliteralstrong{on\_profile} -- which result are on the profile. Some output are not the profiles.

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- the number of profile by reach (careful this is the number of profile, not the number of output)

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- the figure option

\item {} 
\sphinxstyleliteralstrong{xhzv\_data} -- the height and velcoity (x,h,v) list by time step

\item {} 
\sphinxstyleliteralstrong{profile} (\sphinxstyleliteralemphasis{pro}) -- which profile to be plotted (list of int)

\item {} 
\sphinxstyleliteralstrong{plot\_timestep} -- which timestep to be plotted

\item {} 
\sphinxstyleliteralstrong{reach\_plot} -- the reach to be plotted for the river view

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the figure

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_node() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.find_node}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{find\_node}}{\emph{node\_number}, \emph{reach\_to\_find}}{}
This function finds which node is a stream end or a stream start. It is associated by the function
define\_stream\_network()
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{node\_number} -- the list of list of the reaches linked with one node

\item {} 
\sphinxstyleliteralstrong{reach\_to\_find} -- the number indicating the start or end of the reach

\end{itemize}

\item[{Returns}] \leavevmode
the node number, ordered as in the xcas file

\end{description}\end{quote}

\end{fulllineitems}

\index{flat\_coord\_pro() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.flat_coord_pro}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{flat\_coord\_pro}}{\emph{coord\_pro}}{}
This function is not used anymroe.

The variable coord\_pro was a list of profile by reach. Finally, it was useful to have each profile one after the
other with accounting for the reach. So we stop to use this function whose goal was to pass from one form of
coord\_pro to the other form 9with or wihtout reach information).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{coord\_pro} -- the list of profile (x,y,h, dist along the river) by reach

\item[{Returns}] \leavevmode
coord\_pro\_f: a list of profile without the reach information. The list is flatten

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_geo\_name\_from\_xcas() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.get_geo_name_from_xcas}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{get\_geo\_name\_from\_xcas}}{\emph{file\_gen}, \emph{path\_gen}}{}
This function gets the name of the .geo file from the .xcas xml file. It is not used yet, but it could be useful
in the GUI to simplify the loading of mascaret. The user would not need to give the name of the geo and the xcas
files separetly. However, it is not written in yet.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_gen} -- the xcas file

\item {} 
\sphinxstyleliteralstrong{path\_gen} -- the path to the xcas file

\end{itemize}

\item[{Returns}] \leavevmode
the name of the .geo file (no path indicated)

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_name\_from\_cas() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.get_name_from_cas}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{get\_name\_from\_cas}}{\emph{file\_gen}, \emph{path\_gen}}{}
This function gets the name of the .geo file from the .cas text file. It is not used yet, but it could be useful
in the GUI to simplify the loading of mascaret. The user would not need to give the name of the geo and the cas
files separetly. However, it is not written in yet.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_gen} -- the name of .cas file (string)

\item {} 
\sphinxstyleliteralstrong{path\_gen} -- the path to the cas file (string

\end{itemize}

\item[{Returns}] \leavevmode
the name of the .geo file (no path indicated)

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_this\_res\_on\_the\_profile() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.is_this_res_on_the_profile}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{is\_this\_res\_on\_the\_profile}}{\emph{abscisse}, \emph{xhzv\_data\_all}}{}
The output of mascaret can be given at points of the river where there is no profile.
The function here says which results are on the profiles. All profiles are linked with an output, but some output
are not linked with a profile.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{abscisse} -- the distance between each profile (list of float)

\item {} 
\sphinxstyleliteralstrong{xhzv\_data\_all} -- the outputs from mascaret by time step

\end{itemize}

\item[{Returns}] \leavevmode
a list of bool of the length of xhzv\_data, True on profile, False not on profile

\end{description}\end{quote}

\sphinxstylestrong{Technical comment}

In the mascaret outputs, some rounding are suprising. For example, 0.49 can be transformed to 0.50 in an otehr file
(not 0.5). To avoid this type of problem, we says that outputs with a distance smaller than 3cm of the profile are
on the profile. If there are more than one output by profile, we takes the output which is the closest to the
profile.

\end{fulllineitems}

\index{load\_mascaret() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.load_mascaret}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{load\_mascaret}}{\emph{file\_gen}, \emph{file\_geo}, \emph{file\_res}, \emph{path\_gen}, \emph{path\_geo}, \emph{path\_res}}{}
The function is used to load the mascaret data. It load the geofile and the general file. Then, it re-forms the
geometrical data. Next, it loads the output data from mascaret. Fianally, it looks which outputs is close to
a profile and which outputs is not linked with a profile as there are some outputs given between profiles.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_gen} -- the xcas .xml file giving general info about the model (string)

\item {} 
\sphinxstyleliteralstrong{file\_geo} -- the file containting the profile data (.geo) (string)

\item {} 
\sphinxstyleliteralstrong{file\_res} -- the files containting the mascaret output in the Optyca format (.opt) (string)

\item {} 
\sphinxstyleliteralstrong{path\_gen} -- the path to the xcas file or .cas file (string). By default, choose the xcas file.

\item {} 
\sphinxstyleliteralstrong{path\_geo} -- the path to the geo file (string)

\item {} 
\sphinxstyleliteralstrong{path\_res} -- the path to the res file (string)

\end{itemize}

\item[{Returns}] \leavevmode
the coordinates of the profile (x,y,z, dist along the profile), the coordinate of the river (x,y), name of
reach and profile, data height and velocity (list by time step), list of bollean indicating which data is
on the profile and the number of profile by reach.

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_mascaret\_and\_create\_grid() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.load_mascaret_and_create_grid}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{load\_mascaret\_and\_create\_grid}}{\emph{name\_hdf5}, \emph{path\_hdf5}, \emph{name\_prj}, \emph{path\_prj}, \emph{model\_type}, \emph{namefile}, \emph{pathfile}, \emph{interpo\_choice}, \emph{manning\_data}, \emph{nb\_point\_vel}, \emph{show\_fig\_1D}, \emph{pro\_add}, \emph{q={[}{]}}, \emph{path\_im='.'}, \emph{print\_cmd=False}}{}
This function is used to load the mascaret data by calling the load\_mascaret() function and to create the grid
by calling the grid\_and\_interpo function in manage\_grid\_8. This function is called in a second thread by the class
Mascaret() in Hydro\_grid\_2(). It also distribute the velocity by calling dist\_vitess2.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{name\_hdf5} -- the name of the hdf5 to be created (string)

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- the path to the hdf5 to be created (string)

\item {} 
\sphinxstyleliteralstrong{model\_type} -- the name of the model (mascaret in most case, but given as argument in case we change
the form of the name)

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- the name of the project (string)

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path of the project

\item {} 
\sphinxstyleliteralstrong{namefile} -- the name of the geo file and the data file, which contains respectively geographical data and
the ouput data (see open\_hec\_ras() for more precision) -\textgreater{} list of string

\item {} 
\sphinxstyleliteralstrong{pathfile} -- the absolute path to the file chosen into namefile -\textgreater{} list of string

\item {} 
\sphinxstyleliteralstrong{interpo\_choice} -- the interpolation type (int: 0,1,2 or 3). See grid\_and\_interpo() for mroe details.

\item {} 
\sphinxstyleliteralstrong{manning\_data} -- Contains the manning data. It can be in an array form (variable) or as a float (constant)

\item {} 
\sphinxstyleliteralstrong{nb\_point\_vel} -- the number of velcoity point by whole profile

\item {} 
\sphinxstyleliteralstrong{show\_fig\_1D} -- A boolean. If True, image from the 1D data are created and savec

\item {} 
\sphinxstyleliteralstrong{q} -- used by the second thread.

\item {} 
\sphinxstyleliteralstrong{pro\_add} -- the number of addictional profile (one used for interpolation\_choice 1 and 2)

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the figure

\item {} 
\sphinxstyleliteralstrong{print\_cmd} -- if True the print command is directed in the cmd, False if directed to the GUI

\end{itemize}

\end{description}\end{quote}

** Technical comments**

This function redirect the sys.stdout. The point of doing this is because this function will be call by the GUI or
by the cmd. If it is called by the GUI, we want the output to be redirected to the windows for the log under HABBY.
If it is called by the cmd, we want the print function to be sent to the command line. We make the switch here.

\end{fulllineitems}

\index{main() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.main}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{main}}{}{}
Used to test this module separately.

\end{fulllineitems}

\index{open\_geo\_mascaret() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.open_geo_mascaret}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{open\_geo\_mascaret}}{\emph{file\_geo}, \emph{path\_geo}}{}
This function load the mascaret geo file. Generally, the profile are not geo-referenced when using this function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_geo} -- the name of the geo file (string)

\item {} 
\sphinxstyleliteralstrong{path\_geo} -- the path to the geo file (string)

\end{itemize}

\item[{Returns}] \leavevmode
the profile data (x,y), profile name (list of string),
brief name (list of string), the number of profile in each reach and distance along the river/abcisse (list)

\end{description}\end{quote}

\end{fulllineitems}

\index{open\_res\_file() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.open_res_file}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{open\_res\_file}}{\emph{file\_res}, \emph{path\_res}}{}
The function to load the output from mascaret (.opt file). The format is Optyca.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_res} -- the name of the .opt file (string)

\item {} 
\sphinxstyleliteralstrong{path\_res} -- the path to this file (string)

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{open\_rub\_file() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.open_rub_file}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{open\_rub\_file}}{\emph{file\_res}, \emph{path\_res}}{}
The function to open the binary output file from mascaret (.rub format).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_res} -- the name of the rub binary file (string)

\item {} 
\sphinxstyleliteralstrong{path\_res} -- the path to this file (string)

\end{itemize}

\item[{Returns}] \leavevmode
xhzv\_data, timestep

\end{description}\end{quote}

\sphinxstylestrong{Technical comment}

The binary output file was done using a program written in FORTRAN. So there are often suprising
octet which are added to the binary file. Be careful before changing anything.

\end{fulllineitems}

\index{profil\_coord\_non\_georef() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.profil_coord_non_georef}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{profil\_coord\_non\_georef}}{\emph{coord\_pro}, \emph{coord\_r}, \emph{nr}, \emph{nb\_pro\_reach}, \emph{bt=None}}{}
This function gets the coordinates (x,y) of the profile as masacret outputs are not georeferenced.

Hypothesis: The river and the profile are straight. The profile is perpendicular to the river.
The river pass at the minimum elevation of the river bed. If there is a distinction between the main bed the
secondary bed is given, we take the minimum elevation of the main bed

The origin of the coordinate system is the start of the river.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the coordinate of the profile. This variable is not in the general coordinate system,
just distance along the profile and bed elevation (p, dist, h)

\item {} 
\sphinxstyleliteralstrong{coord\_r} -- the river coordinates

\item {} 
\sphinxstyleliteralstrong{n} -- the vector indicating the river direction

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- the number of profile by reach (additive)

\item {} 
\sphinxstyleliteralstrong{bt} -- optional, it indicates which points in the profiles are in the minor/major bed

\end{itemize}

\item[{Returns}] \leavevmode
the velocity and height data, the timestep

\end{description}\end{quote}

\end{fulllineitems}

\index{river\_coord\_non\_georef\_from\_cas() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.river_coord_non_georef_from_cas}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{river\_coord\_non\_georef\_from\_cas}}{\emph{file\_gen}, \emph{path\_gen}, \emph{abcisse}, \emph{nb\_pro\_reach}}{}
Get the coordinates of the river based on the cas text file. If there are only one river, this is an easy task as
the river is straight. If there are more than one reach, the junctions and the angles between the reach sould be
managed using the define\_stream\_network function and the information in the .cas file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_gen} -- the .cas file whcih contains general info (string)

\item {} 
\sphinxstyleliteralstrong{path\_gen} -- the path to this file (string)

\item {} 
\sphinxstyleliteralstrong{abcisse} -- ditance along the profiles

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- the number of reach by profile

\end{itemize}

\item[{Returns}] \leavevmode
the river coordinate and the unit vector indicating the river direction

\end{description}\end{quote}

\end{fulllineitems}

\index{river\_coord\_non\_georef\_from\_xcas() (in module src.mascaret)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mascaret.river_coord_non_georef_from_xcas}}\pysiglinewithargsret{\sphinxcode{src.mascaret.}\sphinxbfcode{river\_coord\_non\_georef\_from\_xcas}}{\emph{file\_gen}, \emph{path\_gen}, \emph{abcisse}, \emph{nb\_pro\_reach}}{}
Get the coordinates of the river based on the xcas xml file. If there are only one river, this is an easy task as
the river is straight. If there are more than one reach, the junctions and the angles between the reach sould be
managed using the define\_stream\_network function and the information in the .xcas file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_gen} -- the .xcas file with the information concerning the reach (string)

\item {} 
\sphinxstyleliteralstrong{path\_gen} -- the path to the xcas file (string)

\item {} 
\sphinxstyleliteralstrong{abcisse} -- the distance along the river

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- the number of profile by reach

\end{itemize}

\item[{Returns}] \leavevmode
coord\_r the coordinate of the river

\end{description}\end{quote}

\end{fulllineitems}



\section{River 2D}
\label{\detokenize{index:river-2d}}
in src/river2D.py

This module contains the functions used to load the outputs from the River2D model.
\phantomsection\label{\detokenize{index:module-src.river2d}}\index{src.river2d (module)}\index{figure\_river2d() (in module src.river2d)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.river2d.figure_river2d}}\pysiglinewithargsret{\sphinxcode{src.river2d.}\sphinxbfcode{figure\_river2d}}{\emph{xyzhv}, \emph{ikle}, \emph{path\_im}, \emph{t=0}}{}
A function to plot the output from river 2d. Need hec-ras2d as import because it re-used most of the plot from this
script. It is only used to debug. It is not used directly by HABBY.

Plot only one time step because river 2d output have one file by time step.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{xyzhv} -- the x,y, coordinates of the node (h,v are nodal output in river 2d), the river bed, the water height
and the velocity (one data by column, row are node)

\item {} 
\sphinxstyleliteralstrong{ikle} -- connectivity table

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the figure

\item {} 
\sphinxstyleliteralstrong{t} -- the time step which is being plotted

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_rid\_of\_lines() (in module src.river2d)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.river2d.get_rid_of_lines}}\pysiglinewithargsret{\sphinxcode{src.river2d.}\sphinxbfcode{get\_rid\_of\_lines}}{\emph{datahere}, \emph{nb\_data}}{}
There are lines which are useless in the cdg file. This function is used to correct ikle and data\_node
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{datahere} -- the data with the empty lines

\item {} 
\sphinxstyleliteralstrong{nb\_data} -- nb\_node or nb\_el

\end{itemize}

\item[{Returns}] \leavevmode
datahere wihtout the useless lines

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_river2d\_and\_cut\_grid() (in module src.river2d)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.river2d.load_river2d_and_cut_grid}}\pysiglinewithargsret{\sphinxcode{src.river2d.}\sphinxbfcode{load\_river2d\_and\_cut\_grid}}{\emph{name\_hdf5}, \emph{namefiles}, \emph{paths}, \emph{name\_prj}, \emph{path\_prj}, \emph{model\_type}, \emph{nb\_dim}, \emph{path\_hdf5}, \emph{q={[}{]}}, \emph{print\_cmd=False}, \emph{fig\_opt=\{\}}}{}
This function loads the river2d data and cut the grid to the wet area. Originally, this function was in the class
River2D() in hydro\_GUI\_2. This function was added as it was practical to have a second thread to avoid freezing
the GUI.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{name\_hdf5} -- the base name of the created hdf5 (string)

\item {} 
\sphinxstyleliteralstrong{namefiles} -- the names of all the cdg file (list of string)

\item {} 
\sphinxstyleliteralstrong{paths} -- the path to the files (list of string).

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- the name of the project (string)

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path of the project

\item {} 
\sphinxstyleliteralstrong{model\_type} -- the name of the model such as Rubar, hec-ras, etc. (string)

\item {} 
\sphinxstyleliteralstrong{nb\_dim} -- the number of dimension (model, 1D, 1,5D, 2D) in a float

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- A string which gives the adress to the folder in which to save the hdf5

\item {} 
\sphinxstyleliteralstrong{q} -- used to send the error back from the second thread (can be used to send other variable too)

\item {} 
\sphinxstyleliteralstrong{print\_cmd} -- if True the print command is directed in the cmd, False if directed to the GUI

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- the figure option, used here to get the minimum water height to have a wet node (can be \textgreater{} 0)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_river2d\_cdg() (in module src.river2d)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.river2d.load_river2d_cdg}}\pysiglinewithargsret{\sphinxcode{src.river2d.}\sphinxbfcode{load\_river2d\_cdg}}{\emph{file\_cdg}, \emph{path}}{}
The file to load the output data from River2D. Careful the input data of River2D has the same ending and nearly
the same format as the output. However, it is nessary to have the output here. River2D gives one cdg. file by timestep.
Hence, this function read only one timeste. HABBY read all time step by calling this function once for each time step.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_cdg} -- the name of the cdg file (string)

\item {} 
\sphinxstyleliteralstrong{path} -- the path to this file (string).

\end{itemize}

\item[{Returns}] \leavevmode
the velocity and height data, the coordinate and the connectivity table.

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module src.river2d)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.river2d.main}}\pysiglinewithargsret{\sphinxcode{src.river2d.}\sphinxbfcode{main}}{}{}
Used to test this module.

\end{fulllineitems}



\section{Rubar}
\label{\detokenize{index:rubar}}
in src/rubar.py

This module contains the functions used to load the Rubar data in 2D and 1D.
\phantomsection\label{\detokenize{index:module-src.rubar}}\index{src.rubar (module)}\index{correct\_duplicate\_xy() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.correct_duplicate_xy}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{correct\_duplicate\_xy}}{\emph{seq3D}, \emph{send\_warn}, \emph{idfun=None}}{}
It is possible to have a vertical line on a profile (different h, identical x). This is not possible for HABBY and
the 2D grid. So this function correct duplicates along the profile.

A similiar function exists in mascaret, for the case where the input is the distance along the profile and not
(x,y) coordinates. This function is inspired by \url{https://www.peterbe.com/plog/uniqifiers-benchmark}.

It should be tested more as manage\_grid sometime still send warning about duplicate data in profile.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{seq3D} -- the list to be corrected in this case (x,y,z,dist along the profile)

\item {} 
\sphinxstyleliteralstrong{send\_warn} -- a bool to avoid printing the warning too many time

\item {} 
\sphinxstyleliteralstrong{idfun} -- support an optional transform function (not tested)

\end{itemize}

\item[{Returns}] \leavevmode
the list wihtout duplicate and the boolean which helps manage the warnings

\end{description}\end{quote}

\end{fulllineitems}

\index{figure\_rubar1d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.figure_rubar1d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{figure\_rubar1d}}{\emph{coord\_pro, lim\_riv, data\_xhzv, name\_profile, path\_im, pro, plot\_timestep, nb\_pro\_reach={[}0, 10000000000{]}, fig\_opt=\{\}}}{}
The function to plot the loaded RUBAR 1D data (Rubar BE).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the coordinate of the profile (x, y, z, dist along the river)

\item {} 
\sphinxstyleliteralstrong{lim\_riv} -- the right bank, river center, left bank

\item {} 
\sphinxstyleliteralstrong{data\_xhzv} -- the data by time step with x the distance along the river, h the water height and v the vlocity

\item {} 
\sphinxstyleliteralstrong{cote} -- the altitude of the river center

\item {} 
\sphinxstyleliteralstrong{name\_profile} -- the name of the profile

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the image

\item {} 
\sphinxstyleliteralstrong{pro} -- the profile number which should be plotted

\item {} 
\sphinxstyleliteralstrong{plot\_timestep} -- which timestep should be plotted

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- the number of profile by reach

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- the dictionnary with the figure option

\end{itemize}

\item[{Returns}] \leavevmode
none

\end{description}\end{quote}

\end{fulllineitems}

\index{figure\_rubar2d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.figure_rubar2d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{figure\_rubar2d}}{\emph{xy, coord\_c, ikle, v, h, path\_im, time\_step={[}-1{]}}}{}
This functions plots the rubar 2d data. This function is only used to debug. It is not used direclty by Habby.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{xy} -- coordinates of the points

\item {} 
\sphinxstyleliteralstrong{coord\_c} -- the center of the point

\item {} 
\sphinxstyleliteralstrong{ikle} -- connectivity table

\item {} 
\sphinxstyleliteralstrong{v} -- speed

\item {} 
\sphinxstyleliteralstrong{h} -- height

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the figure

\item {} 
\sphinxstyleliteralstrong{time\_step} -- The time step which will be plotted

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_triangular\_grid() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.get_triangular_grid}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{get\_triangular\_grid}}{\emph{ikle}, \emph{coord\_c}, \emph{xy}, \emph{h}, \emph{v}}{}
In Rubar, it is possible to have non-triangular cells. It is possible to have a grid composed of a mix
of pentagonal, 4-sided and triangualr cells. This function transform the ``mixed'' grid to a triangular grid. For this,
it uses the centroid of each cell with more than three side and it create a triangle by side (linked with the
center of the cell). A similar function exists in hec-ras2D.py, but, as there is only one reach in rubar
and because ikle is different in hec-ras, it was hard to marge both functions together.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{ikle} -- the connectivity table (list)

\item {} 
\sphinxstyleliteralstrong{coord\_c} -- the coordinate of the centroid of the cell (list)

\item {} 
\sphinxstyleliteralstrong{xy} -- the points of the grid (np.array)

\item {} 
\sphinxstyleliteralstrong{h} -- data on water height

\item {} 
\sphinxstyleliteralstrong{v} -- data on velocity

\end{itemize}

\item[{Returns}] \leavevmode
the updated ikle, coord\_c (the center of the cell , must be updated ) and xy (the grid coordinate)

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_coord\_1d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.load_coord_1d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{load\_coord\_1d}}{\emph{name\_rbe}, \emph{path}}{}
the function to load the rbe file, which is an xml file. The gives the geometry of the river system.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{name\_rbe} -- The name fo the rbe file (string)

\item {} 
\sphinxstyleliteralstrong{path} -- the path to this file (string)

\end{itemize}

\item[{Returns}] \leavevmode
the coordinates of the profiles and the coordinates of the right bank, center of the river, left bank
(list of np.array with x,y,z coordinate), name of the profile (list of string), dist along the river (list of float)
number of cells (int)

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_dat\_2d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.load_dat_2d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{load\_dat\_2d}}{\emph{geofile}, \emph{path}}{}
This  function is used to load the geomtery info for the 2D case, using the .dat file
The .dat file has the same role than the .mai file but with more information (number of side and more
complicated connectivity table).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{geofile} -- the .dat file which contain the connectivity table and the (x,y)

\item {} 
\sphinxstyleliteralstrong{path} -- the path to this file

\end{itemize}

\item[{Returns}] \leavevmode
connectivity table, point coordinates, coordinates of the cell centers

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_data\_1d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.load_data_1d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{load\_data\_1d}}{\emph{name\_data\_vh}, \emph{path}, \emph{x}}{}
This function loads the output data for Rubar BE (in 1D). The geometry data should be loaded before using this function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{name\_data\_vh} -- the name of the profile.ETUDE file (string)

\item {} 
\sphinxstyleliteralstrong{path} -- the path to this file

\item {} 
\sphinxstyleliteralstrong{x} -- the distance along the river (from the .geo file)

\end{itemize}

\item[{Returns}] \leavevmode
data x, velocity height, cote for each time step (list of np.array), time step

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_mai\_1d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.load_mai_1d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{load\_mai\_1d}}{\emph{mailfile}, \emph{path}}{}
This function is not used anymore. It was used to load the coordinate of the 1D data. It might become useful again
in the case where we found a Rubar model with more than one reach (which we do not have yet).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{mailfile} -- the name of the file which contain the (x,z) data

\item {} 
\sphinxstyleliteralstrong{path} -- the path to this file

\end{itemize}

\item[{Returns}] \leavevmode
x of the river, np.array and the number of mail

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_mai\_2d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.load_mai_2d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{load\_mai\_2d}}{\emph{geofile}, \emph{path}}{}
The function to load the geomtery info for the 2D case when we use the .mai file. It would also be possible
to use the .dat file. In fact, it is advised to use the dat file when possible as there are more info in the .dat file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{geofile} -- the .mai file which contain the connectivity table and the (x,y)

\item {} 
\sphinxstyleliteralstrong{path} -- the path to this file

\end{itemize}

\item[{Returns}] \leavevmode
connectivity table, point coordinates, coordinates of the cell centers

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_rubar1d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.load_rubar1d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{load\_rubar1d}}{\emph{geofile}, \emph{data\_vh}, \emph{pathgeo}, \emph{pathdata}, \emph{path\_im}, \emph{savefig}, \emph{fig\_opt={[}{]}}}{}
the function to load the RUBAR BE data (in 1D).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{geofile} -- the name of .rbe file which gives the coordinates of each profile (string)

\item {} 
\sphinxstyleliteralstrong{data\_vh} -- the name of the profile.ETUDE file which contains the height and velocity data (string)

\item {} 
\sphinxstyleliteralstrong{pathgeo} -- the path to the geofile - string

\item {} 
\sphinxstyleliteralstrong{pathdata} -- the path to the data\_vh file

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the file where to save the image

\item {} 
\sphinxstyleliteralstrong{savefig} -- a boolean. If True create and save the figure.

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- A dictionarry with the figure option

\end{itemize}

\item[{Returns}] \leavevmode
coordinates of the profile (x,y,z dist along the profile) coordinates (x,y) of the river and the bed,
data xhzv by time step where x is the distance along the river, h the water height, z the elevation of the bed
and v the velocity

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_rubar1d\_and\_create\_grid() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.load_rubar1d_and_create_grid}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{load\_rubar1d\_and\_create\_grid}}{\emph{name\_hdf5}, \emph{path\_hdf5}, \emph{name\_prj}, \emph{path\_prj}, \emph{model\_type}, \emph{namefile}, \emph{pathfile}, \emph{interpo\_choice}, \emph{manning\_data}, \emph{nb\_point\_vel}, \emph{show\_fig\_1D}, \emph{pro\_add}, \emph{q={[}{]}}, \emph{path\_im='.'}, \emph{print\_cmd=False}}{}
This function is used to load rubar 1d data by calling the load\_rubar1d() function and to create the grid
by calling the grid\_and\_interpo function in manage\_grid\_8. This function is called in a second thread by the class
Rubar() in Hydro\_grid\_2(). It also distribute the velocity by calling dist\_vitess2.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{name\_hdf5} -- the name of the hdf5 to be created (string)

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- the path to the hdf5 to be created (string)

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- the name of the project (string)

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path of the project

\item {} 
\sphinxstyleliteralstrong{model\_type} -- the name of the model (rubar in most case, but given as argument in case we change
the form of the name)

\item {} 
\sphinxstyleliteralstrong{namefile} -- the name of the geo file and the data file, which contains respectively geographical data and
the ouput data (see open\_hec\_ras() for more precision) -\textgreater{} list of string

\item {} 
\sphinxstyleliteralstrong{pathfile} -- the absolute path to the file chosen into namefile -\textgreater{} list of string

\item {} 
\sphinxstyleliteralstrong{interpo\_choice} -- the interpolation type (int: 0,1,2 or 3). See grid\_and\_interpo() for mroe details.

\item {} 
\sphinxstyleliteralstrong{manning\_data} -- Contains the manning data. It can be in an array form (variable) or as a float (constant)

\item {} 
\sphinxstyleliteralstrong{nb\_point\_vel} -- the number of velcoity point by whole profile

\item {} 
\sphinxstyleliteralstrong{show\_fig\_1D} -- A boolean. If True, image from the 1D data are created and savec

\item {} 
\sphinxstyleliteralstrong{q} -- used by the second thread.

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the figure

\item {} 
\sphinxstyleliteralstrong{print\_cmd} -- if True the print command is directed in the cmd, False if directed to the GUI

\end{itemize}

\end{description}\end{quote}

** Technical comments**

This function redirect the sys.stdout. The point of doing this is because this function will be call by the GUI or
by the cmd. If it is called by the GUI, we want the output to be redirected to the windows for the log under HABBY.
If it is called by the cmd, we want the print function to be sent to the command line. We make the switch here.

\end{fulllineitems}

\index{load\_rubar2d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.load_rubar2d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{load\_rubar2d}}{\emph{geofile}, \emph{tpsfile}, \emph{pathgeo}, \emph{pathtps}, \emph{path\_im}, \emph{save\_fig}}{}
This is the function used to load the RUBAR data in 2D.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{geofile} -- the name of the .mai or .dat file which contains the connectivity table and the coordinates (string)

\item {} 
\sphinxstyleliteralstrong{tpsfile} -- the name of the .tps file (string)

\item {} 
\sphinxstyleliteralstrong{pathgeo} -- path to the geo file (string)

\item {} 
\sphinxstyleliteralstrong{pathtps} -- path to the tps file which contains the outputs (string)

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the figure (string)

\item {} 
\sphinxstyleliteralstrong{save\_fig} -- a boolean indicating if the figures should be created or not

\end{itemize}

\item[{Returns}] \leavevmode
velocity and height at the center of the cells, the coordinate of the point of the cells,
the coordinates of the center of the cells and the connectivity table.

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_rubar2d\_and\_create\_grid() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.load_rubar2d_and_create_grid}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{load\_rubar2d\_and\_create\_grid}}{\emph{name\_hdf5}, \emph{geofile}, \emph{tpsfile}, \emph{pathgeo}, \emph{pathtps}, \emph{path\_im}, \emph{name\_prj}, \emph{path\_prj}, \emph{model\_type}, \emph{nb\_dim}, \emph{path\_hdf5}, \emph{q={[}{]}}, \emph{print\_cmd=False}, \emph{fig\_opt=\{\}}}{}
This is the function used to load the RUBAR data in 2D, to pass the data from the cell to the node using
interpolation and to save the whole in an hdf5 format
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{name\_hdf5} -- the base name of the created hdf5 (string)

\item {} 
\sphinxstyleliteralstrong{geofile} -- the name of the .mai or .dat file which contains the connectivity table and the coordinates (string)

\item {} 
\sphinxstyleliteralstrong{tpsfile} -- the name of the .tps file (string)

\item {} 
\sphinxstyleliteralstrong{pathgeo} -- path to the geo file (string)

\item {} 
\sphinxstyleliteralstrong{pathtps} -- path to the tps file which contains the outputs (string)

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the figure (string)

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- the name of the project (string)

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path of the project

\item {} 
\sphinxstyleliteralstrong{model\_type} -- the name of the model such as Rubar, hec-ras, etc. (string)

\item {} 
\sphinxstyleliteralstrong{nb\_dim} -- the number of dimension (model, 1D, 1,5D, 2D) in a float

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- A string which gives the adress to the folder in which to save the hdf5

\item {} 
\sphinxstyleliteralstrong{q} -- used by the second thread to get the error back to the GUI at the end of the thread

\item {} 
\sphinxstyleliteralstrong{print\_cmd} -- if True the print command is directed in the cmd, False if directed to the GUI

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- the figure option, used here to get the minimum water height to have a wet node (can be \textgreater{} 0)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_tps\_2d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.load_tps_2d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{load\_tps\_2d}}{\emph{tpsfile}, \emph{path}, \emph{nb\_cell}}{}
The function to load the output data in the 2D rubar case. The geometry file (.mai or .dat) should be loaded before.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{tpsfile} -- the name of the file with the data for the 2d case

\item {} 
\sphinxstyleliteralstrong{path} -- the path to the tps file.

\item {} 
\sphinxstyleliteralstrong{nb\_cell} -- the number of cell extracted from the .mai file

\end{itemize}

\item[{Returns}] \leavevmode
v, h, timestep (all in list of np.array)

\end{description}\end{quote}

\end{fulllineitems}

\index{m\_file\_load\_coord\_1d() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.m_file_load_coord_1d}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{m\_file\_load\_coord\_1d}}{\emph{geofile\_name}, \emph{pathgeo}}{}
This function loads the m.ETUDE file which is based on .st format from cemagref. When we use the M.ETUDE file
instead of the rbe file, more than one reach can be studied but the center and side of the river is not
indicated anymore.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{geofile\_name} -- The name to the m.ETUDE file (string)

\item {} 
\sphinxstyleliteralstrong{pathgeo} -- the path to this file (string)

\end{itemize}

\item[{Returns}] \leavevmode
the coordinates of the profiles (list of np.array with x,y,z coordinate), name of the profile
(list of string), dist along the river (list of float), number of profile by reach

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module src.rubar)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.rubar.main}}\pysiglinewithargsret{\sphinxcode{src.rubar.}\sphinxbfcode{main}}{}{}
Used to test this module

\end{fulllineitems}



\section{Telemac}
\label{\detokenize{index:telemac}}
in src/selafin\_habby1.py

This module contains the functions used to load the Telemac data.
\phantomsection\label{\detokenize{index:module-src.selafin_habby1}}\index{src.selafin\_habby1 (module)}\index{Selafin (class in src.selafin\_habby1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src.selafin\_habby1.}\sphinxbfcode{Selafin}}{\emph{filename}}{}
Selafin file format reader for Telemac 2D. Create an object for reading data from a slf file.
Adapted from the original script `parserSELAFIN.py' from the open Telemac distribution.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{filename} -- the name of the binary Selafin file

\end{description}\end{quote}
\index{addcontent() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.addcontent}}\pysiglinewithargsret{\sphinxbfcode{addcontent}}{\emph{fileName}, \emph{times}, \emph{values}}{}
\end{fulllineitems}

\index{appendcoretimeslf() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.appendcoretimeslf}}\pysiglinewithargsret{\sphinxbfcode{appendcoretimeslf}}{\emph{t}}{}
\end{fulllineitems}

\index{appendcorevarsslf() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.appendcorevarsslf}}\pysiglinewithargsret{\sphinxbfcode{appendcorevarsslf}}{\emph{varsor}}{}
\end{fulllineitems}

\index{appendheaderslf() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.appendheaderslf}}\pysiglinewithargsret{\sphinxbfcode{appendheaderslf}}{}{}
Write the header file

\end{fulllineitems}

\index{getheaderfloatsslf() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.getheaderfloatsslf}}\pysiglinewithargsret{\sphinxbfcode{getheaderfloatsslf}}{}{}
Get the mesh coordinates

\end{fulllineitems}

\index{getheaderintegersslf() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.getheaderintegersslf}}\pysiglinewithargsret{\sphinxbfcode{getheaderintegersslf}}{}{}
Get dimensions and descritions (mesh)

\end{fulllineitems}

\index{getheadermetadataslf() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.getheadermetadataslf}}\pysiglinewithargsret{\sphinxbfcode{getheadermetadataslf}}{}{}
Get header information

\end{fulllineitems}

\index{gettimehistoryslf() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.gettimehistoryslf}}\pysiglinewithargsret{\sphinxbfcode{gettimehistoryslf}}{}{}
Get the timesteps

\end{fulllineitems}

\index{getvalues() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.getvalues}}\pysiglinewithargsret{\sphinxbfcode{getvalues}}{\emph{t}}{}
Get the values for the variables at time t

\end{fulllineitems}

\index{getvariablesat() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.getvariablesat}}\pysiglinewithargsret{\sphinxbfcode{getvariablesat}}{\emph{frame}, \emph{varindexes}}{}
Get the values for the variables at a particular time step

\end{fulllineitems}

\index{putcontent() (src.selafin\_habby1.Selafin method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.Selafin.putcontent}}\pysiglinewithargsret{\sphinxbfcode{putcontent}}{\emph{fileName}, \emph{times}, \emph{values}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{getendianfromchar() (in module src.selafin\_habby1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.getendianfromchar}}\pysiglinewithargsret{\sphinxcode{src.selafin\_habby1.}\sphinxbfcode{getendianfromchar}}{\emph{fileslf}, \emph{nchar}}{}~\begin{description}
\item[{Get the endian encoding}] \leavevmode
``\textless{}'' means little-endian
``\textgreater{}'' means big-endian

\end{description}

\end{fulllineitems}

\index{getfloattypefromfloat() (in module src.selafin\_habby1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.getfloattypefromfloat}}\pysiglinewithargsret{\sphinxcode{src.selafin\_habby1.}\sphinxbfcode{getfloattypefromfloat}}{\emph{fileslf}, \emph{endian}, \emph{nfloat}}{}
Get float precision

\end{fulllineitems}

\index{load\_telemac() (in module src.selafin\_habby1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.load_telemac}}\pysiglinewithargsret{\sphinxcode{src.selafin\_habby1.}\sphinxbfcode{load\_telemac}}{\emph{namefilet}, \emph{pathfilet}}{}
A function which load the telemac data using the Selafin class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{namefilet} -- the name of the selafin file (string)

\item {} 
\sphinxstyleliteralstrong{pathfilet} -- the path to this file (string)

\end{itemize}

\item[{Returns}] \leavevmode
the velocity, the height, the coordinate of the points of the grid, the connectivity table.

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_telemac\_and\_cut\_grid() (in module src.selafin\_habby1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.load_telemac_and_cut_grid}}\pysiglinewithargsret{\sphinxcode{src.selafin\_habby1.}\sphinxbfcode{load\_telemac\_and\_cut\_grid}}{\emph{name\_hdf5}, \emph{namefilet}, \emph{pathfilet}, \emph{name\_prj}, \emph{path\_prj}, \emph{model\_type}, \emph{nb\_dim}, \emph{path\_hdf5}, \emph{q={[}{]}}, \emph{print\_cmd=False}, \emph{fig\_opt=\{\}}}{}
This function calls the function load\_telemac and call the function cut\_2d\_grid(). Orginally, this function
was part of the TELEMAC class in Hydro\_GUI\_2.py but it was separated to be able to have a second thread, which
is useful to avoid freezing the GUI.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{name\_hdf5} -- the base name of the created hdf5 (string)

\item {} 
\sphinxstyleliteralstrong{namefilet} -- the name of the selafin file (string)

\item {} 
\sphinxstyleliteralstrong{pathfilet} -- the path to this file (string)

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- the name of the project (string)

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path of the project

\item {} 
\sphinxstyleliteralstrong{model\_type} -- the name of the model such as Rubar, hec-ras, etc. (string)

\item {} 
\sphinxstyleliteralstrong{nb\_dim} -- the number of dimension (model, 1D, 1,5D, 2D) in a float

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- A string which gives the adress to the folder in which to save the hdf5

\item {} 
\sphinxstyleliteralstrong{q} -- used by the second thread to get the error back to the GUI at the end of the thread

\item {} 
\sphinxstyleliteralstrong{print\_cmd} -- if True the print command is directed in the cmd, False if directed to the GUI

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- the figure option, used here to get the minimum water height to have a wet node (can be \textgreater{} 0)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_vel\_h() (in module src.selafin\_habby1)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.selafin_habby1.plot_vel_h}}\pysiglinewithargsret{\sphinxcode{src.selafin\_habby1.}\sphinxbfcode{plot\_vel\_h}}{\emph{coord\_p2, h, v, path\_im, timestep={[}-1{]}}}{}
a function to plot the velocity and height which are the output from TELEMAC. It is used to debug.
It is not used direclty by HABBY.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_p2} -- the coordinates of the point forming the grid

\item {} 
\sphinxstyleliteralstrong{h} -- the  water height

\item {} 
\sphinxstyleliteralstrong{v} -- the velocity

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where the image should be saved (string)

\item {} 
\sphinxstyleliteralstrong{timestep} -- which time step should be plotted

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{LAMMI}
\label{\detokenize{index:lammi}}
in src/lammi.py

This module contains functions used to load data from LAMMI. For more information on LAMMI, please see the pdf document \sphinxcode{LAMMI.pdf}
\phantomsection\label{\detokenize{index:module-src.lammi}}\index{src.lammi (module)}\index{check\_code\_change() (in module src.lammi)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.lammi.check_code_change}}\pysiglinewithargsret{\sphinxcode{src.lammi.}\sphinxbfcode{check\_code\_change}}{\emph{facies\_path}}{}
If we can find the habitat.txt file, we check that the conversion from EDF to Cemagref code was done as in HABBY.
In most case, the habiat.txt file will not be found. This is not a problem.
:param facies\_path: the path to the facies.txt file
:return: a boolean

\end{fulllineitems}

\index{compare\_lammi() (in module src.lammi)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.lammi.compare_lammi}}\pysiglinewithargsret{\sphinxcode{src.lammi.}\sphinxbfcode{compare\_lammi}}{\emph{filename\_habby}, \emph{filename\_lammi}, \emph{filename\_lammi\_sur}}{}
This function compares the SPU for the trut done by lammi and by HABBY (using hydrological lammi output). It is
not directly used by HABBY, but it can be useful to check the differences.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{filename\_habby} -- the name and path of the text file giving the spu from HABBY (spu\_xxx.txt)

\item {} 
\sphinxstyleliteralstrong{filename\_lammi} -- the name and the file of the lammi spu (FaciesTRF.txt)

\item {} 
\sphinxstyleliteralstrong{filename\_lammi\_sur} -- the name and the file of the lammi surface

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{coord\_lammi() (in module src.lammi)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.lammi.coord_lammi}}\pysiglinewithargsret{\sphinxcode{src.lammi.}\sphinxbfcode{coord\_lammi}}{\emph{dist\_all}, \emph{vel\_all}, \emph{height\_all}, \emph{sub\_all}, \emph{length\_all}}{}
This function takes the data from the lammi outputs and get the coordinate for the river. It also
reform the data to put it in the needed for HABBY (as the other 1.5D hydraulic model as hec\_ras).

To get the coordinates, we assume that the river is straight, that each facies is one after the other and
that the river passes by the deepest point of the profile. In addition we assume that the profile are straight
and perpendicular to the river. We assume that each facies (or reach for HABBY) is separated by a constant value

We loop through all the profiles for all reach all time steps. For each profile, the x coordinate is identical
for all point of the profile and is calculated using length\_all. When a new reach starts, a x constant distance
is added to the x coordinate. To find the y coordinate, we first pass from cell data (in lammi) to point data.
The point are the center of each cell and the border of this cells.  Then, we find the higher water height and
we assume that the river passes there. Hence, this is the origin of y-coordinate axes.

We double the last and the first profile of each reach/facies. Indded, in HABBY,the information of a profile are
given to the cells of the grid before and after the profile. If no cell would be done before or after the last/first
profile, these profiles would have less wight than the other which is a problem to reproduce lammi results. This
also avoid the case of a facies with only one profile, which is complicated to maange for the grid creation.

To keep as much as possible the same data than in Lammi, we create four points for each orginal lammi cells. The
three first points have the cell value of lammi and the last one is the average of the value of these cells and
the next. The point are disposed so that the first and last points are close to the end of the cells.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{dist\_all} -- the distance along profile by reach (or facies) and by time step

\item {} 
\sphinxstyleliteralstrong{vel\_all} -- the velocity along profile by reach (or facies) and by time step

\item {} 
\sphinxstyleliteralstrong{height\_all} -- the height along profile by reach (or facies) and by time step

\item {} 
\sphinxstyleliteralstrong{sub\_all} -- the substrate data along profile by reach (or facies) and by time step. Eacu subtrate data is a list
of eight number representing the percentage of each of the eight subtrate class.

\item {} 
\sphinxstyleliteralstrong{length\_all} -- the distance between profile

\end{itemize}

\item[{Returns}] \leavevmode
coord\_pro, nb\_pro\_reach and vh\_pro in the same form as in final form for hec-ras, a variable with the eight
subtrate data in a percetage form (sub\_pro) and a variable to find the position of the middle profile
(used by manage grid)

\end{description}\end{quote}

\end{fulllineitems}

\index{fig\_lammi() (in module src.lammi)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.lammi.fig_lammi}}\pysiglinewithargsret{\sphinxcode{src.lammi.}\sphinxbfcode{fig\_lammi}}{\emph{vh\_pro}, \emph{coord\_pro}, \emph{nb\_pro\_reach}, \emph{pro\_num}, \emph{sim\_num}, \emph{fig\_opt}, \emph{path\_im}}{}
This function create a figure with the loaded lammi data.
It work only for one time steps gven by the number sim\_num.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{vh\_pro} -- dist along the profile, height, vel

\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- x,y, dist along profile, height

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- the number of profile by reach

\item {} 
\sphinxstyleliteralstrong{pro\_num} -- the profile to plot

\item {} 
\sphinxstyleliteralstrong{sim\_num} -- the time step (or simuation) to plot

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- the option for the figure

\item {} 
\sphinxstyleliteralstrong{path\_im} -- path path where to save the figure

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_transect\_filename() (in module src.lammi)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.lammi.get_transect_filename}}\pysiglinewithargsret{\sphinxcode{src.lammi.}\sphinxbfcode{get\_transect\_filename}}{\emph{facies\_path}, \emph{facies\_name}, \emph{transect\_path}, \emph{transect\_name}, \emph{new\_dir}}{}
For each facies, we obtain the name of the transect file and the length of this reach
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{facies\_path} -- the path the facies.txt file

\item {} 
\sphinxstyleliteralstrong{facies\_name} -- the name of the facies file, usually `Facies.txt'

\item {} 
\sphinxstyleliteralstrong{transect\_path} -- the path to the transect.txt path

\item {} 
\sphinxstyleliteralstrong{transect\_name} -- the name of the transect file, usually `Transect.txt'

\item {} 
\sphinxstyleliteralstrong{new\_dir} -- If the folder with the transect have been moved, this argument allos it to be corrected without
modification to transect.txt

\end{itemize}

\item[{Returns}] \leavevmode
the length of each transect (arranged by facies and station) and the filename with the transect info

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_lammi() (in module src.lammi)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.lammi.load_lammi}}\pysiglinewithargsret{\sphinxcode{src.lammi.}\sphinxbfcode{load\_lammi}}{\emph{facies\_path}, \emph{transect\_path}, \emph{path\_im}, \emph{new\_dir}, \emph{fig\_opt}, \emph{savefig1d}, \emph{transect\_name}, \emph{facies\_name}}{}
This function loads the data from the LAMMI model. A description of the LAMMI model is available in the
documentation folder (LAMMIGuideMetho.pdf).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{transect\_path} -- the path to the transect.txt path

\item {} 
\sphinxstyleliteralstrong{facies\_path} -- the path the facies.txt file

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the image

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- the figure option

\item {} 
\sphinxstyleliteralstrong{savefig1d} -- create and save the figure related to the loading of the data (profile and so on)

\item {} 
\sphinxstyleliteralstrong{new\_dir} -- if necessary, the path to the resultat file (.prn file). Be default, use the one in transect.txt

\item {} 
\sphinxstyleliteralstrong{transect\_name} -- the name of the transect file, usually `Transect.txt'

\item {} 
\sphinxstyleliteralstrong{facies\_name} -- the name of the facies file, usually `Facies.txt'

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\sphinxstylestrong{Technical Comments}

LAMMI is organised aroung group of transects. Transect are river profile which describe the river geometry.
In LAMMI, there are four way of grouping transect. The facies is the a group a transect which is considered by HABBY
to form a reach. The facies can then begroup in station. HABBY do not considered station directly, but it is
possible to use the function ``load\_station'' to get the station info if needed. The group Secteur are used in case
where water is brought to the river.

To load LAMMI data, we first load the facies file, which gives which transect are in which facies. Then, we use
the transect file to know the length of each transect (length between transects along the river) and the
name of the file containing the transect precise data. The name of the file is an absolute path to the file.
This can be annoying if one want to move the files. Hence, we add the variable new\_dir which correct the transect
file in case the files containing the transect data have been moved (they should however all be in the same
directory). This is done by the function get\_transect\_name().

Then it uses the function load\_transect\_data to read all this data , file by file. Consequentely, we have
the data in memory but no(x,y) coordinate. In addition, this data is is in the different form than in the other
hydraulic model.

To obtain the coordainte of the river and to put the data is the form usually needed by HABBY for 1.5D model
(coord\_pro, vh\_pro, nb\_pro\_reach), we use the coord\_lammi() function.

There is also an optionnal check to control that the conversion between lammi and cemagref code is as normal.
This check is only done if HABBY can find the habitat.txt file where the conversion can be modified by the user.
Otherwise we assume that the normal conversion is used. Obviously, this check should be modifed if the edf
to cemagref conversion is modified.

\end{fulllineitems}

\index{load\_station() (in module src.lammi)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.lammi.load_station}}\pysiglinewithargsret{\sphinxcode{src.lammi.}\sphinxbfcode{load\_station}}{\emph{station\_path}, \emph{station\_name}}{}
This function loads the station data from the LAMMI model. This is the data contains in Station.txt. It is not used
by HABBY but it could be useful.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{station\_path} -- the path to the station.txt file

\item {} 
\sphinxstyleliteralstrong{station\_name} -- the name of the station file, usually `Station.txt'

\end{itemize}

\item[{Returns}] \leavevmode
the length of the station (list of float) and the id of the facies for each station (list of list)

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_transect\_data() (in module src.lammi)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.lammi.load_transect_data}}\pysiglinewithargsret{\sphinxcode{src.lammi.}\sphinxbfcode{load\_transect\_data}}{\emph{fac\_filename\_all}}{}
This function loads the transect data. In this data, there are the subtrate, the height and the velocity data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{fac\_filename\_all} -- the list of transect name organized by facies

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module src.lammi)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.lammi.main}}\pysiglinewithargsret{\sphinxcode{src.lammi.}\sphinxbfcode{main}}{}{}
Used to test this module

\end{fulllineitems}

\index{open\_lammi\_and\_create\_grid() (in module src.lammi)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.lammi.open_lammi_and_create_grid}}\pysiglinewithargsret{\sphinxcode{src.lammi.}\sphinxbfcode{open\_lammi\_and\_create\_grid}}{\emph{facies\_path}, \emph{transect\_path}, \emph{path\_im}, \emph{name\_hdf5}, \emph{name\_prj}, \emph{path\_prj}, \emph{path\_hdf5}, \emph{new\_dir='`}, \emph{fig\_opt={[}{]}}, \emph{savefig1d=False}, \emph{transect\_name='Transect.txt'}, \emph{facies\_name='Facies.txt'}, \emph{print\_cmd=False}, \emph{q={[}{]}}, \emph{dominant\_case=1}, \emph{model\_type='LAMMI'}}{}
This function loads the data from the LAMMI model using the load\_lammi() function., create the grid and save the
data in an hdf5 file. A description of the LAMMI model is available in the documentation folder
(LAMMIGuideMetho.pdf).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{transect\_path} -- the path to the transect.txt path

\item {} 
\sphinxstyleliteralstrong{facies\_path} -- the path the facies.txt file

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the image

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- the figure option

\item {} 
\sphinxstyleliteralstrong{savefig1d} -- create and save the figure related to the loading of the data (profile and so on)

\item {} 
\sphinxstyleliteralstrong{name\_hdf5} -- the name of the hdf5 to be created

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- the name of the project (string)

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path of the project

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- the path to the hdf5 data

\item {} 
\sphinxstyleliteralstrong{new\_dir} -- if necessary, the path to the resultat file (.prn file). Be default, use the one in transect.txt

\item {} 
\sphinxstyleliteralstrong{transect\_name} -- the name of the transect file, usually `Transect.txt'

\item {} 
\sphinxstyleliteralstrong{facies\_name} -- the name of the facies file, ususally `Facies.txt

\item {} 
\sphinxstyleliteralstrong{print\_cmd} -- if True the print command is directed in the cmd, False if directed to the GUI

\item {} 
\sphinxstyleliteralstrong{q} -- used if this function is send using the second thread

\item {} 
\sphinxstyleliteralstrong{dominant\_case} -- an int to manage the case where the transfomation form percentage to dominnat is unclear (two
maxinimum percentage are equal from one element). if -1 take the smallest, if 1 take the biggest,
if 0, we do not know.

\item {} 
\sphinxstyleliteralstrong{model\_type} -- which type of model (LAMMI in this case). It is as an argument just in case (lammi, Lammi, etc.)

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

LAMMI has a special way of creating a grid from its data. Because spatial information is not very good in LAMMI,
we can only used the create\_grid\_only\_1\_profile() function. The function which uses triangle to create the grid can
not be used here as the developper fomr LAMMI did not wish to introduce an interpolation method in their outputs.
In addition, LAMMI integrates substrate data which should be direclty added to the grid while other hydraulic model
get their substrate data from another sources.

\end{fulllineitems}



\section{Load HABBY hdf5 file}
\label{\detokenize{index:load-habby-hdf5-file}}
in src/load\_hdf5.py

This module contains some functions to load and manage hdf5 input/outputs.
\phantomsection\label{\detokenize{index:module-src.load_hdf5}}\index{src.load\_hdf5 (module)}\index{add\_habitat\_to\_merge() (in module src.load\_hdf5)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.load_hdf5.add_habitat_to_merge}}\pysiglinewithargsret{\sphinxcode{src.load\_hdf5.}\sphinxbfcode{add\_habitat\_to\_merge}}{\emph{hdf5\_name}, \emph{path\_hdf5}, \emph{vh\_cell}, \emph{h\_cell}, \emph{v\_cell}, \emph{fish\_name}}{}
This function takes a merge file and add habitat data to it. The habitat data is given by cell. It also save the
velocity and the water height by cell (and not by node)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{hdf5\_name} -- the name of the merge file

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- the path to this file

\item {} 
\sphinxstyleliteralstrong{vh\_cell} -- the habitat value by cell

\item {} 
\sphinxstyleliteralstrong{h\_cell} -- the height data by cell

\item {} 
\sphinxstyleliteralstrong{v\_cell} -- the velcoity data by cell

\item {} 
\sphinxstyleliteralstrong{fish\_name} -- the name of the fish (with the stage in it)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{addition\_hdf5() (in module src.load\_hdf5)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.load_hdf5.addition_hdf5}}\pysiglinewithargsret{\sphinxcode{src.load\_hdf5.}\sphinxbfcode{addition\_hdf5}}{\emph{path1}, \emph{hdf51}, \emph{path2}, \emph{hdf52}, \emph{name\_prj}, \emph{path\_prj}, \emph{model\_type}, \emph{path\_hdf5}, \emph{merge=False}, \emph{erase\_id=True}}{}
This function merge two hdf5 together. The hdf5 files should be of hydrological or merge type and both grid should
in the same coordinate system. It is not possible to have one merge file and one hydrological hdf5 file. They both
should be of the same type. The two grid are added as two separeted river reach.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{path1} -- the path to the first hydrological hdf5

\item {} 
\sphinxstyleliteralstrong{hdf51} -- the name of the first hdf5 file

\item {} 
\sphinxstyleliteralstrong{path2} -- the path to the second hdf5

\item {} 
\sphinxstyleliteralstrong{hdf52} -- the name of the second hdf5

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- the name of the project

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path to the project

\item {} 
\sphinxstyleliteralstrong{model\_type} -- the type of model (used to save the new file name into the project xml file)

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- the path where to save the hdf5 (ususally path\_prj, but not always)

\item {} 
\sphinxstyleliteralstrong{merge} -- If True, this is a merge hdf5 file and not only hydraulic data. Boolean.

\item {} 
\sphinxstyleliteralstrong{erase\_id} -- If true and if a similar hdf5 exist, il will be erased

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{copy\_files() (in module src.load\_hdf5)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.load_hdf5.copy_files}}\pysiglinewithargsret{\sphinxcode{src.load\_hdf5.}\sphinxbfcode{copy\_files}}{\emph{names}, \emph{paths}, \emph{path\_input}}{}
This function copied the input files to the project file. The input files are usually contains in the input
project file. It is ususally done on a second thread as it might be long.

For the moment this function cannot send warning and error to the GUI. As input should have been cheked before
by HABBY, this should not be a problem.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{names} -- the name of the files to be copied (list of string)

\item {} 
\sphinxstyleliteralstrong{paths} -- the path to these files (list of string)

\item {} 
\sphinxstyleliteralstrong{path\_input} -- the path where to send the input (string)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_filename() (in module src.load\_hdf5)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.load_hdf5.get_all_filename}}\pysiglinewithargsret{\sphinxcode{src.load\_hdf5.}\sphinxbfcode{get\_all\_filename}}{\emph{dirname}, \emph{ext}}{}
This function gets the name of all file with a particular extension in a folder. Useful to get all the output
from one hydraulic model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{dirname} -- the path to the directory (string)

\item {} 
\sphinxstyleliteralstrong{ext} -- the extension (.txt for example). It is a string, the point needs to be the first character.

\end{itemize}

\item[{Returns}] \leavevmode
a list with the filename (filename+dir) for each extension

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_hdf5\_name() (in module src.load\_hdf5)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.load_hdf5.get_hdf5_name}}\pysiglinewithargsret{\sphinxcode{src.load\_hdf5.}\sphinxbfcode{get\_hdf5\_name}}{\emph{model\_name}, \emph{name\_prj}, \emph{path\_prj}}{}
This function get the name of the hdf5 file containg the hydrological data for an hydrological model of type
model\_name. If there is more than one hdf5 file, it choose the last one. Tha path is the path from the
project folder. Hence, it is not the absolute path.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{model\_name} -- the name of the hydrological model as written in the attribute of the xml project file

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- the name of the project

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path to the project

\end{itemize}

\item[{Returns}] \leavevmode
the name of the hdf5 file

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_initial\_files() (in module src.load\_hdf5)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.load_hdf5.get_initial_files}}\pysiglinewithargsret{\sphinxcode{src.load\_hdf5.}\sphinxbfcode{get\_initial\_files}}{\emph{path\_hdf5}, \emph{hdf5\_name}}{}
This function looks into a merge file to find the hydraulic and subtrate file which
were used to create this file.
:param path\_hdf5: the path to the hdf5 file
:param hdf5\_name: the name fo this hdf5 file
:return: the name of the substrate and hydraulic file used to create the merge file

\end{fulllineitems}

\index{load\_hdf5\_hyd() (in module src.load\_hdf5)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.load_hdf5.load_hdf5_hyd}}\pysiglinewithargsret{\sphinxcode{src.load\_hdf5.}\sphinxbfcode{load\_hdf5\_hyd}}{\emph{hdf5\_name\_hyd}, \emph{path\_hdf5='`}, \emph{merge=False}}{}
A function to load the 2D hydrological data contains in the hdf5 file in the form required by HABBY. f hdf5\_name\_sub
is an absolute path, the path\_prj is not used. If it is a relative path, the path is composed of the path to the
project (path\_prj) composed with hdf5\_name\_sub.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{hdf5\_name\_hyd} -- filename of the hdf5 file (string)

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- the path to the hdf5 file

\item {} 
\sphinxstyleliteralstrong{merge} -- If merge is True. this is a merged file with substrate data added

\end{itemize}

\item[{Returns}] \leavevmode
the connectivity table, the coordinates of the point, the height data, the velocity data on the coordinates.

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_hdf5\_sub() (in module src.load\_hdf5)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.load_hdf5.load_hdf5_sub}}\pysiglinewithargsret{\sphinxcode{src.load\_hdf5.}\sphinxbfcode{load\_hdf5\_sub}}{\emph{hdf5\_name\_sub}, \emph{path\_hdf5}, \emph{ind\_const=False}}{}
A function to load the substrate data contained in the hdf5 file. It also manage
the constant cases. If hdf5\_name\_sub is an absolute path, the path\_prj is not used. If it is a relative path,
the path is composed of the path to the `hdf5' folder (path\_prj/fichier\_hdf5) composed with hdf5\_name\_sub. it manages constant and
vairable (based on a grid) cases. The code should be of cemagref type and the data is given as coarser and dominant.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{hdf5\_name\_sub} -- path and file name to the hdf5 file (string)

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path to the hdf5 file

\item {} 
\sphinxstyleliteralstrong{ind\_const} -- If True this function return a boolean which indicates if the substrant is constant or not

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_sub\_percent() (in module src.load\_hdf5)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.load_hdf5.load_sub_percent}}\pysiglinewithargsret{\sphinxcode{src.load\_hdf5.}\sphinxbfcode{load\_sub\_percent}}{\emph{hdf5\_name\_hyd}, \emph{path\_hdf5='`}}{}
This function loads the substrate in percent form, if this info is present in the hdf5 file. It send a warning
otherwise.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{hdf5\_name\_hyd} -- filename of the hdf5 file (string)

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- the path to the hdf5 file

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{load\_timestep\_name() (in module src.load\_hdf5)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.load_hdf5.load_timestep_name}}\pysiglinewithargsret{\sphinxcode{src.load\_hdf5.}\sphinxbfcode{load\_timestep\_name}}{\emph{hdf5\_name}, \emph{path\_hdf5='`}}{}
This function looks for the name of the timesteps in hydrological or merge hdf5. If it find the name
of the time steps, it retruns them. If not, it return an empty lists.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{hdf5\_name} -- the name of the merge or hydrological hdf5 file

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- the path to the hdf5

\end{itemize}

\item[{Returns}] \leavevmode
the name of the time step if they exist. Otherwise, an empty list

\end{description}\end{quote}

\end{fulllineitems}

\index{open\_hdf5() (in module src.load\_hdf5)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.load_hdf5.open_hdf5}}\pysiglinewithargsret{\sphinxcode{src.load\_hdf5.}\sphinxbfcode{open\_hdf5}}{\emph{hdf5\_name}}{}
This is a function which open an hdf5 file and check that it exists. it does not load the data. It only opens the
files.
:param hdf5\_name: the path and name of the hdf5 file (string)

\end{fulllineitems}

\index{save\_hdf5() (in module src.load\_hdf5)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.load_hdf5.save_hdf5}}\pysiglinewithargsret{\sphinxcode{src.load\_hdf5.}\sphinxbfcode{save\_hdf5}}{\emph{name\_hdf5}, \emph{name\_prj}, \emph{path\_prj}, \emph{model\_type}, \emph{nb\_dim}, \emph{path\_hdf5}, \emph{ikle\_all\_t}, \emph{point\_all\_t}, \emph{point\_c\_all\_t}, \emph{inter\_vel\_all\_t}, \emph{inter\_h\_all\_t}, \emph{xhzv\_data={[}{]}}, \emph{coord\_pro={[}{]}}, \emph{vh\_pro={[}{]}}, \emph{nb\_pro\_reach={[}{]}}, \emph{merge=False}, \emph{sub\_pg\_all\_t={[}{]}}, \emph{sub\_dom\_all\_t={[}{]}}, \emph{sub\_per\_all\_t={[}{]}}, \emph{sim\_name={[}{]}}, \emph{sub\_ini\_name='`}, \emph{hydro\_ini\_name='`}, \emph{save\_option=None}}{}
This function save the hydrological data in the hdf5 format.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{name\_hdf5} -- the base name for the hdf5 file to be created (string)

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- the name of the project (string)

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path of the project

\item {} 
\sphinxstyleliteralstrong{model\_type} -- the name of the model such as Rubar, hec-ras, etc. (string)

\item {} 
\sphinxstyleliteralstrong{nb\_dim} -- the number of dimension (model, 1D, 1,5D, 2D) in a float

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- A string which gives the adress to the folder in which to save the hdf5

\item {} 
\sphinxstyleliteralstrong{ikle\_all\_t} -- the connectivity table for all discharge, for all reaches and all time steps

\item {} 
\sphinxstyleliteralstrong{point\_all\_t} -- the point forming the grid, for all reaches and all time steps

\item {} 
\sphinxstyleliteralstrong{point\_c\_all\_t} -- the point at the center of the cells, for all reaches and all time steps

\item {} 
\sphinxstyleliteralstrong{inter\_vel\_all\_t} -- the velocity for all grid point, for all reaches and all time steps (by node)

\item {} 
\sphinxstyleliteralstrong{inter\_h\_all\_t} -- the height for all grid point, for all reaches and all time steps (by node)

\item {} 
\sphinxstyleliteralstrong{xhzv\_data} -- data linked with 1D model (only used when a 1D model was transformed to a 2D)

\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- data linked with 1.5D model or data created by dist\_vist from a 1D model (profile data)

\item {} 
\sphinxstyleliteralstrong{vh\_pro} -- data linked with 1.5D model or data created by dist\_vist from a 1D model (velcoity and height data)

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- data linked with 1.5D model or data created by dist\_vist from a 1D model (nb profile)

\item {} 
\sphinxstyleliteralstrong{merge} -- If True, the data is coming from the merging of substrate and hydrological data.

\item {} 
\sphinxstyleliteralstrong{sub\_pg\_all\_t} -- the data of the coarser substrate given on the merged grid by cell. Only used if merge is True.

\item {} 
\sphinxstyleliteralstrong{sub\_dom\_all\_t} -- the data of the dominant substrate given on the merged grid by cells. Only used if merge is True.

\item {} 
\sphinxstyleliteralstrong{sub\_per\_all\_t} -- the data of the substreate by percentage. Only used with lammi (mostly)

\item {} 
\sphinxstyleliteralstrong{sim\_name} -- the name of the simulation or the names of the time steps if the names are not {[}0,1,2,3, etc.{]}

\item {} 
\sphinxstyleliteralstrong{sub\_ini\_name} -- The name of the substrate hdf5 file from which the data originates

\item {} 
\sphinxstyleliteralstrong{hydro\_ini\_name} -- the name of the hydraulic hdf5 file from which the data originates

\item {} 
\sphinxstyleliteralstrong{save\_option} -- If save\_option is not none, the variable erase\_idem which is usually given in the figure option
is overwritten by save\_option which is boolean. This is useful for habby cmd.

\end{itemize}

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

This function could look better inside the class SubHydroW where it was before. However, it was not possible
to use it on the command line and it was not pratical for having two thread (it is impossible to have a method
as a second thread)

This function creates an hdf5 file which contains the hydrological data. First it creates an empty hdf5.
Then it fill the hdf5 with data. For 1D model, it fill the data in 1D (the original data), then the 1.5D data
created by dist\_vitess2.py and finally the 2D data. For model in 2D it only saved 2D data. Hence, the 2D data
is the data which is common to all model and which can always be loaded from a hydrological hdf5 created by
HABBY. The 1D and 1.5D data is only present if the model is 1D or 1.5D. Here is some general info about the
created hdf5:
\begin{itemize}
\item {} 
Name of the file: name\_hdf5. If we save all file even if the model is re-run we add a time stamp.
For example, test4\_HEC-RAS\_25\_10\_2016\_12\_23\_23.h5.

\item {} 
Position of the file: in the folder  figure\_habby currently (probably in a project folder in the final software)

\item {} 
Format of the hdf5 file:
\begin{itemize}
\item {} 
Dats\_gen:  number of time step and number of reach

\item {} 
Data\_1D:  xhzv\_data\_all (given profile by profile)

\item {} 
Data\_15D :  vh\_pro, coord\_pro (given profile by profile in a dict) and nb\_pro\_reach.

\item {} 
Data\_2D : For each time step, for each reach: ikle, point, point\_c, inter\_h, inter\_vel

\end{itemize}

\end{itemize}

If a list has elements with a changing number of variables, it is necessary to create a dictionary to save
this list in hdf5. For example, a dictionary will be needed to save the following list: {[}{[}1,2,3,4{]}, {[}1,2,3{]}{]}.
This is used for example, to save data by profile as we can have profile with more or less points. We also note
in the hdf5 attribute some important info such as the project name, path to the project, hdf5 version.
This can be useful if an hdf5 is lost and is not linked with any project. We also add the name of the created
hdf5 to the xml project file. Now we can load the hydrological data using this hdf5 file and the xml project file.

When saving habitat data, we add a time stamp so that if re-run an habitat simulation, we do not loos all the data.
When loading, the last data should be used.

Hdf5 file do not support unicode. It is necessary to encode string to write them.

\end{fulllineitems}

\index{save\_hdf5\_sub() (in module src.load\_hdf5)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.load_hdf5.save_hdf5_sub}}\pysiglinewithargsret{\sphinxcode{src.load\_hdf5.}\sphinxbfcode{save\_hdf5\_sub}}{\emph{path\_hdf5}, \emph{path\_prj}, \emph{name\_prj}, \emph{sub\_pg}, \emph{sub\_dom}, \emph{ikle\_sub={[}{]}}, \emph{coord\_p={[}{]}}, \emph{name\_hdf5='`}, \emph{constsub=False}, \emph{model\_type='SUBSTRATE'}, \emph{return\_name=False}}{}
This function creates an hdf5 with the substrate data. This hdf5 does not have the same form than the hdf5 file used
to store hydrological or merge data. This hdf5 store the substrate data alone before it is merged with the
hydrological info. The substrate info should be given in the cemagref code.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- the path where the hdf5 file should be saved

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the project path

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- the name of the project

\item {} 
\sphinxstyleliteralstrong{sub\_pg} -- the coarser part of the substrate (array with length of ikle if const\_sub is False, a float otherwise)

\item {} 
\sphinxstyleliteralstrong{sub\_dom} -- the dominant part of the substrate (array with length of ikle if const\_sub is False, a float otherwise)

\item {} 
\sphinxstyleliteralstrong{ikle\_sub} -- the connectivity table for the substrate (only if constsub = False)

\item {} 
\sphinxstyleliteralstrong{coord\_p} -- the point of the grid of the substrate (only if constsub = False)

\item {} 
\sphinxstyleliteralstrong{name\_hdf5} -- the name of the substrate h5 file (without the timestamp). If not given, a default name is used.

\item {} 
\sphinxstyleliteralstrong{constsub} -- If True the substrate is a constant value

\item {} 
\sphinxstyleliteralstrong{model\_type} -- the attribute for the xml file (usually SUBSTRATE)

\item {} 
\sphinxstyleliteralstrong{return\_name} -- If True this function return the name of the substrate hdf5 name

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Form of the hdf5 files}
\label{\detokenize{index:form-of-the-hdf5-files}}
Here is the actual form of the hdf5 containing the 2D hydrological data.
\begin{itemize}
\item {} 
Number of timestep: Data\_gen/Nb\_timestep

\item {} 
Number of reach: Data\_gen/Nb\_reach

\item {} 
Connectivity table for the whole profile: Data\_2D/Whole\_Profile/Reach\_\textless{}r\textgreater{}/ikle

\item {} 
Connectivity table for the wetted area (by time step): Data\_2D/Timestep\textless{}t\textgreater{}/Reach\_\textless{}r\textgreater{}/ikle

\item {} 
Coordinates for the whole profile: Data\_2D/Whole\_Profile/Reach\_\textless{}r\textgreater{}/point\_all

\item {} 
Coordinates for the wetted area (by time steps): Data\_2D/Timestep\textless{}t\textgreater{}/Reach\_\textless{}r\textgreater{}/point\_all

\item {} 
Data for the velocity: Data\_2D/Timestep\textless{}t\textgreater{}/Reach\_\textless{}r\textgreater{}/inter\_vel\_all

\item {} 
Data for the height:  Data\_2D/Timestep\textless{}t\textgreater{}/Reach\_\textless{}r\textgreater{}/inter\_h\_all

\end{itemize}

Here is the actual form of the hdf5 containing the substrate data.
\begin{itemize}
\item {} 
the coordinate of the point forming the substrate ``grid'': coord\_p\_sub/

\item {} 
the connectivity table of the substrate ``grid'': ikle\_sub/

\item {} 
Substrate data; not done yet

\end{itemize}


\section{Velocity distribution}
\label{\detokenize{index:velocity-distribution}}
in src/dist\_vitesse2.py

The goal of this list of function is to distribute the velocity along the cross-section
for 1D model such as mascaret or Rubar BE. Hec-Ras outputs do not need to uses this type
of function as they are already distributed along the profiles.

The method of velocity distribution in HABBY is similar to the one used by Hec-Ras to distribute
velocity.
\phantomsection\label{\detokenize{index:module-src.dist_vistess2}}\index{src.dist\_vistess2 (module)}\index{dist\_velocity\_hecras() (in module src.dist\_vistess2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.dist_vistess2.dist_velocity_hecras}}\pysiglinewithargsret{\sphinxcode{src.dist\_vistess2.}\sphinxbfcode{dist\_velocity\_hecras}}{\emph{coord\_pro}, \emph{xhzv\_data\_all}, \emph{manning\_pro}, \emph{nb\_point=-99}, \emph{eng=1.0}, \emph{on\_profile={[}{]}}}{}
This function distribute the velocity along the profile using the method from hec-ras
which is described in the hydraulic reference manual p 4-20 (Flow distribtion calculation)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the coordinates and elevation of the river bed for each profile (x,y, h, dist along the profile)
this list is flatten No reach info.

\item {} 
\sphinxstyleliteralstrong{xhzv\_data\_all} -- water height and velocity at each profile, 1D

\item {} 
\sphinxstyleliteralstrong{manning\_pro} -- the manning coefficient for zone between point of each profile.
For a particular profile, the length of manning\_pro is the length of coord\_pro{[}0{]}

\item {} 
\sphinxstyleliteralstrong{nb\_point} -- number of velocity points (-99 takes the number of measured elevation as the number of velocity points).

\item {} 
\sphinxstyleliteralstrong{eng} -- in case the output from hec-ras are in US unit (eng=1 for SI unit and 1.486 for US unit)

\item {} 
\sphinxstyleliteralstrong{on\_profile} -- Mascaret also gives outputs in poitns between profile. on\_profile is true if the results are
close or on the profile (les than 3cm of difference). This is not important for rubar or other models

\end{itemize}

\item[{Returns}] \leavevmode
the velocity for each profile by time step (x,v)

\end{description}\end{quote}

\sphinxstylestrong{Technical comment and walk-through}

First, we decide on which point along the profile we will calculate the velocity. This is controlled by the
variable nb\_point. If nb\_point=-99, we will calculate the velocity at the same point than the profile (i.e., the
velocity will be calculated at each point on which the elevation of the profile was measured). There are cases where
this is not adequate. Let’s imagine for example a rectangular canal. The calculation would only give two velocity
points, which is not enough. So, it is possible to give the number of velocity point on which the calculation must
be made, using the variable nb\_point.

Currently, the velocity points are determined by dividing the whole profile in nb\_point segments. This means that
some velocity point are not used afterwards because they are in the dry part of the profile and that it is not
possible to select for a part of the profile where more velocity points would be calculated. This could be modified
in the future if it is judged necessary.

To determine the point where velocity should be calculated we need to get two array: one “x” array, the distance
along the profile and one “h” array, the elevation of the profile at this point. As we choose the position of the
velocity point as regularly placed along the profile, the “x” array is easy to determine using linespace. For the
“h” array, we use the hypothesis that the elevation of the profile changes linearly between the measured elevation
points. We find between which elevation point are the new point and we use a linear interpolation to find the new”h”.
To find between which points we are, we use the bisect.bisect function. It is a bit like the np.where function,
but it is quicker when the array is ordered (as it is the case here).

Then, we get the manning array as created by the get\_manning\_arr and the get\_manning function. It should be a float.

Next, we cut the profile to keep only the part under water. For this, we do two things: First we had a point on the
profile where h==0. We should account for the fact that we might have  “islands” (part of the profile which are
dry, but surrounded by water on both side.). So we cannot only looked which part are dry, we need to look
for each point where we pass from “wet to dry” or from “dry to wet”. At this place, we add one point where h= 0.
For these new points water height is obviously known, but x (the distlance along profile) should be determined.
It is determined assuming a linear change between the measured points of the profile.

If the profile is not entirely dry, we will now distribute the velocity along the profile. First, for each part of
the profile where velocity will be calculated, it looks where is the higher height (like if this part of the profile
is going up or down). Next, we calculate the area, the wetted perimeter and the hydraulic radius of each part of the
profile. By combining this geometrical information with the manning parameter, we can calculate the conveyance
of each part of the profile. See manual of hec-ras p.4-20 for the conveyance definition.

We now calculate the conveyance of the whole profile. Normally, the sum of the conveyance of the part is higher
than the total conveyance. The next part of the script corrects for this, using the ratio of the total conveyance
and the sum of the parts of the conveyance. Next, we calculate the velocity using the modelled energy slope (Sf)
and the manning equation. We then then add a velocity of zero where there are no water (velocity is not defined
at his point).

\end{fulllineitems}

\index{distribute\_velocity() (in module src.dist\_vistess2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.dist_vistess2.distribute_velocity}}\pysiglinewithargsret{\sphinxcode{src.dist\_vistess2.}\sphinxbfcode{distribute\_velocity}}{\emph{manning\_data}, \emph{nb\_point\_vel}, \emph{coord\_pro}, \emph{xhzv\_data}, \emph{on\_profile={[}{]}}}{}
This function make the link between the GUI and the functions of dist\_vitesse2. It is used by 1D model,
notably rubar and masacret.

Dist vitess needs a manning parameters. It can be given by the user in two forms: a constant (float) or an array
created by the function load\_manning\_text.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{manning\_data} -- the manning data as a float (constant) or as an array (variable)

\item {} 
\sphinxstyleliteralstrong{nb\_point\_vel} -- the number of velcoity point asked (if -99, the same number of point than the profile
will be used)

\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the form of the profil (x,y, h, dist along the profile)

\item {} 
\sphinxstyleliteralstrong{xhzv\_data} -- the vecoity and height data

\item {} 
\sphinxstyleliteralstrong{on\_profile} -- Mascaret also gives outputs in poitns between profile. on\_profile is true if the results are
close or on the profile (les than 3cm of difference). This is not important for rubar or other models

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_manning() (in module src.dist\_vistess2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.dist_vistess2.get_manning}}\pysiglinewithargsret{\sphinxcode{src.dist\_vistess2.}\sphinxbfcode{get\_manning}}{\emph{manning1}, \emph{nb\_point}, \emph{nb\_profil}, \emph{coord\_pro}}{}
This function creates an array with the manning value when a single float is given, so when the manning value
is a constant for the whole river.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{manning1} -- the manning value (can be a value or an array)

\item {} 
\sphinxstyleliteralstrong{nb\_point} -- the number of velocity point by profile

\item {} 
\sphinxstyleliteralstrong{nb\_profil} -- the number of profile

\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- necessary if the number is -99 as we need to know the length of each profile

\end{itemize}

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

The function dist\_velcoity\_hec\_ras needs a manning array with a length equal to the number of profile, where each
row (representing a profile) have one value by velocity point which will be calculated. This function creates an
array of this form based on a float. It creates a list of manning value which is identical for each point of the
river. It can be used for the cases where the same number of point is asked for each profile or for the case where
the number of point is defined by the form of the profile (nb\_point = -99).

\end{fulllineitems}

\index{get\_manning\_arr() (in module src.dist\_vistess2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.dist_vistess2.get_manning_arr}}\pysiglinewithargsret{\sphinxcode{src.dist\_vistess2.}\sphinxbfcode{get\_manning\_arr}}{\emph{manning\_arr}, \emph{nb\_point}, \emph{coord\_pro}}{}
This function create the manning array when manning data is loaded using a text file. In this case, the manning
value do not needs to be a constant.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{manning\_arr} -- the data for manning

\item {} 
\sphinxstyleliteralstrong{nb\_point} -- the number of velocity point by profile

\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- x,y,dist

\end{itemize}

\end{description}\end{quote}

\sphinxstylestrong{Technical comment}

The user creates a txt file with a list of manning info. Each manning value is given the following way:
the profile, the distance along the profile and the manning value. One value by line in SI unit.

This function automatically fills the missing value, so that the user do not needs to give each manning value.
He can describe one profile and this profile will be replicated until the next profile written in the text file.

\end{fulllineitems}

\index{main() (in module src.dist\_vistess2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.dist_vistess2.main}}\pysiglinewithargsret{\sphinxcode{src.dist\_vistess2.}\sphinxbfcode{main}}{}{}
Used to test this module.

\end{fulllineitems}

\index{plot\_dist\_vit() (in module src.dist\_vistess2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.dist_vistess2.plot_dist_vit}}\pysiglinewithargsret{\sphinxcode{src.dist\_vistess2.}\sphinxbfcode{plot\_dist\_vit}}{\emph{v\_pro}, \emph{coord\_pro}, \emph{xhzv\_data}, \emph{plot\_timestep}, \emph{pro}, \emph{name\_pro={[}{]}}, \emph{on\_profile={[}{]}}, \emph{zone\_v\_all={[}{]}}, \emph{data\_profile={[}{]}}, \emph{xy\_h\_all={[}{]}}}{}
This is a function to plot the distribution of velocity and the elevation of the profile. It is quite close to the
similar function which is in hec-ras (see this function for a more detailed explanation)

It can be used to test the program if we provide the variable zone\_v\_all where zone\_v\_all is an hec-ras output with a
velocity distribution. In this case, it would plot the comparison between the output from this script and the
output from hec-ras. Of course, for this, it is necessary to have prepared the 1D output from hec-ras
(using the function preparetest\_velocity) and to have the same points on which to calculate the velocity.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{v\_pro} -- the calculated velcocity distribution by time step

\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the coordinate of the profiles

\item {} 
\sphinxstyleliteralstrong{xhzv\_data} -- the output data from the model, before the velocity distrbution

\item {} 
\sphinxstyleliteralstrong{plot\_timestep} -- which time step to be plottied

\item {} 
\sphinxstyleliteralstrong{name\_pro} -- the name of the profile (optionnal just for the title)

\item {} 
\sphinxstyleliteralstrong{pro} -- which porfile to be plotted

\item {} 
\sphinxstyleliteralstrong{on\_profile} -- select the data which is on the profile

\item {} 
\sphinxstyleliteralstrong{zone\_v} -- output from hec-ras used to test dist\_vitesse

\item {} 
\sphinxstyleliteralstrong{data\_profile} -- output from hec-ras used to test dist\_vitesse

\item {} 
\sphinxstyleliteralstrong{xy\_h} -- output from hec-ras used to test dist\_vitesse

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{preparetest\_velocity() (in module src.dist\_vistess2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.dist_vistess2.preparetest_velocity}}\pysiglinewithargsret{\sphinxcode{src.dist\_vistess2.}\sphinxbfcode{preparetest\_velocity}}{\emph{coord\_pro}, \emph{vh\_pro\_orr}, \emph{v\_in}}{}
This is a debugging function. It takes as input the output from the hec-ras model and gives a 1D velocity as
output. This is only to test this program. It will not be used by HABBY directly. To use this function, it is
necessary to use the function to load hec-ras data from HABBY, so that the hec-ras data is in the right form.
The 1D-velocity is assumed to be the velocity as the lowest part of the profile. This is where a 1D-model would
estimate the position of the river (the lowest part of the river bed).

A complicated point to test the program is to put the velocity point at the same point than hec-ras. As hec-ras
calculate velocity between zones and not on one point, this is more or less impossible to do with precision.
However, one can count the number of velocity zone and give this as an input to dist\_velocity\_hecras() for the
variable nb\_point. However, both line will not be exactly at the same place. The results should however be close
enough.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the coordinate of the profile (x,y,h,dist along profile)

\item {} 
\sphinxstyleliteralstrong{vh\_pro\_orr} -- the velocity distribution which is the output from hec ras (produced by hec-ras06.py)

\item {} 
\sphinxstyleliteralstrong{v\_in} -- the uni-dimensional velocity

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{Create a grid}
\label{\detokenize{index:create-a-grid}}
in src/manage\_grid\_8

This module is composed of the functions used to manage the grid,
notably to create 2D grid from the output from 1D model.

There are two main way to go from data in 1.5D in a profile form to a 2D grid:
\begin{itemize}
\item {} 
through the usage of the triangle module in create\_grid().

\item {} 
through the definition of a middle profile used as a guide to create the grid in create\_grid\_only\_one\_profile().

\end{itemize}

For an in-depth explanation on how to create the grids, please see the pdf document \sphinxcode{More info on the grid}
\phantomsection\label{\detokenize{index:module-src.manage_grid_8}}\index{src.manage\_grid\_8 (module)}\index{add\_point() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.add_point}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{add\_point}}{\emph{point\_all}, \emph{point}}{}
To manage the substrate data, we modify the hydrological grid to avoid to have cells with two substrate type.
This function add one coordinate point to the list of coordinates which compose the hydrological grid. This point
is the intersection between one side of one triangluar cell of the hydrological grid and one side of the
sibstrate layer (which is a shp). It only adds this intersection point if it is not already in point\_all.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{point\_all} -- the coordinates of the hydrological grid

\item {} 
\sphinxstyleliteralstrong{point} -- one intersection point between substrat and hydrological grids

\end{itemize}

\item[{Returns}] \leavevmode
the updated point\_all (the coordinates of the hydrological grid)

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_dummy\_substrate() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.create_dummy_substrate}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{create\_dummy\_substrate}}{\emph{coord\_pro}, \emph{sqrtnp}}{}
For testing purposes, it can be useful to create a substrate input even if one does not exist.
This substrate is compose of n triangle situated on the rivers in the same coodinates system.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the coordinate of each profile

\item {} 
\sphinxstyleliteralstrong{sqrtnp} -- the number of point which will compose one side of the new substrate grid (so the total number
of point is sqrtnb squared).

\end{itemize}

\item[{Returns}] \leavevmode
dummy coord\_sub, ikle\_sub

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_grid() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.create_grid}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{create\_grid}}{\emph{coord\_pro, extra\_pro, coord\_sub, ikle\_sub, nb\_pro\_reach={[}0, 10000000000.0{]}, vh\_pro\_t={[}{]}, q={[}{]}, pnew\_add=1}}{}
It creates a grid from the coord\_pro data using the triangle module.
It creates the grid up to the end of the profile if vh\_pro\_t is not present
or up to the water limit if vh\_pro\_t is present
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{q} -- used in the secondary process  when we do not call this function direclty, but we call it in a second
process so that the GUI do not crash if something go wrong (not used anymore in this form)

\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the profile coordinates (x,y, h, dist along) the profile

\item {} 
\sphinxstyleliteralstrong{extra\_pro} -- the number of ``extra'' profiles to be added between profile to simplify the grid

\item {} 
\sphinxstyleliteralstrong{coord\_sub} -- (not used anymore)
the coordinate of the point forming the substrate layer (often created with substrate.load\_sub)

\item {} 
\sphinxstyleliteralstrong{ikle\_sub} -- (not used anymore)
the connectivity table of the substrate grid (often created with substrate.load\_sub)

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- the number of reach by profile starting with 0

\item {} 
\sphinxstyleliteralstrong{vh\_pro\_t} -- the velocity and height of the water (used to cut the limit of the river).

\item {} 
\sphinxstyleliteralstrong{pnew\_add} -- (not used anymore) a parameter to cut the substrate side in smaller part (improve grid quality)
in the form dist along profile, h , v for the analyzed time step. f not given, gird is contructed on the whole profile.

\end{itemize}

\item[{Returns}] \leavevmode
connectivity table and grid point

\end{description}\end{quote}

\sphinxstylestrong{Form of the function in summary}
\begin{itemize}
\item {} 
if vh\_pro\_t:
\begin{itemize}
\item {} 
find cordinate under water and used this to update coord\_pro

\item {} 
see if there is islands, find the island limits and the holes indicating the inside/outside of the islands

\end{itemize}

\item {} 
find the point which give the end/start of the segment defining the grid limit

\item {} 
find all point which need to be added to the grid and add extra profile if needed

\item {} 
based on the start/end points and the island limits, create the segments which gives the grid limit

\item {} 
triangulate and so create the grid

\item {} 
flag point which are overlapping in two grids

\end{itemize}

For more info, see the document ``More info on the grid''.

\end{fulllineitems}

\index{create\_grid\_only\_1\_profile() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.create_grid_only_1_profile}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{create\_grid\_only\_1\_profile}}{\emph{coord\_pro, nb\_pro\_reach={[}0, 10000000000.0{]}, vh\_pro\_t={[}{]}, sub\_pg={[}{]}, sub\_dom={[}{]}, sub\_per={[}{]}, virtual\_startend=False, divgiv={[}{]}, h0ok=False}}{}
This function creates the grid from the coord\_pro data using one additional profil in the middle. No triangulation.
The interpolation of the data is done in this function also, contrarily to create\_grid().
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the profile coordinates (x,y, h, dist along) the profile

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- the number of profile by reach

\item {} 
\sphinxstyleliteralstrong{vh\_pro\_t} -- the data with heigh and velocity, giving the river limits

\item {} 
\sphinxstyleliteralstrong{sub\_pg} -- the data from the coarser substrate, in case the hydraulic model already contains substrate data

\item {} 
\sphinxstyleliteralstrong{sub\_dom} -- the data from the dominant substrate, in case the hydraulic model already contains substrate data

\item {} 
\sphinxstyleliteralstrong{sub\_per} -- the data from the subtrate in a percentage form

\item {} 
\sphinxstyleliteralstrong{virtual\_startend} -- this indicates that the first and the lst profile is doubled. This is used so that the
grid around the last and the first profile extend after or before this profile, so that all porfile have
the same weight. Useful for LAMMI moslty.

\item {} 
\sphinxstyleliteralstrong{divgiv} -- in case we do not want to middle profile to be at an equal distance of both profile(one value by profile)

\item {} 
\sphinxstyleliteralstrong{h0ok} -- if we want to keep in the grid the cell with an height or velocity of zero (False usually)

\end{itemize}

\item[{Returns}] \leavevmode
the connevtivity table, the coordinate of the grid, the centroid of the grid, the velocity data on this
grid, the height data on this grid.

\end{description}\end{quote}

For more info on this function, see the document ``More info on the grid''.

\end{fulllineitems}

\index{cut\_2d\_grid() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.cut_2d_grid}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{cut\_2d\_grid}}{\emph{ikle}, \emph{point\_all}, \emph{water\_height}, \emph{velocity}, \emph{min\_height=0.001}, \emph{get\_ind\_new=False}}{}
This function cut the grid of the 2D model to have correct wet surface. If we have a node with h\textless{}0 and other node(s)
with h\textgreater{}0, this function cut the cells to find the wetted perimeter, assuminga linear decrease in the water elevation.
This function works for one time steps and for one reach
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{ikle} -- the connectivity table of the 2D grid

\item {} 
\sphinxstyleliteralstrong{point\_all} -- the coordinate of the points

\item {} 
\sphinxstyleliteralstrong{water\_height} -- the water height data given on the nodes

\item {} 
\sphinxstyleliteralstrong{velocity} -- the velcoity given on the nodes

\item {} 
\sphinxstyleliteralstrong{min\_height} -- the minimum water height considered (as model sometime have cell with very low water height)

\item {} 
\sphinxstyleliteralstrong{get\_ind\_new} -- If True, a np.array is returned which give the indices of the old cell in the order of the new cells

\end{itemize}

\item[{Returns}] \leavevmode
the update connectivity table, the coodinate of the point, the height of the water and the
velocity on the updated grid and (if get\_ind\_new is True) the indices of the old connectivity table in
the new cell orders.

\end{description}\end{quote}

\end{fulllineitems}

\index{cut\_2d\_grid\_all\_reach() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.cut_2d_grid_all_reach}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{cut\_2d\_grid\_all\_reach}}{\emph{ikle\_all}, \emph{point\_all}, \emph{inter\_height\_all}, \emph{inter\_vel\_all}, \emph{min\_height=0.001}, \emph{get\_ind\_new=False}}{}
This function si just use to call cut\_2d-grid for all reach. So that if we have a river with more than reach, we
do not need to add a for loops to call for all reach. Sometime it can save place. This can be only use for one
time step.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{ikle\_all} -- the connectivity table of the 2D grid for all reach

\item {} 
\sphinxstyleliteralstrong{point\_all} -- the coordinate of the points for all reach

\item {} 
\sphinxstyleliteralstrong{inter\_height\_all} -- the water height data given on the nodes for all reach

\item {} 
\sphinxstyleliteralstrong{inter\_vel\_all} -- the velcoity given on the nodes for all reach

\item {} 
\sphinxstyleliteralstrong{min\_height} -- the minimum water height which is kept inthe grid

\item {} 
\sphinxstyleliteralstrong{get\_ind\_new} -- If True, a list is returned which give the indices of the old cell in the order of the new cells
One list by reach (so a list of np.array is returned)

\end{itemize}

\item[{Returns}] \leavevmode
the update connectivity table, the coodinate of the point, the height of the water and the
velocity on the updated grid fro all reaches

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_profile\_between() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.find_profile_between}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{find\_profile\_between}}{\emph{coord\_pro\_p0}, \emph{coord\_pro\_p1}, \emph{nb\_pro}, \emph{trim=True}, \emph{divgiv={[}{]}}}{}
Find n profile between two profiles which are not straight. This functions is useful to create the grid from 1D model
as profile in 1D model are often far away from another.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro\_p0} -- the coord\_pro (x,y,h, z) of the first profile

\item {} 
\sphinxstyleliteralstrong{coord\_pro\_p1} -- the coord\_pro (x,y,h, z) of the second profile

\item {} 
\sphinxstyleliteralstrong{nb\_pro} -- the number of profile to add

\item {} 
\sphinxstyleliteralstrong{trim} -- If True cut the end and start of profile to avoid to have part of the grid outside of the water limit

\item {} 
\sphinxstyleliteralstrong{divgiv} -- one value by profile, used to not put the middle profile at an euql distance of two profile

\end{itemize}

\item[{Returns}] \leavevmode
a list with the updated profiles

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_crossing\_segment\_sub() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.get_crossing_segment_sub}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{get\_crossing\_segment\_sub}}{\emph{p1sub, p2sub, lim\_here, lim\_by\_reachr, point\_all, island, ind\_seg\_sub\_ini={[}0{]}}}{}
This function looks at one substrate segment and find the crossing points of this semgent with the different
segment which composed the hydrological grid. This function is useful to cut the grid as a function of the form
of the substrate layer (to avoid having cells in the hydrological grid which have two substrate value).

If island switch is True, lim\_here is the limit of the island, so
inside the polygon is outside the river. If island is false, lim\_here is the limit of the reach under investigation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{p1sub} -- the start point of the substrate semgent

\item {} 
\sphinxstyleliteralstrong{p2sub} -- the end point of the substrate segment

\item {} 
\sphinxstyleliteralstrong{lim\_here} -- the reach?island limit given in the coordinate system

\item {} 
\sphinxstyleliteralstrong{lim\_by\_reachr} -- the limits for reach r which will be given to triangle given by point\_all indices.

\item {} 
\sphinxstyleliteralstrong{point\_all} -- all the point (ccordinates) which will be given to triangle

\item {} 
\sphinxstyleliteralstrong{island} -- a boolean indicating if we are on an island or not

\item {} 
\sphinxstyleliteralstrong{ind\_seg\_sub\_ini} -- the indices of the first segment add by p1sub et p2sub by the reach. Only used island = true

\end{itemize}

\item[{Returns}] \leavevmode
the updated point\_all and lim\_by\_reach

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_new\_point\_and\_cell\_1\_profil() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.get_new_point_and_cell_1_profil}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{get\_new\_point\_and\_cell\_1\_profil}}{\emph{coord\_pro\_p}, \emph{vh\_pro\_t\_p}, \emph{point\_mid\_x}, \emph{point\_mid\_y}, \emph{point\_all}, \emph{ikle}, \emph{point\_c}, \emph{dir}, \emph{h0ok=False}}{}
This function is use by create\_grid\_one\_profile. It creates the grid for one profile (one ``line'' of triangle).
To create the whole grod this function is called for each profile.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro\_p} -- the coordinates of the profile

\item {} 
\sphinxstyleliteralstrong{vh\_pro\_t\_p} -- the height and velocity data of the profile analysed

\item {} 
\sphinxstyleliteralstrong{point\_mid\_x} -- the x coodinate of the points forming the middle profile

\item {} 
\sphinxstyleliteralstrong{point\_mid\_y} -- the y coordinate of the points forming the middle profile

\item {} 
\sphinxstyleliteralstrong{point\_all} -- the point of the grid

\item {} 
\sphinxstyleliteralstrong{ikle} -- the connectivity table of the grid

\item {} 
\sphinxstyleliteralstrong{point\_c} -- the central point of each cell

\item {} 
\sphinxstyleliteralstrong{dir} -- in which direction are we going around the profile (upstream/downstram)

\item {} 
\sphinxstyleliteralstrong{h0ok} -- if True, cell with a water height or a velocity of zero are kept

\end{itemize}

\item[{Returns}] \leavevmode
point\_all, ikle, point\_c (the centroid of the cell)

\end{description}\end{quote}

For more info, see the document ``More info on the grid''.

\end{fulllineitems}

\index{grid\_and\_interpo() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.grid_and_interpo}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{grid\_and\_interpo}}{\emph{vh\_pro}, \emph{coord\_pro}, \emph{nb\_pro\_reach}, \emph{interpo\_choice}, \emph{pro\_add=1}}{}
This function forms the link between GUI and the various grid and interpolation functions. Is called by
the ``loading'' function of hec-ras 1D, Mascaret and Rubar BE. It used to be a method in hydro\_GUI2, but we have
to move it as a function to create a second thread. Hence, the high amount of parameter.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{vh\_pro} -- Velcoity and height data

\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the position of the profile

\item {} 
\sphinxstyleliteralstrong{nb\_pro\_reach} -- the number of profile by reach

\item {} 
\sphinxstyleliteralstrong{interpo\_choice} -- an int which gives the choice of interpolatin (see below)

\item {} 
\sphinxstyleliteralstrong{pro\_add} -- the number of profile for be added (for interpoation method 1 and 2)

\end{itemize}

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

Here are the list of the interpolation choice:
\begin{itemize}
\item {} 
0 Use the function create\_grid\_only\_1\_profile() from manage\_grid\_8.py for all time steps.

\item {} 
1 Use the function create\_grid() from manage\_grid\_8.py for all time steps followed by a linear interpolation

\item {} 
2 Use the function create\_grid() from manage\_grid\_8.py for all time steps followed by a nearest neighbour interpolation

\item {} \begin{description}
\item[{3 Use create\_grid() for the whole profile, make a linear inteporlation on this grid for all time step}] \leavevmode
and use the cut\_2d\_grid to get a grid with only the wet profile for all time step (This part was only started.
It was not finished.)

\end{description}

\end{itemize}

For the interpolation case 1 and 2, it is possible that the triangle module crashes if the geometry of the
river is too complicated. Generally, the interpolation method 1 and 2 gives smoother results with more control
over the interpolation option and the size of the cells. However, these two interpolation methods are more sensitive
to the inputs, especially if the river has a lot of ``island'' (strongly anastomotic). So the interpoliation method 0
is more adequate in this case.

\end{fulllineitems}

\index{inside\_polygon() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.inside_polygon}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{inside\_polygon}}{\emph{seg\_poly}, \emph{point}}{}
This function find if a point is inside a polygon, using a ray casting algorythm.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{seg\_poly} -- the segmentS forming the polygon

\item {} 
\sphinxstyleliteralstrong{point} -- the point which is indide or outside the polygon

\end{itemize}

\item[{Returns}] \leavevmode
True is the point is inside the polygon, false otherwise

\end{description}\end{quote}

\end{fulllineitems}

\index{interp\_weights() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.interp_weights}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{interp\_weights}}{\emph{xyz}, \emph{uvw}}{}
This fucntion is used by the function pass\_grid\_cell\_to\_node\_lin(). To optimize the interpolation when more than one time step
is done on the same grid, the first step of scipy.griddata.interolate are done here and are called only once for all
time step. Hence, this function is the first part of a quicker ``scipy.interpolate.griddata''
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{xyz} -- 

\item {} 
\sphinxstyleliteralstrong{uvw} -- 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{interpo\_linear() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.interpo_linear}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{interpo\_linear}}{\emph{point\_all}, \emph{coord\_pro}, \emph{vh\_pro\_t}}{}
Using scipy.gridata, this function interpolates the 1.5 D velocity and height to the new grid
It can be used for only one time step. The interpolation is linear.
It is usually called after create\_grid have been called.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{point\_all} -- the coordinate of the grid point

\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the coordinate of the profile. It should be coherent with the coordinate from vh\_pro.
To insure this, pass coord\_pro through the function ``create\_grid'' with the same vh\_pro as input

\item {} 
\sphinxstyleliteralstrong{vh\_pro\_t} -- for each profile, dist along the profile, water height and velocity at a particular time step

\end{itemize}

\item[{Returns}] \leavevmode
the new interpolated data for velocity and water height

\end{description}\end{quote}

\end{fulllineitems}

\index{interpo\_nearest() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.interpo_nearest}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{interpo\_nearest}}{\emph{point\_all}, \emph{coord\_pro}, \emph{vh\_pro\_t}}{}
Using scipy.gridata, this function interpolates the 1.5 D velocity and height to the new grid
It can be used for only one time step. The interpolation is nearest neighbours.
It is usually called after create\_grid have been called.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{point\_all} -- the coordinate of the grid point

\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the coordinate of the profile. It should be coherent with the coordinate from vh\_pro.
To insure this, pass coord\_pro through the function ``create\_grid'' with the same vh\_pro as input

\item {} 
\sphinxstyleliteralstrong{vh\_pro\_t} -- for each profile, dist along the profile, water height and velocity at a particular time step

\end{itemize}

\item[{Returns}] \leavevmode
the new interpolated data for velocity and water height

\end{description}\end{quote}

\end{fulllineitems}

\index{interpolate\_opti() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.interpolate_opti}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{interpolate\_opti}}{\emph{values}, \emph{vtx}, \emph{wts}}{}
This fucntion is called by interp\_weights(). It is used in the optimization of the function pass\_grid\_cell\_to\_node\_lin().
This idea of this optimization is to not re-do some calculation when many interpolation are done on the same grid.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{values} -- 

\item {} 
\sphinxstyleliteralstrong{vtx} -- 

\item {} 
\sphinxstyleliteralstrong{wts} -- 

\item {} 
\sphinxstyleliteralstrong{fill\_value} -- A new value for point where

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{intersection\_seg() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.intersection_seg}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{intersection\_seg}}{\emph{p1hyd}, \emph{p2hyd}, \emph{p1sub}, \emph{p2sub}, \emph{col=True}, \emph{wig=1e-07}}{}
This function finds if there is an intersection between two segment (AB and CD). Idea from :
\url{http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect}
It is based on the caluclaion of the cross-product z= 0 for 2D

Careful there is many function using this function, so change here should be thought about. There is a precision
management, so everythion smaller than 10**-8 is ok
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{p1hyd} -- point A

\item {} 
\sphinxstyleliteralstrong{p2hyd} -- point B

\item {} 
\sphinxstyleliteralstrong{p1sub} -- point C

\item {} 
\sphinxstyleliteralstrong{p2sub} -- point D

\item {} 
\sphinxstyleliteralstrong{col} -- if True, colinear segment crossed. If false, they do not cross

\item {} 
\sphinxstyleliteralstrong{wig} -- ``wiggle room'', how precise should the calculation be (careful, complicated!)

\end{itemize}

\item[{Returns}] \leavevmode
intersect (True or False) and the crossing point (if True, empty is False)

\end{description}\end{quote}

\end{fulllineitems}

\index{linear\_h\_cross() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.linear_h_cross}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{linear\_h\_cross}}{\emph{p1}, \emph{p2}, \emph{h1}, \emph{h2}, \emph{minwh=0.0}}{}
This function is called by cut\_2D\_grid. It find the intersection point along a side of the triangle if part of a
cells is dry.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{p1} -- the coordinate (x,y) of the first point

\item {} 
\sphinxstyleliteralstrong{p2} -- the coordinate (x,y) of the first point

\item {} 
\sphinxstyleliteralstrong{h1} -- the water height at p1 (might be negative or positive)

\item {} 
\sphinxstyleliteralstrong{h2} -- the water height at p2 (might be negative or positive)

\end{itemize}

\item[{Returns}] \leavevmode
the intersection point

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.main}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{main}}{}{}
Used to test this module

\end{fulllineitems}

\index{newp() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.newp}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{newp}}{\emph{p0}, \emph{p1}, \emph{extra\_pro}}{}
This function find the start/end of the added profile. If only one profile is needed, it is just the
point in the middle of the start/end of the profile. If mroe than one profile is needed, there are linearly
distributed. This function only give the start and the end of the profile, the profile in full are constructed using
find\_profile\_between()
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{p0} -- the point at the profile p

\item {} 
\sphinxstyleliteralstrong{p1} -- the point at the profile p-1

\item {} 
\sphinxstyleliteralstrong{extra\_pro} -- the number of extra profile needed

\end{itemize}

\item[{Returns}] \leavevmode
the start/end of the new profile

\end{description}\end{quote}

\end{fulllineitems}

\index{pass\_grid\_cell\_to\_node\_lin() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.pass_grid_cell_to_node_lin}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{pass\_grid\_cell\_to\_node\_lin}}{\emph{point\_all}, \emph{coord\_c}, \emph{vel\_in}, \emph{height\_in}, \emph{warn1=True}, \emph{vtx\_all={[}{]}}, \emph{wts\_all={[}{]}}}{}
HABBY uses nodal information. Some hydraulic models have only ouput on the cells. This function pass
from cells information to nodal information. The interpolation is linear and the cell centroid is used as the
point where the cell information is carried. It can be used for one time step only.

This function is also used by hydraulic\_chronic to pass from one discharge to another because each discharge
has it own grid. hence, we need to interpolate
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{point\_all} -- the coordinates of grid points (new grid here)

\item {} 
\sphinxstyleliteralstrong{coord\_c} -- the coordintes of the centroid of the cells (old grid here)

\item {} 
\sphinxstyleliteralstrong{vel\_in} -- the velocity data by cell

\item {} 
\sphinxstyleliteralstrong{height\_in} -- the height data by cell

\item {} 
\sphinxstyleliteralstrong{warn1} -- if True , show the warning (usually warn1 is True for t=0, False afterwards)

\item {} 
\sphinxstyleliteralstrong{vtx\_all} -- if it exists it means than the same grid was interpolated before. This info can be reused to
speed up the interpolation of mulitple time step. (optional, need wts)

\item {} 
\sphinxstyleliteralstrong{wts\_all} -- if it exists it means than the same grid was interpolated before. This info can be reused to
speed up the interpolation of mulitple time step. (optional, need vtx)

\end{itemize}

\item[{Returns}] \leavevmode
velocity and height data by node

\end{description}\end{quote}

\sphinxstylestrong{Technical Comment}

This function can be very slow when a lot of time step needs to be interpolated if done directlty with
scipy.interpolate. It was optimized for this case:
\url{http://stackoverflow.com/questions/20915502/speedup-scipy-griddata-for-multiple}-
interpolations-between-two-irregular-grids

\end{fulllineitems}

\index{plot\_grid() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.plot_grid}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{plot\_grid}}{\emph{point\_all\_reach}, \emph{ikle\_all}, \emph{lim\_by\_reach}, \emph{hole\_all}, \emph{overlap}, \emph{point\_c\_all={[}{]}}, \emph{inter\_vel\_all={[}{]}}, \emph{inter\_h\_all={[}{]}}, \emph{path\_im={[}{]}}}{}
This is a function to plot a grid and the output. It is mosty used to debug the grid creation. Contrarily to the more
simple function plot\_grid\_simple, it is posible to plot the position of the holes (which indicates the dry area),
the limits of the reaches used by triangle, the overlap between two reaches, and so on.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{point\_all\_reach} -- the grid point by reach

\item {} 
\sphinxstyleliteralstrong{ikle\_all} -- the connectivity table by reach

\item {} 
\sphinxstyleliteralstrong{lim\_by\_reach} -- the segment giving the limits of the grid

\item {} 
\sphinxstyleliteralstrong{hole\_all} -- the coordinates of the holes

\item {} 
\sphinxstyleliteralstrong{overlap} -- the point of each reach which are also on an other reach

\item {} 
\sphinxstyleliteralstrong{point\_c\_all} -- the centroid of each element

\item {} 
\sphinxstyleliteralstrong{inter\_vel\_all} -- the interpolated velocity for each reach

\item {} 
\sphinxstyleliteralstrong{inter\_h\_all} -- the interpolated height

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the image

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_grid\_simple() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.plot_grid_simple}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{plot\_grid\_simple}}{\emph{point\_all\_reach}, \emph{ikle\_all}, \emph{fig\_opt}, \emph{inter\_vel\_all={[}{]}}, \emph{inter\_h\_all={[}{]}}, \emph{path\_im={[}{]}}, \emph{merge\_case=False}, \emph{time\_step=0}}{}
This is the function to plot grid output for one time step. The data is one the node. A more complicated function
exists to plot the grid and additional information (manage-grid\_8.plot\_grid()) in case there are needed to debug.
The present function only plot the grid and output without more information.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{point\_all\_reach} -- the coordinate of the point. This is given by reaches.

\item {} 
\sphinxstyleliteralstrong{ikle\_all} -- the connectivity table. This is given by reaches.

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- the dictionary with the different options to create the figures

\item {} 
\sphinxstyleliteralstrong{inter\_vel\_all} -- the velcoity data. This is given by reaches.

\item {} 
\sphinxstyleliteralstrong{inter\_h\_all} -- the height data. This is given by reaches.

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where the figure should be saved

\item {} 
\sphinxstyleliteralstrong{merge\_case} -- If True, we plot data from grid with merged substrate and hydrological data

\item {} 
\sphinxstyleliteralstrong{time\_step} -- time step to be added to the title

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_coord\_pro\_with\_vh\_pro() (in module src.manage\_grid\_8)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.manage_grid_8.update_coord_pro_with_vh_pro}}\pysiglinewithargsret{\sphinxcode{src.manage\_grid\_8.}\sphinxbfcode{update\_coord\_pro\_with\_vh\_pro}}{\emph{coord\_pro}, \emph{vh\_pro\_t}}{}
The points describing the profile elevation and the points where velocity is measured might not be the same.
Additionally,part of the profile might be dry and we have added points giving the wetted limit in vh\_pro\_t. They were
are not in the original profil (coord\_pro). In this function,
coord\_pro is recalculated to account for these modicfications. It is used by create\_grid() and
create\_grid\_one\_profile, but only if vh\_pro\_t exists.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_pro} -- the original coord\_pro

\item {} 
\sphinxstyleliteralstrong{vh\_pro\_t} -- the value and position of h and velcoity measurement with the river limits

\end{itemize}

\item[{Returns}] \leavevmode
updated coord\_pro

\end{description}\end{quote}

More information in the document ``More info on the grid'' (linked above)

\end{fulllineitems}



\section{Estimhab -source}
\label{\detokenize{index:estimhab-source}}
in src/estimhab.py

The module contains the Estimhab model. For an explanation on the estimhab model, please see
the pdf document \sphinxcode{estimhab2008}
\phantomsection\label{\detokenize{index:module-src.estimhab}}\index{src.estimhab (module)}\index{estimhab() (in module src.estimhab)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.estimhab.estimhab}}\pysiglinewithargsret{\sphinxcode{src.estimhab.}\sphinxbfcode{estimhab}}{\emph{qmes}, \emph{width}, \emph{height}, \emph{q50}, \emph{qrange}, \emph{substrat}, \emph{path\_bio}, \emph{fish\_name}, \emph{path\_im}, \emph{pict=False}, \emph{fig\_opt=\{\}}, \emph{path\_txt={[}{]}}}{}
This the function which forms the Estimhab model in HABBY. It is a reproduction in python of the excel file which
forms the original Estimhab model.. Unit in meter amd m\textasciicircum{}3/sec
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{qmes} -- the two measured discharge

\item {} 
\sphinxstyleliteralstrong{width} -- the two measured width

\item {} 
\sphinxstyleliteralstrong{height} -- the two measured height

\item {} 
\sphinxstyleliteralstrong{q50} -- the natural median discharge

\item {} 
\sphinxstyleliteralstrong{qrange} -- the range of discharge

\item {} 
\sphinxstyleliteralstrong{substrat} -- mean height of substrat

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where the image should be saved

\item {} 
\sphinxstyleliteralstrong{path\_bio} -- the path to the xml file with the information on the fishes

\item {} 
\sphinxstyleliteralstrong{fish\_name} -- the name of the fish which have to be analyzed

\item {} 
\sphinxstyleliteralstrong{pict} -- if true the figure is shown. If false, the figure is not shown

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- a dictionnary with the figure option

\item {} 
\sphinxstyleliteralstrong{path\_txt} -- the path where to send the text data

\end{itemize}

\item[{Returns}] \leavevmode
habitat value and useful surface (VH and SPU) as a function of discharge

\end{description}\end{quote}

\sphinxstylestrong{Technical comments and walk-through}

First, we get all the discharges on which we want to calculate the SPU (surface ponderée utile),
using the inputs from the user.

Next we use hydrological rating curves (info on google if needed) to get the height and the width of the river for
all discharge. The calculation is based on the width and height of the river measured at two discharges (given by the
user).

Next, we get other parameters which are used in the preference curves such as the Froude number of
the mean discharge or the Reynolds number.

Next, we load the fish data contains in the xml files in the biology folder. Careful, this is not the xml project
file. This are the xml files described above in the “Class EstimhabW” section. There are one xml file per fish and
they described the preference curves. For the argumentation on the form of the relationship, report yourself to the
documentation of Estimhab (one pdf file should in the folder “doc “ in HABBY).

Then, we calculate the habitat values (VH and SPU). Finally, we plot the results in a figure and we save it as
a text file.

\end{fulllineitems}

\index{main() (in module src.estimhab)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.estimhab.main}}\pysiglinewithargsret{\sphinxcode{src.estimhab.}\sphinxbfcode{main}}{}{}
Used to test this module.

\end{fulllineitems}

\index{pass\_to\_float\_estimhab() (in module src.estimhab)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.estimhab.pass_to_float_estimhab}}\pysiglinewithargsret{\sphinxcode{src.estimhab.}\sphinxbfcode{pass\_to\_float\_estimhab}}{\emph{var\_name}, \emph{root}}{}
This is a function to pass from an xml element to a float
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{root} -- the root of the open xml file

\item {} 
\sphinxstyleliteralstrong{var\_name} -- the name of the attribute in the xml file

\end{itemize}

\item[{Returns}] \leavevmode
the float data

\end{description}\end{quote}

\end{fulllineitems}



\section{Stathab - source}
\label{\detokenize{index:stathab-source}}
in src/stathab\_c

This module contains the function used to run the model stathab.For an explanation on
the form of the stathab input, please see the pdf document \sphinxcode{stathabinfo}
\phantomsection\label{\detokenize{index:module-src.stathab_c}}\index{src.stathab\_c (module)}\index{Stathab (class in src.stathab\_c)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab}}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{src.stathab\_c.}\sphinxbfcode{Stathab}}{\emph{name\_prj}, \emph{path\_prj}}{}
The class for the Stathab model
\index{create\_hdf5() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.create_hdf5}}\pysiglinewithargsret{\sphinxbfcode{create\_hdf5}}{}{}
A function to create an hdf5 file from the loaded txt. It creates ``name\_prj''\_STATHAB.h5, an hdf5 file with the
info from stathab

\end{fulllineitems}

\index{dengauss() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.dengauss}}\pysiglinewithargsret{\sphinxbfcode{dengauss}}{\emph{x}}{}
gaussian density, used only for debugging purposes.
This is not used in Habby, but can be useful if scipy is not available (remplace all stat.norm.cdf with
dengauss)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{x} -- the parameter of the gaussian

\item[{Returns}] \leavevmode
the gaussian density

\end{description}\end{quote}

\end{fulllineitems}

\index{dist\_h() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.dist_h}}\pysiglinewithargsret{\sphinxbfcode{dist\_h}}{\emph{sh0}, \emph{h0}, \emph{bornh}, \emph{h}}{}
The calculation of height distribution  acrros the river
The distribution is a mix of an exponential and guassian.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{sh0} -- the sh of the original data
sh is the parameter of the distribution, gives the relative importance of ganussian and exp distrbution

\item {} 
\sphinxstyleliteralstrong{h} -- the mean height data

\item {} 
\sphinxstyleliteralstrong{h0} -- the mean height

\item {} 
\sphinxstyleliteralstrong{bornh} -- the limits of each class of height

\end{itemize}

\item[{Returns}] \leavevmode
disth the distribution of heights across the river for the mean height h.

\end{description}\end{quote}

\end{fulllineitems}

\index{dist\_h\_trop() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.dist_h_trop}}\pysiglinewithargsret{\sphinxbfcode{dist\_h\_trop}}{\emph{v}, \emph{h}, \emph{mean\_slope}}{}
This function calulate the height distribution for steep tropical stream based on the R code from
Girard et al. (stathab\_hyd\_steep). The frequency distribution is based on empirical data which
is given in the list of numbers in the codes below. The final frequency distribution is in the form:
t xf1 + (1-t) x f where t is a function of the froude number and the mean slope of the station.

The height limits are considered constant here (constrarily to dist\_h where they are given in the parameter
bornh).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{v} -- the velcoity for this discharge

\item {} 
\sphinxstyleliteralstrong{h} -- the height for this discharge

\item {} 
\sphinxstyleliteralstrong{mean\_slope} -- the mean slope of the station (usally in the data\_ii{[}0{]} variable)

\end{itemize}

\item[{Returns}] \leavevmode
the distribution of height

\end{description}\end{quote}

\end{fulllineitems}

\index{dist\_v() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.dist_v}}\pysiglinewithargsret{\sphinxbfcode{dist\_v}}{\emph{h}, \emph{d}, \emph{bornv}, \emph{v}}{}
The calculation of velocity distribution across the river
The distribution is a mix of an exponential and guassian.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{h} -- the height which is related to the mean velocity v

\item {} 
\sphinxstyleliteralstrong{d} -- granulo moyenne

\item {} 
\sphinxstyleliteralstrong{bornv} -- the born of the velocity

\item {} 
\sphinxstyleliteralstrong{v} -- the mean velocity

\end{itemize}

\item[{Returns}] \leavevmode
the distribution of velocity across the river

\end{description}\end{quote}

\end{fulllineitems}

\index{dist\_v\_trop() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.dist_v_trop}}\pysiglinewithargsret{\sphinxbfcode{dist\_v\_trop}}{\emph{v}, \emph{h}, \emph{h\_waterfall}, \emph{length\_stat}}{}
This function calulate the velocity distribution for steep tropical stream based on the R code from
Girard et al. (stathab\_hyd\_steep). The frequency distribution is based on empirical data which
is given in the list of numbers in the codes below. The final frequency distribution is in the form:
t x f1 + (1-t) x f where t depends on the ratio of the length of station and the height of the waterfall.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{v} -- the velcoity for this discharge

\item {} 
\sphinxstyleliteralstrong{h} -- the height for this discharge

\item {} 
\sphinxstyleliteralstrong{h\_waterfall} -- the height of the waterfall

\item {} 
\sphinxstyleliteralstrong{length\_stat} -- the length of the station

\end{itemize}

\item[{Returns}] \leavevmode
the distribution of velocity

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_path\_hdf5\_stat() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.find_path_hdf5_stat}}\pysiglinewithargsret{\sphinxbfcode{find\_path\_hdf5\_stat}}{}{}
A function to find the path where to save the hdf5 file. Careful a simialar one is in hydro\_GUI\_2.py
and in estimhab\_GUI. By default,
path\_hdf5 is in the project folder in the folder `fichier\_hdf5'.

\end{fulllineitems}

\index{find\_sh0() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.find_sh0}}\pysiglinewithargsret{\sphinxbfcode{find\_sh0}}{\emph{disthmesr}, \emph{h0}}{}
the function to find sh0, using a minimzation technique. Not used because the output was string.
Possibly an error on the bornes? We remplaced this function by the function find\_sh0\_maxvrais().
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{disthmesr} -- the measured distribution of height

\item {} 
\sphinxstyleliteralstrong{h0} -- the measured mean height

\end{itemize}

\item[{Returns}] \leavevmode
the optimized sh0

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_sh0\_maxvrais() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.find_sh0_maxvrais}}\pysiglinewithargsret{\sphinxbfcode{find\_sh0\_maxvrais}}{\emph{disthmesr}, \emph{h0}}{}
the function to find sh0, using the maximum of vraisemblance.
This function aims at reproducing the results from the c++ code. Hence, no use of scipy
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{disthmesr} -- the measured distribution of height

\item {} 
\sphinxstyleliteralstrong{h0} -- the measured mean height

\end{itemize}

\item[{Returns}] \leavevmode
the optimized sh0

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_stathab\_from\_hdf5() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.load_stathab_from_hdf5}}\pysiglinewithargsret{\sphinxbfcode{load\_stathab\_from\_hdf5}}{}{}
A function to load the file from an hdf5 whose name is given in the xml project file. If the name of the
file is a relative path, use the path\_prj to create an absolute path.

It works for tropical and temperate rivers. It checks the river type in the hdf5  files and
used this river type regardless of the one curently used by the GUI. The method load\_hdf5 in stathab\_GUI
get the value of self.riverint from the object mystathab to check the cohrenence between the GUI and the loaded
hdf5.

\end{fulllineitems}

\index{load\_stathab\_from\_txt() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.load_stathab_from_txt}}\pysiglinewithargsret{\sphinxbfcode{load\_stathab\_from\_txt}}{\emph{reachname\_file}, \emph{end\_file\_reach}, \emph{name\_file\_allreach}, \emph{path}}{}
A function to read and check the input from stathab based on the text files.
All files should be in the same folder.
The file Pref.txt is read in run\_stathab.
If self.fish\_chosen is not present, all fish in the preference file are read.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{reachname\_file} -- the file with the name of the reaches to study (usually listirv)

\item {} 
\sphinxstyleliteralstrong{end\_file\_reach} -- the ending of the files whose names depends on the reach (with .txt or .csv)

\item {} 
\sphinxstyleliteralstrong{name\_file\_allreach} -- the name of the file common to all reaches

\item {} 
\sphinxstyleliteralstrong{path} -- the path to the file

\end{itemize}

\item[{Returns}] \leavevmode
the inputs needed for run\_stathab

\end{description}\end{quote}

\end{fulllineitems}

\index{power\_law() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.power_law}}\pysiglinewithargsret{\sphinxbfcode{power\_law}}{\emph{qwh\_r}}{}
The function to calculate power law for discharge and width
ln(h0 = a1 + a2 ln(Q)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{qwh\_r} -- an array where each line in one observatino of Q, width and height

\item[{Returns}] \leavevmode
the coeff of the regression

\end{description}\end{quote}

\end{fulllineitems}

\index{save\_xml\_stathab() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.save_xml_stathab}}\pysiglinewithargsret{\sphinxbfcode{save\_xml\_stathab}}{\emph{no\_hdf5=False}}{}
The function which saves the function related to stathab in the xml projexct files
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{no\_hdf5} -- If True, no hdf5 file was created (usually because Stathab crashed at some points)

\end{description}\end{quote}

\end{fulllineitems}

\index{savefig\_stahab() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.savefig_stahab}}\pysiglinewithargsret{\sphinxbfcode{savefig\_stahab}}{\emph{show\_class=True}}{}
A function to save the results in text and the figure. If the argument show\_class is True,
it shows an extra figure with the size of the different height, granulo, and velocity classes. The optional
figure only works when stathab1 for temperate river is used.

\end{fulllineitems}

\index{savetxt\_stathab() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.savetxt_stathab}}\pysiglinewithargsret{\sphinxbfcode{savetxt\_stathab}}{}{}
A function to save the stathab result in .txt form

\end{fulllineitems}

\index{stathab\_calc() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.stathab_calc}}\pysiglinewithargsret{\sphinxbfcode{stathab\_calc}}{\emph{path\_pref='.'}, \emph{name\_pref='Pref.txt'}}{}
The function to calculate stathab output.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{path\_pref} -- the path to the preference file

\item {} 
\sphinxstyleliteralstrong{name\_pref} -- the name of the preference file

\end{itemize}

\item[{Returns}] \leavevmode
the biological preferrence index (np.array of {[}reach, specices, nbclaq{]} size), surface or volume by class, etc.

\end{description}\end{quote}

\end{fulllineitems}

\index{stathab\_trop\_biv() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.stathab_trop_biv}}\pysiglinewithargsret{\sphinxbfcode{stathab\_trop\_biv}}{\emph{path\_bio}}{}
This function calculate the stathab outputs  for the bivariate preference file in the case where the river is
steep and in the tropical regions (usually the islands of Reunion and Guadeloupe).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{path\_bio} -- 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{stathab\_trop\_univ() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.stathab_trop_univ}}\pysiglinewithargsret{\sphinxbfcode{stathab\_trop\_univ}}{\emph{path\_bio}, \emph{by\_vol}}{}
This function calculate the stathab outputs  for the univariate preference file in the case where the river is
steep and in the tropical regions (usually the islands of Reunion and Guadeloupe).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{path\_bio} -- the path to the preference file usually biology/stathab

\item {} 
\sphinxstyleliteralstrong{by\_vol} -- If True the output is by volum (VPU instead of SPU) from the velcoity pref file

\end{itemize}

\item[{Returns}] \leavevmode
the SPU or VPU

\end{description}\end{quote}

\end{fulllineitems}

\index{test\_stathab() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.test_stathab}}\pysiglinewithargsret{\sphinxbfcode{test\_stathab}}{\emph{path\_ori}}{}
A short function to test part of the outputs of stathab in temperate rivers against the C++ code,
It is not used in Habby but it is practical to debug.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{path\_ori} -- the path to the files from stathab based on the c++ code

\end{description}\end{quote}

\end{fulllineitems}

\index{test\_stathab\_trop\_biv() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.test_stathab_trop_biv}}\pysiglinewithargsret{\sphinxbfcode{test\_stathab\_trop\_biv}}{\emph{path\_ori}}{}
A short function to test part of the outputs of the stathab tropical rivers against the R code
in the bivariate mode. It is not used in Habby but it is practical to debug. Stathab\_trop+biv should be
executed before. For the moment only the fish SIC is tested.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{path\_ori} -- the path to the output files from stathab based on the R code

\end{description}\end{quote}

\end{fulllineitems}

\index{test\_stathab\_trop\_uni() (src.stathab\_c.Stathab method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.Stathab.test_stathab_trop_uni}}\pysiglinewithargsret{\sphinxbfcode{test\_stathab\_trop\_uni}}{\emph{path\_ori}, \emph{by\_vel=True}}{}
A short function to test part of the outputs of the stathab tropical rivers against the R code
in the univariate mode. It is not used in Habby but it is practical to debug. Stathab\_trop\_uni should be
executed before. For the moment only the fish SIC is tested.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{path\_ori} -- the path to the output files from stathab based on the R code

\item {} 
\sphinxstyleliteralstrong{by\_vel} -- If True, the velcoity-based vpu is used. Otherise, it is height-based spu

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{load\_float\_stathab() (in module src.stathab\_c)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.load_float_stathab}}\pysiglinewithargsret{\sphinxcode{src.stathab\_c.}\sphinxbfcode{load\_float\_stathab}}{\emph{filename}, \emph{check\_neg}}{}
A function to load float with extra checks
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{filename} -- the file to load with the path

\item {} 
\sphinxstyleliteralstrong{check\_neg} -- if true negative value are not allowed in the data

\end{itemize}

\item[{Returns}] \leavevmode
data if ok, -99 if failed

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_namereach() (in module src.stathab\_c)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.load_namereach}}\pysiglinewithargsret{\sphinxcode{src.stathab\_c.}\sphinxbfcode{load\_namereach}}{\emph{path}, \emph{name\_file\_reach='listriv'}}{}
A function to only load the reach names (useful for the GUI). The extension must be .txt or .csv

:param path : the path to the file listriv.txt or listriv.csv
:param name\_file\_reach: In case the file name is not listriv
:return: the list of reach name

\end{fulllineitems}

\index{load\_pref() (in module src.stathab\_c)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.load_pref}}\pysiglinewithargsret{\sphinxcode{src.stathab\_c.}\sphinxbfcode{load\_pref}}{\emph{filepref}, \emph{path}}{}
The function loads the different pref coeffficient contained in filepref, for the temperate river from Stathab
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{filepref} -- the name of the file (usually Pref.txt)

\item {} 
\sphinxstyleliteralstrong{path} -- the path to this file

\end{itemize}

\item[{Returns}] \leavevmode
the name of the fish, a np.array with the differen coeff

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_pref\_trop\_biv() (in module src.stathab\_c)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.load_pref_trop_biv}}\pysiglinewithargsret{\sphinxcode{src.stathab\_c.}\sphinxbfcode{load\_pref\_trop\_biv}}{\emph{code\_fish}, \emph{path}}{}
This function loads the bivariate preference files for tropical rivers. The name of the file must be in the form
of xbiv\_XXX.csv where XXX is the three-letters fish code and x is whatever string.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{code\_fish} -- the code for the fish name in three letters (such as ASC)

\item {} 
\sphinxstyleliteralstrong{path} -- the path to files

\end{itemize}

\item[{Returns}] \leavevmode
the bivariate preferences

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_pref\_trop\_uni() (in module src.stathab\_c)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.load_pref_trop_uni}}\pysiglinewithargsret{\sphinxcode{src.stathab\_c.}\sphinxbfcode{load\_pref\_trop\_uni}}{\emph{code\_fish}, \emph{path}}{}
This function loads the preference files for the univariate data. The file with the univariate data should be in the
form of xuni-h\_XXX where XX is the fish code and x is whatever string. The assumption is that the filename for
velocity is very similar to the filename for height. In more detail that the string uni-h is changed to uni-v in
the filename. Otherwise, the file are csv file with two columns: First is velocity or height,
the second is the preference data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{code\_fish} -- the code for the fish name in three letters (such as ASC)

\item {} 
\sphinxstyleliteralstrong{path} -- the path to files

\end{itemize}

\item[{Returns}] \leavevmode
the height data and velcoity data (h, pref) and (v,pref)

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module src.stathab\_c)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.stathab_c.main}}\pysiglinewithargsret{\sphinxcode{src.stathab\_c.}\sphinxbfcode{main}}{}{}
used to test this module.

\end{fulllineitems}



\section{FStress - source}
\label{\detokenize{index:fstress-source}}
in src/fstress.py

This module contains the function used to run the model FStress.For an explanation on
the form of the FStress text input, please see the last page of the pdf document \sphinxcode{stathabinfo}
\phantomsection\label{\detokenize{index:module-src.fstress}}\index{src.fstress (module)}\index{denstress() (in module src.fstress)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.fstress.denstress}}\pysiglinewithargsret{\sphinxcode{src.fstress.}\sphinxbfcode{denstress}}{\emph{k}, \emph{m}, \emph{nbst}}{}
This function calulates the stress distrbution function for FStress. This distribution has generally the form
of k*exp() + (1-k)* Sigma(x-m)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{k} -- the first parameter of the distribution

\item {} 
\sphinxstyleliteralstrong{m} -- the second parameter of the disitribution

\item {} 
\sphinxstyleliteralstrong{nbst} -- the number of stress class in the distribution

\end{itemize}

\item[{Returns}] \leavevmode
the stress disitrbution for the (m,k) parameters

\end{description}\end{quote}

\end{fulllineitems}

\index{figure\_fstress() (in module src.fstress)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.fstress.figure_fstress}}\pysiglinewithargsret{\sphinxcode{src.fstress.}\sphinxbfcode{figure\_fstress}}{\emph{qmod\_all}, \emph{vh\_all}, \emph{name\_inv}, \emph{path\_im}, \emph{name\_river}, \emph{fig\_opt=\{\}}}{}
This function creates the figures for Fstress, notably the suitability index as a function of discharge for all
rivers
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{qmod\_all} -- the modelled discharge for each river

\item {} 
\sphinxstyleliteralstrong{vh\_all} -- the suitability indoex for each invertebrate species for each river

\item {} 
\sphinxstyleliteralstrong{name\_inv} -- The four letter code of each selected invetebrate

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the figure

\item {} 
\sphinxstyleliteralstrong{name\_river} -- the name of the river

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- the figure option in a dictionnary

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{fstress\_test() (in module src.fstress)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.fstress.fstress_test}}\pysiglinewithargsret{\sphinxcode{src.fstress.}\sphinxbfcode{fstress\_test}}{\emph{qmod\_all}, \emph{vh\_all}, \emph{name\_inv}, \emph{name\_river}, \emph{path\_rre}, \emph{fig\_opt=\{\}}}{}
This functions compares the output of the C programm of FStress and the output of this script. it is not used
by HABBY, but it is practical to debug.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{qmod\_all} -- the modelled discharge for each river

\item {} 
\sphinxstyleliteralstrong{vh\_all} -- the suitability indoex for each invertebrate species for each river

\item {} 
\sphinxstyleliteralstrong{name\_inv} -- The four letter code of each selected invetebrate

\item {} 
\sphinxstyleliteralstrong{name\_river} -- the name of the river

\item {} 
\sphinxstyleliteralstrong{path\_rre} -- the path to the C output

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{func\_stress() (in module src.fstress)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.fstress.func_stress}}\pysiglinewithargsret{\sphinxcode{src.fstress.}\sphinxbfcode{func\_stress}}{\emph{vm}, \emph{h}, \emph{tau}}{}
This functions calculates the distrbution of stress on the bottom of the river based of height and velocity
at one discharge. In other word, it calculate the distrbution of the ``hemispheres''.
This function is mainly a copy of stress function contains in the vitess2.c of the C source of FStress.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{vm} -- the velocity for this diacharge value

\item {} 
\sphinxstyleliteralstrong{h} -- the height for this discharge value

\item {} 
\sphinxstyleliteralstrong{tau} -- the constraint values

\end{itemize}

\item[{Returns}] \leavevmode
the stress distribution for this discharge

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module src.fstress)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.fstress.main}}\pysiglinewithargsret{\sphinxcode{src.fstress.}\sphinxbfcode{main}}{}{}
This is not the main() of HABBY. This local function is used to test the Fstress model.

\end{fulllineitems}

\index{read\_fstress\_hdf5() (in module src.fstress)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.fstress.read_fstress_hdf5}}\pysiglinewithargsret{\sphinxcode{src.fstress.}\sphinxbfcode{read\_fstress\_hdf5}}{\emph{hdf5\_name}, \emph{hdf5\_path}}{}
This functions reads an hdf5 file related to FStress and extract the relevant information.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{hdf5\_name} -- the name of the hdf5 file with the information realted to FStress

\item {} 
\sphinxstyleliteralstrong{hdf5\_path} -- the path to this file

\end{itemize}

\end{description}\end{quote}

:return:{[}{[}q,w,h{]}, {[}q,w,h{]}{]} for each river, {[}qmin,qmax{]} for each river, the river names, and the selected fish

\end{fulllineitems}

\index{read\_pref() (in module src.fstress)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.fstress.read_pref}}\pysiglinewithargsret{\sphinxcode{src.fstress.}\sphinxbfcode{read\_pref}}{\emph{path\_bio}, \emph{name\_bio}}{}
This function loads and read the preference file for FStress.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{path\_bio} -- the path to the preference file

\item {} 
\sphinxstyleliteralstrong{name\_bio} -- the name of the preference file

\end{itemize}

\item[{Returns}] \leavevmode
the name invertebrate and their preference coefficient

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_fstress() (in module src.fstress)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.fstress.run_fstress}}\pysiglinewithargsret{\sphinxcode{src.fstress.}\sphinxbfcode{run\_fstress}}{\emph{data\_hydro}, \emph{qrange}, \emph{riv\_name}, \emph{inv\_select}, \emph{pref\_all}, \emph{name\_all}, \emph{name\_prj}, \emph{path\_prj}}{}
This function run the model FStress for HABBY. FStress is based on the model of Nicolas Lamouroux. This model
estimates suitability indices for invertebrate in relation with shear stress distributions. However, shear stress
do not needs to be measured. It is statistically estimated based on velocity and height measurement.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{riv\_name} -- the name of the river-\textgreater{} string

\item {} 
\sphinxstyleliteralstrong{data\_hydro} -- the hydrological data (q,w,h for each river in riv name) -\textgreater{} list of list

\item {} 
\sphinxstyleliteralstrong{qrange} -- the qmin and qmax for each river {[}qmin,qmax{]} -\textgreater{} list of list

\item {} 
\sphinxstyleliteralstrong{inv\_select} -- the name of the selected invetebrate

\item {} 
\sphinxstyleliteralstrong{pref\_all} -- the preference data for all invertebrate

\item {} 
\sphinxstyleliteralstrong{name\_all} -- the four letter code of all possible invertebrate

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path to the project-\textgreater{} string

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- the name of the project-\textgreater{} string

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{save\_fstress() (in module src.fstress)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.fstress.save_fstress}}\pysiglinewithargsret{\sphinxcode{src.fstress.}\sphinxbfcode{save\_fstress}}{\emph{path\_hdf5}, \emph{path\_prj}, \emph{name\_prj}, \emph{name\_bio}, \emph{path\_bio}, \emph{riv\_name}, \emph{data\_hydro}, \emph{qrange}, \emph{fish\_list}}{}
This function saves the data related to the fstress model in an hdf5 file and write the name of this hdf5 file
in the xml project file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- the path where to sdave the hdf5-\textgreater{} string

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path to the project-\textgreater{} string

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- the name of the project-\textgreater{} string

\item {} 
\sphinxstyleliteralstrong{name\_bio} -- the name of the preference file-\textgreater{} string

\item {} 
\sphinxstyleliteralstrong{path\_bio} -- the path to the preference file-\textgreater{} string

\item {} 
\sphinxstyleliteralstrong{riv\_name} -- the name of the river-\textgreater{} string

\item {} 
\sphinxstyleliteralstrong{data\_hydro} -- the hydrological data (q,w,h for each river in riv name) -\textgreater{} list of list

\item {} 
\sphinxstyleliteralstrong{qrange} -- the qmin and qmax for each river {[}qmin,qmax{]} -\textgreater{} list of list

\item {} 
\sphinxstyleliteralstrong{fish\_list} -- the name of the selected invertebrate (! no fish) -\textgreater{} list of string

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_txt() (in module src.fstress)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.fstress.write_txt}}\pysiglinewithargsret{\sphinxcode{src.fstress.}\sphinxbfcode{write\_txt}}{\emph{qmod\_all}, \emph{vh\_all}, \emph{name\_inv}, \emph{path\_txt}, \emph{name\_river}}{}
This function writes the txt outputs for FStress
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{qmod\_all} -- the modelled discharge for each river

\item {} 
\sphinxstyleliteralstrong{vh\_all} -- the suitability indoex for each invertebrate species for each river

\item {} 
\sphinxstyleliteralstrong{name\_inv} -- The four letter code of each selected invetebrate

\item {} 
\sphinxstyleliteralstrong{path\_txt} -- the path where to save the text file

\item {} 
\sphinxstyleliteralstrong{name\_river} -- the name of the river

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{Substrate}
\label{\detokenize{index:substrate}}
in src/substrate.py

This module contains the function to load and manage the substrate data.
\phantomsection\label{\detokenize{index:module-src.substrate}}\index{src.substrate (module)}\index{create\_dummy\_substrate\_from\_hydro() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.create_dummy_substrate_from_hydro}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{create\_dummy\_substrate\_from\_hydro}}{\emph{h5name}, \emph{path}, \emph{new\_name}, \emph{code\_type}, \emph{attribute\_type}, \emph{nb\_point=200}, \emph{path\_out='.'}}{}
This function takes an hydrological hdf5 as inputs and create a shapefile of substrate and a text file of substrate
which can be used as input for habby. The substrate data is random. So it is mainly useful to test an hydrological
input.

The created shape file is rectangular with a size based on min/max of the hydrological coordinates. The substrate
grid is not the same as the hydrological grids (which is good to test the programm). In addition, one side of the shp
is smaller than the hydrological grid to test the `default substrate' option (which is used if the substrate
shapefile is not big enough).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{h5name} -- the name of the hydrological hdf5 file

\item {} 
\sphinxstyleliteralstrong{path} -- the path to this file

\item {} 
\sphinxstyleliteralstrong{new\_name} -- the name of the create shape file wihtout the shp (string)

\item {} 
\sphinxstyleliteralstrong{code\_type} -- the code type for the substrate (Sandre, Cemagref, Const\_cemagref, or EDF). All subtrate value
to 4 for Const\_cemagref.

\item {} 
\sphinxstyleliteralstrong{attribute\_type} -- if the substrate is given in the type coarser/dominant/..(0) or in percenctage (1)

\item {} 
\sphinxstyleliteralstrong{nb\_point} -- the number of point needed (more points results in smaller substrate form)

\item {} 
\sphinxstyleliteralstrong{path\_out} -- the path where to save the new substrate shape

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{edf\_to\_cemagref() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.edf_to_cemagref}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{edf\_to\_cemagref}}{\emph{records}}{}
This function passes the substrate data from the code type `EDF'' to the code type ``Cemagref''. As the code 1 from EDF
can be the code 2 or code 1 in Cemagref, a code 1 in EDF is code 1 in Cemagref half of the time and code 2 the
other half of the time. This function is not optimized yet. For the definiction of the code, see the tabular at the 14
of the LAMMI manual. THIS IS NOT RIGHT AS CLASS ARE NOT SPEAREATED IDENTICALLY,  TO BE CORRECTED !!!
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{records} -- the substrate data in code edf

\item[{Returns}] \leavevmode
the substrate data in code cemagref

\end{description}\end{quote}

\end{fulllineitems}

\index{edf\_to\_cemagref\_by\_percentage() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.edf_to_cemagref_by_percentage}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{edf\_to\_cemagref\_by\_percentage}}{\emph{records}}{}
This function change the subtrate in a percetage form from edf code to cemagref code
:param records: the subtrate data (in 8x len tabular)
:return:

\end{fulllineitems}

\index{fig\_substrate() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.fig_substrate}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{fig\_substrate}}{\emph{coord\_p, ikle, sub\_pg, sub\_dom, path\_im, fig\_opt=\{\}, xtxt={[}-99{]}, ytxt={[}-99{]}, subtxt={[}-99{]}}}{}
The function to plot the substrate data, which was loaded before. This function will only work if the substrate
data is given using the cemagref code.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{coord\_p} -- the coordinate of the point

\item {} 
\sphinxstyleliteralstrong{ikle} -- the connectivity table

\item {} 
\sphinxstyleliteralstrong{sub\_pg} -- the information on subtrate by element for the ``coarser part''

\item {} 
\sphinxstyleliteralstrong{sub\_dom} -- the information on subtrate by element for the ``dominant part''

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- the figure option as a doctionnary

\item {} 
\sphinxstyleliteralstrong{xtxt} -- if the data was given in txt form, the orignal x data

\item {} 
\sphinxstyleliteralstrong{ytxt} -- if the data was given in txt form, the orignal y data

\item {} 
\sphinxstyleliteralstrong{subtxt} -- if the data was given in txt form, the orignal sub data

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the figure

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_attribute() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.get_all_attribute}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{get\_all\_attribute}}{\emph{filename}, \emph{path}}{}
This function open a shapefile and get the list of all the attibute which is contains in it.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{filename} -- the name of the shpae file

\item {} 
\sphinxstyleliteralstrong{path} -- the path to this shapefile

\end{itemize}

\item[{Returns}] \leavevmode
a list with the name and information of all attribute. The form of each element of the list
is {[}name(str), type (F,N), int, int{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_useful\_attribute() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.get_useful_attribute}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{get\_useful\_attribute}}{\emph{attributes}}{}
This function find if the substrate was given in percentage or coarser/dominant/accesory and get the attribute
or header name useful to load the substrate. If the subtrate is given by percentage, it is important to get
attribute in order (S1, S2, S3) and not (S3, S1,S2) for this function and the next functions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{attributes} -- The list of attribute from the shp file or the header list from the text file

\item[{Returns}] \leavevmode
The attribute type as int (percentage=1 and coarser/... = 0 and failed = -99) and the attribute names
If we are in the attribute type 0, attribute list is in the order of: coarser, dominant, and accessory

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_sub\_shp() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.load_sub_shp}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{load\_sub\_shp}}{\emph{filename}, \emph{path}, \emph{code\_type}, \emph{dominant\_case=0}}{}
A function to load the substrate in form of shapefile.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{filename} -- the name of the shapefile

\item {} 
\sphinxstyleliteralstrong{path} -- the path where the shapefile is

\item {} 
\sphinxstyleliteralstrong{code\_type} -- the type of code used to define the substrate (string)

\item {} 
\sphinxstyleliteralstrong{dominant\_case} -- an int to manage the case where the transfomation form percentage to dominnat is unclear (two
maxinimum percentage are equal from one element). if -1 take the smallest, if 1 take the biggest,
if 0, we do not know.

\end{itemize}

\item[{Returns}] \leavevmode
grid in form of list of coordinate and connectivity table (two list)
and an array with substrate type and a boolean which allows to get the case where we have tow dominant case

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_sub\_txt() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.load_sub_txt}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{load\_sub\_txt}}{\emph{filename}, \emph{path}, \emph{code\_type}, \emph{path\_shp='.'}}{}
A function to load the substrate in form of a text file. The text file must have 4 columns x,y coordinate and
coarser substrate type, dominant substrate type, no header or title. It is transform to a grid using a voronoi
transformation.

The voronoi transformation might look strange as it is often bigger than theorginal point. However, this is
just the mathematical result.

At the end of this fnuction, the resulting grid is exported in a shapefile form.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{filename} -- the name of the shapefile

\item {} 
\sphinxstyleliteralstrong{path} -- the path where the shapefile is

\item {} 
\sphinxstyleliteralstrong{code\_type} -- the type of code used to define the substrate (string)

\item {} 
\sphinxstyleliteralstrong{path\_shp} -- the path where to save the shapefile (usually the input folder)

\end{itemize}

\item[{Returns}] \leavevmode
grid in form of list of coordinate and connectivity table (two list)
and an array with substrate type and (x,y,sub) of the orginal data

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.main}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{main}}{}{}
Used to test this module.

\end{fulllineitems}

\index{modify\_grid\_if\_concave() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.modify_grid_if_concave}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{modify\_grid\_if\_concave}}{\emph{ikle}, \emph{point\_all}, \emph{sub\_pg}, \emph{sub\_dom}}{}
This function check if the grid in entry is composed of convex cell. Indeed, it is possible to have concave
cells in the substrate grid. However, this is unpractical when the hydrological grid is merged with the subtrate
grid. Hence, we find here the concave cells. These cells are then modified using the triangle module.

The algotithm is based on the idea that when you have a convex polygon you turn always in the same direction.
When you have a concave polygon sometime you will turn left, sometime you will turn right. To check this,
we can take the determinant betwen each vector which compose the cells and check if they have the same sign.
Triangle are always convex.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{ikle} -- the connectivity table of the grid (one reach, one time step as substrate grid is constant)

\item {} 
\sphinxstyleliteralstrong{point\_all} -- the point of the grid

\item {} 
\sphinxstyleliteralstrong{sub\_pg} -- the coarser substrate, one data by cell

\item {} 
\sphinxstyleliteralstrong{sub\_dom} -- the dominant subtrate, one data by cell

\end{itemize}

\item[{Returns}] \leavevmode
ikle, point\_all with only convexe cells

\end{description}\end{quote}

\end{fulllineitems}

\index{open\_shp() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.open_shp}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{open\_shp}}{\emph{filename}, \emph{path}}{}
This function open a ArcGIS shpaefile.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{filename} -- the name of the shapefile

\item {} 
\sphinxstyleliteralstrong{path} -- the path to this shapefile

\end{itemize}

\item[{Returns}] \leavevmode
a shapefile object as define in the model

\end{description}\end{quote}

\end{fulllineitems}

\index{percentage\_to\_domcoarse() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.percentage_to_domcoarse}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{percentage\_to\_domcoarse}}{\emph{sub\_data}, \emph{dominant\_case}}{}
This function is used to pass from percentage data to dominant/coarse. As the code 8 from the subtrate in
Cemagref code is slab, we do not the 8 code as the coarser substrate.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{sub\_data} -- the subtrate data in percentage from Lammi

\item {} 
\sphinxstyleliteralstrong{dominant\_case} -- an int to manage the case where the transfomation form percentage to dominnat is unclear (two
maxinimum percentage are equal from one element). if -1 take the smallest, if 1 take the biggest,
if 0, we do not know.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{sandre\_to\_cemagref() (in module src.substrate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.substrate.sandre_to_cemagref}}\pysiglinewithargsret{\sphinxcode{src.substrate.}\sphinxbfcode{sandre\_to\_cemagref}}{\emph{records}}{}
This function passes the substrate data from the code type ``Sandre'' to the code type ``Cemagref''. This function is
not optimized yet. For the definition of the code, see the tabular at the 14 of the LAMMI manual.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{records} -- the substrate data in code samdre

\item[{Returns}] \leavevmode
the substrate data in code cemagref

\end{description}\end{quote}

\end{fulllineitems}



\section{Merge the grid}
\label{\detokenize{index:merge-the-grid}}
in src/mesh\_grid2.py

This module contains the function to merge the substrate grid and the hydrological grid.
It cut the hydrological grid to the form of each of the substrate. An important hypothesis
is that each polygon forming the subtrate should convex.
\phantomsection\label{\detokenize{index:module-src.mesh_grid2}}\index{src.mesh\_grid2 (module)}\index{check\_clockwise() (in module src.mesh\_grid2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mesh_grid2.check_clockwise}}\pysiglinewithargsret{\sphinxcode{src.mesh\_grid2.}\sphinxbfcode{check\_clockwise}}{\emph{ikle}, \emph{point}}{}
This function check that each grid cell is given in a clockwise order. This is useful because we might create
shapefile afterward. ArcMap beleives that we have hole if a grid cell is in counter-clockwise order.

To check the clockwise order, we sum (x2-x1)*(y2+y1) over the three edges.
Here is a more information on the algo: \url{http://blog.element84.com/polygon-winding.html}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{ikle} -- the connectivity table

\item {} 
\sphinxstyleliteralstrong{point} -- the grid point

\end{itemize}

\item[{Returns}] \leavevmode
the connectivity table with the point in clockewise order

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_merge\_grid() (in module src.mesh\_grid2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mesh_grid2.create_merge_grid}}\pysiglinewithargsret{\sphinxcode{src.mesh\_grid2.}\sphinxbfcode{create\_merge\_grid}}{\emph{ikle}, \emph{coord\_p}, \emph{data\_sub\_pg}, \emph{data\_sub\_dom}, \emph{vel}, \emph{height}, \emph{ikle\_sub}, \emph{default\_data}, \emph{data\_crossing}, \emph{sub\_cell}}{}
A function to update the grid after finding the crossing points. It also get the substrate\_data for each cell
of the new grid.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{ikle} -- the hydrological grid to be merge with the substrate grid

\item {} 
\sphinxstyleliteralstrong{coord\_p} -- the coordinate of the point of the hydrological grid

\item {} 
\sphinxstyleliteralstrong{data\_sub\_pg} -- the coarser substrate data by hydrological cell (3 information by cells realted to
the three points)

\item {} 
\sphinxstyleliteralstrong{data\_sub\_dom} -- the dominant substrate data by hydrological cell (3 information by cells realted to
the three points)

\item {} 
\sphinxstyleliteralstrong{vel} -- the velocity (one time step, one reach) for each point in coord\_p

\item {} 
\sphinxstyleliteralstrong{height} -- the water height (one time step, one reach) for each point in coord\_p

\item {} 
\sphinxstyleliteralstrong{ikle\_sub} -- the connectivity table for the substrate

\item {} 
\sphinxstyleliteralstrong{default\_data} -- the default substrate data

\item {} 
\sphinxstyleliteralstrong{data\_crossing} -- the hydrological elment with a crossing and the info for this crossing (a list of list)

\end{itemize}

\item[{Returns}] \leavevmode
the new grid

\end{description}\end{quote}

\sphinxstylestrong{Technical comments}

This function corrects all element of the grids where a crossing point have been found by the
function find\_sub\_and\_cross()

There are three cases:
\begin{enumerate}
\item {} 
one crossing point -\textgreater{} no change

\item {} 
two crossing points and subtrate point inside -\textgreater{} done manually. We take the two crossing point and the side on
which the crossing is done. Based on this, we correct the grid.

\item {} 
more than two crossing point on the elements -\textgreater{} We call the extrenal module
triangle to re-do some triagulations into the element. This last cases covers many possible case, but it is slow.
To optimize, we can think about writing more individual cases. To follow the border of each subtrate cell in
the ``special cell'', we do one triangulation by subtrate element, so we can have two or three triangulation.
It is also important there that the substrate is convex as the triangulation is not constrained.

\end{enumerate}

\end{fulllineitems}

\index{fig\_merge\_grid() (in module src.mesh\_grid2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mesh_grid2.fig_merge_grid}}\pysiglinewithargsret{\sphinxcode{src.mesh\_grid2.}\sphinxbfcode{fig\_merge\_grid}}{\emph{point\_all\_both\_t}, \emph{ikle\_both\_t}, \emph{path\_im}, \emph{name\_add='`}, \emph{ikle\_orr={[}{]}}, \emph{point\_all\_orr={[}{]}}}{}
A function to plot the grid after it was merged with the substrate data.
It plots one time step at the time. This function is not used anymore by Habby. Indded, mesh\_grid2 uses the
function provided in manage\_grid8.py to plot the grid and data after it is merged with the substrate. However,
this function could be useful to debug if one wants to only plots teh grid and not the height/velocity data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{point\_all\_both\_t} -- the coordinate of the points of the updated grid

\item {} 
\sphinxstyleliteralstrong{ikle\_both\_t} -- the connectivity table

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where the image should be saved

\item {} 
\sphinxstyleliteralstrong{name\_add} -- the anem to be added to the figure name

\item {} 
\sphinxstyleliteralstrong{ikle\_orr} -- the orginial ikle

\item {} 
\sphinxstyleliteralstrong{point\_all\_orr} -- the orginal point\_all

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_sub\_and\_cross() (in module src.mesh\_grid2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mesh_grid2.find_sub_and_cross}}\pysiglinewithargsret{\sphinxcode{src.mesh\_grid2.}\sphinxbfcode{find\_sub\_and\_cross}}{\emph{ikle\_sub}, \emph{coord\_p\_sub}, \emph{ikle}, \emph{coord\_p}, \emph{data\_sub\_pg}, \emph{data\_sub\_dom}, \emph{first\_time=False}}{}
A function which find where the crossing points are. Crossing points are the points on the triangular side of the
hydrological grid which cross with a side of the substrate grid. The algo based on finding if points of one elements
are in the same polygon using a ray casting method. We assume that the polygon forming the subtrate grid are convex.
Otherwise it would not work in all cases.
We also neglect the case where a substrate cell at the border of the subtrate grid is fully in a hydrological cell.

IMPORTANT: polygon should be convex.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{ikle\_sub} -- the connectivity table for the substrate

\item {} 
\sphinxstyleliteralstrong{coord\_p\_sub} -- the coordinates of the poitn forming the subtrate

\item {} 
\sphinxstyleliteralstrong{ikle} -- the connectivity table for the hydrology

\item {} 
\sphinxstyleliteralstrong{coord\_p} -- the coordinate of the hydrology

\item {} 
\sphinxstyleliteralstrong{data\_sub\_dom} -- the subtrate data by subtrate cell (dominant)

\item {} 
\sphinxstyleliteralstrong{data\_sub\_pg} -- the substrate data by substrate cell (coarser)

\item {} 
\sphinxstyleliteralstrong{first\_time} -- If True, we preapre the subtrate data

\end{itemize}

\item[{Returns}] \leavevmode
the new substrate grid (ikle\_sub, coord\_p\_sub, data\_sub\_pg, data\_sub\_dom, sub\_cell), the data for
the crossing point (hydrological element with a crossing, crossing point, substrate element linked with
the crossing point, point of substrate inside, substrate element linked with the substrate point,
side of the crossing points, substrate leemnt link with hydro\_point).

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_new\_vel\_height\_data() (in module src.mesh\_grid2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mesh_grid2.get_new_vel_height_data}}\pysiglinewithargsret{\sphinxcode{src.mesh\_grid2.}\sphinxbfcode{get\_new\_vel\_height\_data}}{\emph{newp}, \emph{point\_old}, \emph{data\_old}}{}
This function gets the height and velcoity data for a new point in or on the side of an element. It does an
average of the data (velocity or height) given at the node of the original (old) elements. This average is weighted
as a function of the distance of the point.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{newp} -- the coordinates of the new points

\item {} 
\sphinxstyleliteralstrong{point\_old} -- the coordinates of thre three old points (would work with more than three)

\item {} 
\sphinxstyleliteralstrong{data\_old} -- the data for the point in point\_old

\end{itemize}

\item[{Returns}] \leavevmode
the new data

\end{description}\end{quote}

\end{fulllineitems}

\index{inside\_trigon() (in module src.mesh\_grid2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mesh_grid2.inside_trigon}}\pysiglinewithargsret{\sphinxcode{src.mesh\_grid2.}\sphinxbfcode{inside\_trigon}}{\emph{pt}, \emph{p0}, \emph{p1}, \emph{p2}}{}
This function check if a point is in a triangle using the barycentric coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{pt} -- the point to determine if it is in or not

\item {} 
\sphinxstyleliteralstrong{p0} -- the first point of triangle

\item {} 
\sphinxstyleliteralstrong{p1} -- the second point of triangle

\item {} 
\sphinxstyleliteralstrong{p2} -- the third point of triangle

\end{itemize}

\item[{Returns}] \leavevmode
A boolean (Ture if pt inside of triangle)

\end{description}\end{quote}

\end{fulllineitems}

\index{intersec\_cross() (in module src.mesh\_grid2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mesh_grid2.intersec_cross}}\pysiglinewithargsret{\sphinxcode{src.mesh\_grid2.}\sphinxbfcode{intersec\_cross}}{\emph{hyd1}, \emph{hyd2}, \emph{sub1}, \emph{sub2}}{}
A function function to calculate the intersection, segment are not parrallel,
used in case where we know that the intersection exists
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{hyd1} -- the first hydrological point

\item {} 
\sphinxstyleliteralstrong{hyd2} -- the second

\item {} 
\sphinxstyleliteralstrong{sub1} -- the first substrate point

\item {} 
\sphinxstyleliteralstrong{sub2} -- the second

\end{itemize}

\item[{Returns}] \leavevmode
intersection

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module src.mesh\_grid2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mesh_grid2.main}}\pysiglinewithargsret{\sphinxcode{src.mesh\_grid2.}\sphinxbfcode{main}}{}{}
Used to test this module.

\end{fulllineitems}

\index{merge\_grid\_and\_save() (in module src.mesh\_grid2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mesh_grid2.merge_grid_and_save}}\pysiglinewithargsret{\sphinxcode{src.mesh\_grid2.}\sphinxbfcode{merge\_grid\_and\_save}}{\emph{hdf5\_name\_hyd}, \emph{hdf5\_name\_sub}, \emph{path\_hdf5}, \emph{default\_data}, \emph{name\_prj}, \emph{path\_prj}, \emph{model\_type}, \emph{q={[}{]}}, \emph{print\_cmd=False}}{}
This function call the merging of the grid between the grid from the hydrological data and the substrate data.
It then save the merged data and the substrate data in a common hdf5 file. This function is called in a second
thread to avoid freezin gthe GUI. This is why we have this extra-function just to call save\_hdf5() and
merge\_grid\_hydro\_sub().
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{hdf5\_name\_hyd} -- the name of the hdf5 file with the hydrological data

\item {} 
\sphinxstyleliteralstrong{hdf5\_name\_sub} -- the name of the hdf5 with the substrate data

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- the path to the hdf5 data

\item {} 
\sphinxstyleliteralstrong{default\_data} -- The substrate data given in the region of the hydrological grid where no substrate is given

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- the name of the project

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path to the project

\item {} 
\sphinxstyleliteralstrong{model\_type} -- the type of the ``model''. In this case, it is just `SUBSTRATE'

\item {} 
\sphinxstyleliteralstrong{q} -- used to share info with the GUI when this thread have finsihed (print\_cmd = False)

\item {} 
\sphinxstyleliteralstrong{print\_cmd} -- If False, print to the GUI (usually False)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{merge\_grid\_hydro\_sub() (in module src.mesh\_grid2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.mesh_grid2.merge_grid_hydro_sub}}\pysiglinewithargsret{\sphinxcode{src.mesh\_grid2.}\sphinxbfcode{merge\_grid\_hydro\_sub}}{\emph{hdf5\_name\_hyd}, \emph{hdf5\_name\_sub}, \emph{path\_hdf5}, \emph{default\_data=1}, \emph{path\_prj='`}}{}
After the data for the substrate and the hydrological data are loaded, they are still in different grids.
This functions will merge both grid together. This is done for all time step and all reaches. If a
constant substrate is there, the hydrological hdf5 is just copied.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{hdf5\_name\_hyd} -- the name of the hdf5 file with the hydrological data

\item {} 
\sphinxstyleliteralstrong{hdf5\_name\_sub} -- the name of the hdf5 with the substrate data

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- the path to the hdf5 data

\item {} 
\sphinxstyleliteralstrong{default\_data} -- The substrate data given in the region of the hydrological grid where no substrate is given

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path to the project

\end{itemize}

\item[{Returns}] \leavevmode
the connectivity table, the coordinates, the substrated data, the velocity and height data all in a merge form.

\end{description}\end{quote}

\end{fulllineitems}



\section{Biological Info}
\label{\detokenize{index:biological-info}}
in src/bio\_info.py

This module contains the script to show and manage the biological models (preference curves) which are in the biology folder.
\phantomsection\label{\detokenize{index:module-src.bio_info}}\index{src.bio\_info (module)}\index{change\_unit() (in module src.bio\_info)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.bio_info.change_unit}}\pysiglinewithargsret{\sphinxcode{src.bio\_info.}\sphinxbfcode{change\_unit}}{\emph{data}, \emph{unit}}{}
This function modify the unit of the data to SI unit. Currently it accept the following unit :
Centimeter, Meter, CentimeterPerSecond, MeterPerSecond, Millimeter, ``Code EVHA 2.0 (GINOT 1998)''
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{data} -- the data which has to be change to SI unti

\item {} 
\sphinxstyleliteralstrong{unit} -- the unit code

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_and\_fill\_database() (in module src.bio\_info)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.bio_info.create_and_fill_database}}\pysiglinewithargsret{\sphinxcode{src.bio\_info.}\sphinxbfcode{create\_and\_fill\_database}}{\emph{path\_bio}, \emph{name\_database}, \emph{attribute}}{}
This function create a new database when Habby starts. The goal of creating a database is to avoid freezing the GUI
when info on the preference curve are asked. So it is possible to select one curve and have information without
seeing too much of a delay.

This is not used anymore by HABBY as the xml file is really small.
It could however be useful if the xml file becomes too big. In this case, this function could be
called if modification are found in the pref\_file folder and would create a database.

The attribute can be modified, but they should all be of text type. It is also important to keep stage at the first
attribute. The modified attribute should reflect the attribute of the xml file. If it not possible, lines should
be added in the ``special case'' attributes''. The main table with the data is called pref\_bio.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{path\_bio} -- the path to the biological information (usually ./biology)

\item {} 
\sphinxstyleliteralstrong{name\_database} -- the name of the database (string) without the path

\item {} 
\sphinxstyleliteralstrong{attribute} -- the attribute in the database (only text type)

\end{itemize}

\item[{Returns}] \leavevmode
a boolean (True if everthing ok, False otherwise)

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_pdf() (in module src.bio\_info)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.bio_info.create_pdf}}\pysiglinewithargsret{\sphinxcode{src.bio\_info.}\sphinxbfcode{create\_pdf}}{\emph{xmlfiles}, \emph{stages\_chosen}, \emph{path\_bio}, \emph{path\_im\_bio}, \emph{path\_out}, \emph{fig\_opt}}{}
This functionc create a pdf with information about the fish. It tries to follow the chosen language, but
the stage name are not translated and the decription are usually only given in French.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{xmlfiles} -- the name of the xmlfile (without the path!)

\item {} 
\sphinxstyleliteralstrong{stages\_chosen} -- the stage chosen (might not be all stages)

\item {} 
\sphinxstyleliteralstrong{path\_bio} -- the path with the biological xml file

\item {} 
\sphinxstyleliteralstrong{path\_im\_bio} -- the path with the images of the fish

\item {} 
\sphinxstyleliteralstrong{path\_out} -- the path where to save the .pdf file (usually other\_outputs)

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- the figure options (contain the chosen language)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{execute\_request() (in module src.bio\_info)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.bio_info.execute_request}}\pysiglinewithargsret{\sphinxcode{src.bio\_info.}\sphinxbfcode{execute\_request}}{\emph{path\_bio}, \emph{name\_database}, \emph{request}}{}
This function execute the SQL request given in the string called request. it saves the found data in a variable.
The idea is to use this function for SELELCT X FROM X WHERE ... , not really to handle all possible request.
It also opens and close the database name\_database to do this. This is not used anymore by HABBY as we do not use
a database. It could however be useful if the xml file becomes too big.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{path\_bio} -- the path to the biological information (usually ./biology)

\item {} 
\sphinxstyleliteralstrong{name\_database} -- the name of the database (string) without the path

\item {} 
\sphinxstyleliteralstrong{request} -- the SQL request in a string form

\end{itemize}

\item[{Returns}] \leavevmode
the result

\end{description}\end{quote}

\end{fulllineitems}

\index{figure\_pref() (in module src.bio\_info)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.bio_info.figure_pref}}\pysiglinewithargsret{\sphinxcode{src.bio\_info.}\sphinxbfcode{figure\_pref}}{\emph{height}, \emph{vel}, \emph{sub}, \emph{code\_fish}, \emph{name\_fish}, \emph{stade}, \emph{get\_fig=False}, \emph{fig\_opt=\{\}}}{}
This function is used to plot the preference curves.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{height} -- the height preference data (list of list)

\item {} 
\sphinxstyleliteralstrong{vel} -- the height preference data (list of list)

\item {} 
\sphinxstyleliteralstrong{sub} -- the height preference data (list of list)

\item {} 
\sphinxstyleliteralstrong{code\_fish} -- the three letter code which indiate which fish species is analyzed

\item {} 
\sphinxstyleliteralstrong{name\_fish} -- the name of the fish analyzed

\item {} 
\sphinxstyleliteralstrong{stade} -- the name of the stade analyzed (ADU, JUV, ...)

\item {} 
\sphinxstyleliteralstrong{get\_fig} -- usually False, If True return the figure (to modfied it more)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_stage() (in module src.bio\_info)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.bio_info.get_stage}}\pysiglinewithargsret{\sphinxcode{src.bio\_info.}\sphinxbfcode{get\_stage}}{\emph{names\_bio}, \emph{path\_bio}}{}
This function loads all the stages present in a list of  xml preference files (JUV, ADU, etc) and the latin name of
the fish species. All the files should be in the same folder indicated by path\_bio. It is mainly used by habby\_cmd
but it can be useful in other cases also.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{names\_bio} -- A list of xml biological preference file

\item {} 
\sphinxstyleliteralstrong{path\_bio} -- the path to the xml preference files (usually `./biology')

\end{itemize}

\item[{Returns}] \leavevmode
the stages in a list of string

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_evha\_curve() (in module src.bio\_info)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.bio_info.load_evha_curve}}\pysiglinewithargsret{\sphinxcode{src.bio\_info.}\sphinxbfcode{load\_evha\_curve}}{\emph{filename}, \emph{path}}{}
This function is used to load the preference curve in the EVHA form . It will be useful to create xml preference
file, but it is not used direclty by HABBY. This function does not have much control on user input as it is planned
to be used only by people working on HABBY. The order of the data in the file must be height, velocity, substrate
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{filename} -- the name of file containing the preference curve for EVHA

\item {} 
\sphinxstyleliteralstrong{path} -- the path to this file

\end{itemize}

\item[{Returns}] \leavevmode
preference for height, vel, sub in a list of list form, name of the fish, code, stade and description

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_xml\_name() (in module src.bio\_info)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.bio_info.load_xml_name}}\pysiglinewithargsret{\sphinxcode{src.bio\_info.}\sphinxbfcode{load\_xml\_name}}{\emph{path\_bio}, \emph{attributes}, \emph{preffiles={[}{]}}}{}
This function looks for all preference curves found in the path\_bio folder. It extract the fish name and the stage.
to be corrected if more than one language. The name of attribute\_acc should be coherent with the one from the xml
file apart from the common name which should be in the form language\_common\_name (so we can wirte something in the
GUI to get all langugage if we get something else than English or French).

If one use the argument preffiles, only part of the xml file are loaded. Otherwise all xml file are loaded.

Careful, the first attribute is relgated at the last place of the list return. This is confusing but it is really
useful for the GUI.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{path\_bio} -- the path to the biological function

\item {} 
\sphinxstyleliteralstrong{attributes} -- the list of attribute which should be possible to search from the GUI or, more generally
which should be in data-fish which is returned.

\item {} 
\sphinxstyleliteralstrong{preffiles} -- If there is a list of string there, it only read this files

\end{itemize}

\item[{Returns}] \leavevmode
the list of stage/fish species with the info from {[}name for GUi, s, xmlfilename, attribute\_acc without s{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module src.bio\_info)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.bio_info.main}}\pysiglinewithargsret{\sphinxcode{src.bio\_info.}\sphinxbfcode{main}}{}{}
Used to test the module on the biological preference

\end{fulllineitems}

\index{plot\_hydrosignature() (in module src.bio\_info)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.bio_info.plot_hydrosignature}}\pysiglinewithargsret{\sphinxcode{src.bio\_info.}\sphinxbfcode{plot\_hydrosignature}}{\emph{xmlfile}}{}
This function plots the hydrosignature in the vclass and hclass given in the xml file.
It does only work if: units are SI (meter and m/s) and if the order of data is `velocity increasing
and then height of water increasing''.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{xmlfile} -- the path and name of the xmlfile

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_pref() (in module src.bio\_info)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.bio_info.read_pref}}\pysiglinewithargsret{\sphinxcode{src.bio\_info.}\sphinxbfcode{read\_pref}}{\emph{xmlfile}}{}
This function reads the preference curve from the xml file and get the subtrate, height and velocity data.
It return the data in meter. Unit for space can be in centimeter, milimeter or meter. Unit for time should be in
second .The unit attribute of the xml files should be coherent with the data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{xmlfile} -- the path and name to the xml file (string)

\item[{Returns}] \leavevmode
height, vel, sub, code\_fish, name\_fish, stade

\end{description}\end{quote}

\end{fulllineitems}

\index{test\_evah\_xml\_pref() (in module src.bio\_info)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.bio_info.test_evah_xml_pref}}\pysiglinewithargsret{\sphinxcode{src.bio\_info.}\sphinxbfcode{test\_evah\_xml\_pref}}{\emph{path\_xml}, \emph{path\_evha}}{}
This function is used to visually compared the evha (.PRF) curve and the xml curve based on the evah curve.
Obviously the xml file should contain the same data than the evha curve (when the xml file are based on the evah
curve). An important assumption of this function is that the data in the xml file is in the order: fry, juvenile,
adult.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{path\_xml} -- the path to the folder which contains the xml files

\item {} 
\sphinxstyleliteralstrong{path\_evha} -- the path to the evha folder which contains the PRF files

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{Calculation habitat}
\label{\detokenize{index:calculation-habitat}}
in src/calcul\_hab.py

This module calculates the habitat value for the fish and creates the outputs (text files, shapefile, and figures).
\phantomsection\label{\detokenize{index:module-src.calcul_hab}}\index{src.calcul\_hab (module)}\index{calc\_hab() (in module src.calcul\_hab)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.calcul_hab.calc_hab}}\pysiglinewithargsret{\sphinxcode{src.calcul\_hab.}\sphinxbfcode{calc\_hab}}{\emph{merge\_name}, \emph{path\_merge}, \emph{bio\_names}, \emph{stages}, \emph{path\_bio}, \emph{opt}}{}
This function calculates the habitat value. It loads substrate and hydrology data from an hdf5 files and it loads
the biology data from the xml files. It is possible to have more than one stage by xml file (usually the three
stages are in the xml files). There are more than one method to calculte the habitat so the parameter opt indicate
which metho to use. 0-\textgreater{} usde coarser substrate, 1 -\textgreater{} use dominant substrate
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{merge\_name} -- the name of the hdf5 with the results

\item {} 
\sphinxstyleliteralstrong{path\_merge} -- the path to the merged file

\item {} 
\sphinxstyleliteralstrong{bio\_names} -- the name of the xml biological data

\item {} 
\sphinxstyleliteralstrong{stages} -- the stage chosen (youngs, adults, etc.). List with the same length as bio\_names.

\item {} 
\sphinxstyleliteralstrong{path\_bio} -- The path to the biological folder (with all files given in bio\_names

\item {} 
\sphinxstyleliteralstrong{opt} -- an int fron 0 to n. Gives which calculation method should be used

\end{itemize}

\item[{Returns}] \leavevmode
the habiatat value for all species, all time, all reach, all cells.

\end{description}\end{quote}

\end{fulllineitems}

\index{calc\_hab\_and\_output() (in module src.calcul\_hab)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.calcul_hab.calc_hab_and_output}}\pysiglinewithargsret{\sphinxcode{src.calcul\_hab.}\sphinxbfcode{calc\_hab\_and\_output}}{\emph{hdf5\_file}, \emph{path\_hdf5}, \emph{pref\_list}, \emph{stages\_chosen}, \emph{name\_fish}, \emph{name\_fish\_sh}, \emph{run\_choice}, \emph{path\_bio}, \emph{path\_txt}, \emph{path\_shp}, \emph{path\_para}, \emph{path\_im}, \emph{q={[}{]}}, \emph{print\_cmd=False}, \emph{fig\_opt=\{\}}, \emph{path\_im\_bio='`}, \emph{xmlfiles={[}{]}}}{}
This function calculates the habitat and create the outputs for the habitat calculation. The outputs are: text
output (spu and cells by cells), shapefile, paraview files, one 2d figure by time step. The 1d figure
is done on the main thread as we want to show it to the user on the GUI. This function is called by bio\_info\_GUI.py
on a second thread to minimize the freezing on the GUI.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{hdf5\_file} -- the name of the hdf5 with the results

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- the path to the merged file

\item {} 
\sphinxstyleliteralstrong{pref\_list} -- the name of the xml biological data

\item {} 
\sphinxstyleliteralstrong{stages\_chosen} -- the stage chosen (youngs, adults, etc.). List with the same length as bio\_names.

\item {} 
\sphinxstyleliteralstrong{name\_fish} -- the name of the chosen fish

\item {} 
\sphinxstyleliteralstrong{name\_fish\_sh} -- In a shapefile, max 8 character for the column name. Hence, a modified name\_fish is needed.

\item {} 
\sphinxstyleliteralstrong{run\_choice} -- an int fron 0 to n. Gives which calculation method should be used

\item {} 
\sphinxstyleliteralstrong{path\_bio} -- The path to the biological folder (with all files given in bio\_names)

\item {} 
\sphinxstyleliteralstrong{path\_txt} -- the path where to save the text file

\item {} 
\sphinxstyleliteralstrong{path\_shp} -- the path where to save shapefile

\item {} 
\sphinxstyleliteralstrong{path\_para} -- the path where to save paraview output

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the image

\item {} 
\sphinxstyleliteralstrong{path\_im\_bio} -- the path where are the image of the fish

\item {} 
\sphinxstyleliteralstrong{q} -- used in the second thread

\item {} 
\sphinxstyleliteralstrong{print\_cmd} -- if True the print command is directed in the cmd, False if directed to the GUI

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- the options to crete the figure if save\_fig1d is True

\item {} 
\sphinxstyleliteralstrong{xmlfiles} -- the list of the xml file (only useful to get the preference curve report, so not used by habby\_cmd)

\end{itemize}

\end{description}\end{quote}

** Technical comments**

This function redirect the sys.stdout. The point of doing this is because this function will be call by the GUI or
by the cmd. If it is called by the GUI, we want the output to be redirected to the windows for the log under HABBY.
If it is called by the cmd, we want the print function to be sent to the command line. We make the switch here.

\end{fulllineitems}

\index{calc\_hab\_norm() (in module src.calcul\_hab)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.calcul_hab.calc_hab_norm}}\pysiglinewithargsret{\sphinxcode{src.calcul\_hab.}\sphinxbfcode{calc\_hab\_norm}}{\emph{ikle\_all\_t}, \emph{point\_all\_t}, \emph{vel}, \emph{height}, \emph{sub}, \emph{pref\_vel}, \emph{pref\_height}, \emph{pref\_sub}, \emph{percent=False}, \emph{take\_sub=True}}{}
This function calculates the habitat suitiabilty index (f(H)xf(v)xf(sub)) for each and the SPU which is the sum of
all habitat suitability index weighted by the cell area for each reach. It is called by clac\_hab\_norm.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{ikle\_all\_t} -- the connectivity table for all time step, all reach

\item {} 
\sphinxstyleliteralstrong{point\_all\_t} -- the point of the grid

\item {} 
\sphinxstyleliteralstrong{vel} -- the velocity data for all time step, all reach

\item {} 
\sphinxstyleliteralstrong{height} -- the water height data for all time step, all reach

\item {} 
\sphinxstyleliteralstrong{sub} -- the substrate data (can be coarser or dominant substrate based on function's call)

\item {} 
\sphinxstyleliteralstrong{pref\_vel} -- the preference index for the velcoity (for one life stage)

\item {} 
\sphinxstyleliteralstrong{pref\_sub} -- the preference index for the substrate  (for one life stage)

\item {} 
\sphinxstyleliteralstrong{pref\_height} -- the preference index for the height  (for one life stage)

\item {} 
\sphinxstyleliteralstrong{percent} -- If True, the variable sub is in percent form, not in the form dominant/coarser

\item {} 
\sphinxstyleliteralstrong{take\_sub} -- If False, the substrate data is neglected.

\end{itemize}

\item[{Returns}] \leavevmode
vh of one life stage, area, habitat value

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_pref\_value() (in module src.calcul\_hab)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.calcul_hab.find_pref_value}}\pysiglinewithargsret{\sphinxcode{src.calcul\_hab.}\sphinxbfcode{find\_pref\_value}}{\emph{data}, \emph{pref}}{}
This function finds the preference value associated with the data for each cell. For this, it finds the last
point of the preference curve under the data and it makes a linear interpolation with the next data to
find the preference value. As preference value is sorted, it uses the module bisect to accelerate the process.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{data} -- the data on the cells (for one time step, on reach)

\item {} 
\sphinxstyleliteralstrong{pref} -- the pref data {[}pref, class data{]}

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_hist\_biology() (in module src.calcul\_hab)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.calcul_hab.plot_hist_biology}}\pysiglinewithargsret{\sphinxcode{src.calcul\_hab.}\sphinxbfcode{plot\_hist\_biology}}{\emph{vh\_all\_t\_sp}, \emph{area\_c\_all\_t}, \emph{name\_fish}, \emph{fig\_opt}, \emph{path\_im}, \emph{timestep}, \emph{name\_base}, \emph{sim\_name={[}{]}}, \emph{erase\_id=False}}{}
This function plot the historgram of the habitat value for the slected species and time step. This historgramm
is weighted by the area of the cell.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{vh\_all\_t\_sp} -- The habitat value by cell by reach by time step by species

\item {} 
\sphinxstyleliteralstrong{area\_c\_all\_t} -- the area of each cell

\item {} 
\sphinxstyleliteralstrong{name\_fish} -- the name of the fish chosen
:param fig\_opt: the figure options

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the images

\item {} 
\sphinxstyleliteralstrong{timestep} -- a list with the time step to be plotted

\item {} 
\sphinxstyleliteralstrong{name\_base} -- the base on which to form the figure name

\item {} 
\sphinxstyleliteralstrong{sim\_name} -- the name of the time steps when not 0,1,2,3

\item {} 
\sphinxstyleliteralstrong{erase\_id} -- If True, we erase a figure with an identical name

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_hist\_hydro() (in module src.calcul\_hab)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.calcul_hab.plot_hist_hydro}}\pysiglinewithargsret{\sphinxcode{src.calcul\_hab.}\sphinxbfcode{plot\_hist\_hydro}}{\emph{hdf5\_file}, \emph{path\_hdf5}, \emph{vel\_c\_all\_t}, \emph{height\_c\_all\_t}, \emph{area\_c\_all\_t}, \emph{fig\_opt}, \emph{path\_im}, \emph{timestep}, \emph{name\_base}, \emph{sim\_name={[}{]}}, \emph{erase\_id=False}}{}
This function plots an historgram of the hydraulic and substrate data for the selected timestep. This historgramm
is weighted by the area of the cell. The data is based on the height and velocity data by cell and not on the node.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{hdf5\_file} -- the name of the hdf5 file

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- the path to this file

\item {} 
\sphinxstyleliteralstrong{vel\_c\_all\_t} -- the velcoity for all reach all time step by cell

\item {} 
\sphinxstyleliteralstrong{height\_c\_all\_t} -- the water height for all reach all time step by cell

\item {} 
\sphinxstyleliteralstrong{area\_c\_all\_t} -- the aire of cells for all reach, all time step

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- the figure options

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the images

\item {} 
\sphinxstyleliteralstrong{timestep} -- a list with the time step to be plotted

\item {} 
\sphinxstyleliteralstrong{name\_base} -- the base on which to form the figure name

\item {} 
\sphinxstyleliteralstrong{sim\_name} -- the name of the time steps when not 0,1,2,3

\item {} 
\sphinxstyleliteralstrong{erase\_id} -- If True, we erase a figure with an identical name

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{remove\_image() (in module src.calcul\_hab)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.calcul_hab.remove_image}}\pysiglinewithargsret{\sphinxcode{src.calcul\_hab.}\sphinxbfcode{remove\_image}}{\emph{name}, \emph{path}, \emph{format1}}{}
This is a small function used to erase images if erase\_id is True. We have a function because different format
czan be used and because it is done often in the functions above.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{name} -- the name of the file t be erase (without the extension)

\item {} 
\sphinxstyleliteralstrong{path} -- the path to the file

\item {} 
\sphinxstyleliteralstrong{format1} -- the type of format

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{save\_hab\_fig\_spu() (in module src.calcul\_hab)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.calcul_hab.save_hab_fig_spu}}\pysiglinewithargsret{\sphinxcode{src.calcul\_hab.}\sphinxbfcode{save\_hab\_fig\_spu}}{\emph{area\_all}, \emph{spu\_all}, \emph{name\_fish}, \emph{path\_im}, \emph{name\_base}, \emph{fig\_opt=\{\}}, \emph{sim\_name={[}{]}}, \emph{erase\_id=False}, \emph{do\_save=True}}{}
This function creates the figure of the spu as a function of time for each reach. if there is only one
time step, it reverse to a bar plot. Otherwise it is a line plot.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{area\_all} -- the area for all reach

\item {} 
\sphinxstyleliteralstrong{spu\_all} -- the ``surface pondere utile'' (SPU) for each reach

\item {} 
\sphinxstyleliteralstrong{name\_fish} -- the list of fish latin name + stage

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the image

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- the dictionnary with the figure options

\item {} 
\sphinxstyleliteralstrong{name\_base} -- a string on which to base the name of the files

\item {} 
\sphinxstyleliteralstrong{sim\_name} -- the name of the time steps if not 0,1,2,3

\item {} 
\sphinxstyleliteralstrong{erase\_id} -- If True, figure from identical simuation are erased

\item {} 
\sphinxstyleliteralstrong{do\_save} -- If False, the figure is not saved, but the figure is returned to be used for something else

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{save\_hab\_shape() (in module src.calcul\_hab)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.calcul_hab.save_hab_shape}}\pysiglinewithargsret{\sphinxcode{src.calcul\_hab.}\sphinxbfcode{save\_hab\_shape}}{\emph{name\_merge\_hdf5}, \emph{path\_hdf5}, \emph{vh\_data}, \emph{vel\_data}, \emph{height\_data}, \emph{name\_fish\_sh}, \emph{path\_shp}, \emph{name\_base}, \emph{sim\_name={[}{]}}, \emph{save\_perc=False}, \emph{erase\_id=False}}{}
This function create the output in the form of a shapefile. It creates one shapefile by time step. It put
all the reaches together. If there is overlap between reaches, it does not care. It create an attribute table
with the habitat value, velocity, height, substrate coarser, substrate dominant. It also create a shapefile
0 with the whole profile without data.

The name of the column of the attribute table should be less than 10 character. Hence, the variable name\_fish
has been adapted to be shorter. The shorter name\_fish is called name\_fish\_sh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{name\_merge\_hdf5} -- the name of the hdf5 merged file

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- the path to the hydrological hdf5 data

\item {} 
\sphinxstyleliteralstrong{vel\_data} -- the velocity by reach by time step on the cell (not node!)

\item {} 
\sphinxstyleliteralstrong{height\_data} -- the height by reach by time step on the cell (not node!)

\item {} 
\sphinxstyleliteralstrong{vh\_data} -- the habitat value data by speces by reach by tims tep

\item {} 
\sphinxstyleliteralstrong{name\_fish\_sh} -- the list of fish latin name + stage

\item {} 
\sphinxstyleliteralstrong{path\_shp} -- the path where to save the shpaefile

\item {} 
\sphinxstyleliteralstrong{name\_base} -- a string on which to base the name of the files

\item {} 
\sphinxstyleliteralstrong{sim\_name} -- the time step's name if not 0,1,2,3

\item {} 
\sphinxstyleliteralstrong{save\_perc} -- It true the substrate in percentage will be added to the shapefile

\item {} 
\sphinxstyleliteralstrong{erase\_id} -- If True, we erase old text file from identical hydraulic model

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{save\_hab\_txt() (in module src.calcul\_hab)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.calcul_hab.save_hab_txt}}\pysiglinewithargsret{\sphinxcode{src.calcul\_hab.}\sphinxbfcode{save\_hab\_txt}}{\emph{name\_merge\_hdf5}, \emph{path\_hdf5}, \emph{vh\_data}, \emph{vel\_data}, \emph{height\_data}, \emph{name\_fish}, \emph{path\_txt}, \emph{name\_base}, \emph{sim\_name={[}{]}}, \emph{erase\_id=False}}{}
This function print the text output. We create one set of text file by time step. Each Reach is separated by the
key work REACH follwoed by the reach number (strating from 0). There are three files by time steps: one file which
gives the connectivity table (starting at 0), one file with the point coordinates in the
coordinate systems of the hydraulic models (x,y), one file wiche gives the results.
In all three files, the first column is the reach number. In the results files, the next columns are velocity,
height, substrate, habitat value for each species. Use tab instead of space to help with excel import.

The name and the form of the files do not change with the chosen language. The idea is that these files are quite big
and that they will mostly be used by computer program. So it is easier for the user if the name and form is coherent.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{name\_merge\_hdf5} -- the name of the hdf5 merged file

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- the path to the hydrological hdf5 data

\item {} 
\sphinxstyleliteralstrong{vel\_data} -- the velocity by reach by time step on the cell (not node!)

\item {} 
\sphinxstyleliteralstrong{height\_data} -- the height by reach by time step on the cell (not node!)

\item {} 
\sphinxstyleliteralstrong{vh\_data} -- the habitat value data by speces by reach by tims tep

\item {} 
\sphinxstyleliteralstrong{name\_fish} -- the list of fish latin name + stage

\item {} 
\sphinxstyleliteralstrong{path\_txt} -- the path where to save the text file

\item {} 
\sphinxstyleliteralstrong{name\_base} -- a string on which to base the name of the files

\item {} 
\sphinxstyleliteralstrong{sim\_name} -- the name of the simulation/time step (list of strings)

\item {} 
\sphinxstyleliteralstrong{erase\_id} -- If True, we erase old text file from identical hydraulic model

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{save\_spu\_txt() (in module src.calcul\_hab)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.calcul_hab.save_spu_txt}}\pysiglinewithargsret{\sphinxcode{src.calcul\_hab.}\sphinxbfcode{save\_spu\_txt}}{\emph{area\_all}, \emph{spu\_all}, \emph{name\_fish}, \emph{path\_txt}, \emph{name\_base}, \emph{sim\_name={[}{]}}, \emph{lang=0}, \emph{erase\_id=False}}{}
This function create a text files with the folowing columns: the tiem step, the reach number, the area of the
reach and the spu for each fish species. Use tab instead of space to help with excel import.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{area\_all} -- the area for all reach

\item {} 
\sphinxstyleliteralstrong{spu\_all} -- the ``surface pondere utile'' (SPU) for each reach

\item {} 
\sphinxstyleliteralstrong{name\_fish} -- the list of fish latin name + stage

\item {} 
\sphinxstyleliteralstrong{path\_txt} -- the path where to save the text file

\item {} 
\sphinxstyleliteralstrong{name\_base} -- a string on which to base the name of the files

\item {} 
\sphinxstyleliteralstrong{sim\_name} -- the name of the time step

\item {} 
\sphinxstyleliteralstrong{lang} -- an int which indicates the chosen language (0 is english)

\item {} 
\sphinxstyleliteralstrong{erase\_id} -- If True, we erase old text file from identical hydraulic model

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{save\_vh\_fig\_2d() (in module src.calcul\_hab)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.calcul_hab.save_vh_fig_2d}}\pysiglinewithargsret{\sphinxcode{src.calcul\_hab.}\sphinxbfcode{save\_vh\_fig\_2d}}{\emph{name\_merge\_hdf5, path\_hdf5, vh\_all\_t\_sp, path\_im, name\_fish, name\_base, fig\_opt=\{\}, time\_step={[}-1{]}, sim\_name={[}{]}, save\_fig=True, erase\_id=False}}{}
This function creates 2D map of the habitat value for each species at
the time step asked. All reaches are ploted on the same figure.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{name\_merge\_hdf5} -- the name of the hdf5 merged file

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- the path to the hydrological hdf5 data

\item {} 
\sphinxstyleliteralstrong{vh\_all\_t\_sp} -- the habitat value for all reach all time step all species

\item {} 
\sphinxstyleliteralstrong{path\_im} -- the path where to save the figure

\item {} 
\sphinxstyleliteralstrong{name\_fish} -- the name and stage of the studied species

\item {} 
\sphinxstyleliteralstrong{name\_base} -- the string on which to base the figure name

\item {} 
\sphinxstyleliteralstrong{fig\_opt} -- the dictionnary with the figure options

\item {} 
\sphinxstyleliteralstrong{time\_step} -- which time step should be plotted

\item {} 
\sphinxstyleliteralstrong{sim\_name} -- the name of the time step if not 0,1,2,3

\item {} 
\sphinxstyleliteralstrong{save\_fig} -- If True the figure is saved

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{Create Paraview Files}
\label{\detokenize{index:create-paraview-files}}
in src/new\_create\_vtk.py
in src/evtk.py
in src/hl.py
in src/vtk.py
in src/xml\_vk.py

Theses modules contain the scripts to create Paraview input which are binary xml-based vtu files. This part is heavily based on the module
Pyevtk created by Paulo Herrera (\url{https://bitbucket.org/pauloh/pyevtk}). Hence, the only script written for HABBY is in new\_create\_vtk.py. This
script then called one function in hl.py which then called the three other scripts as in Pyevtk (not documented here).
\phantomsection\label{\detokenize{index:module-src.new_create_vtk}}\index{src.new\_create\_vtk (module)}\index{habitat\_to\_vtu() (in module src.new\_create\_vtk)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.new_create_vtk.habitat_to_vtu}}\pysiglinewithargsret{\sphinxcode{src.new\_create\_vtk.}\sphinxbfcode{habitat\_to\_vtu}}{\emph{file\_name\_base}, \emph{path\_out}, \emph{path\_hdf5}, \emph{name\_hdf5}, \emph{vh\_all\_t\_sp}, \emph{height\_c\_data}, \emph{vel\_c\_data}, \emph{name\_fish}, \emph{erase\_id}}{}
This function creates paraview input in the new, non-legacy xml format. This function called the evtk class
written by Paulo Herrera, which is available at \url{https://bitbucket.org/pauloh/pyevtk/downloads/}

The format for paravier input file is descirbed in paraview\_file\_format.pdf in the doc folder of HABBY.

The data of the paraview file created here  is usually in binary form. The idea of paraview for a binary file is
to keep the same usual xml file. The data is encoded to base64. Before the binary array, there is a 32-bits interger
which contains the data length in bytes.
More info: \url{http://www.earthmodels.org/software/vtk-and-paraview/vtk-file-formats}.

Paraview can handle a group of file which compose an output with than one time step. This is the reason to create a
pwd files which list the files composing all the time steps (one file by time step)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_name\_base} -- the base to create the name of the vtu file

\item {} 
\sphinxstyleliteralstrong{path\_hdf5} -- the path to the hdf5 hydro file (to load the grid)

\item {} 
\sphinxstyleliteralstrong{name\_hdf5} -- the name of the hdf5 containing the grid

\item {} 
\sphinxstyleliteralstrong{vh\_all\_t\_sp} -- the habitat data by reach, time step, species

\item {} 
\sphinxstyleliteralstrong{height\_c\_data} -- the height by cell by reach by time step

\item {} 
\sphinxstyleliteralstrong{vel\_c\_data} -- the velocity by cell by reach by time step

\item {} 
\sphinxstyleliteralstrong{name\_fish} -- the name of fish and stage

\item {} 
\sphinxstyleliteralstrong{path\_out} -- the path where to save the data

\item {} 
\sphinxstyleliteralstrong{erase\_id} -- if True, previous paraview file from identical merge file are erased

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module src.new\_create\_vtk)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.new_create_vtk.main}}\pysiglinewithargsret{\sphinxcode{src.new\_create\_vtk.}\sphinxbfcode{main}}{}{}
Used to test this module

\end{fulllineitems}

\index{writePVD() (in module src.new\_create\_vtk)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.new_create_vtk.writePVD}}\pysiglinewithargsret{\sphinxcode{src.new\_create\_vtk.}\sphinxbfcode{writePVD}}{\emph{fileName}, \emph{fileNames}}{}
This function write the file which indicates to paraview how to group the file. This ``grouping'' file is pvd file.
With this file, paraview can open all the time steps together with one clic. This function is heavily inspired
by the class given at the adress:
\url{https://github.com/cfinch/Shocksolution\_Examples/blob/master/Visualization/vtktools.py}. Because Element Tree
was not used in the class from Shocksolution, we use minidom here instead of Element Tree.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{fileName} -- the name of the pvd file

\item {} 
\sphinxstyleliteralstrong{fileNames} -- the names of all the files for this time step (usually only for one reach but could be changed).

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{Function for the command lines}
\label{\detokenize{index:function-for-the-command-lines}}
in src/func\_for\_cmd.py

This module contains functions which are used by habby.py when called on the command line (witjout using the GUI).
\phantomsection\label{\detokenize{index:module-src.func_for_cmd}}\index{src.func\_for\_cmd (module)}\index{all\_command() (in module src.func\_for\_cmd)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.func_for_cmd.all_command}}\pysiglinewithargsret{\sphinxcode{src.func\_for\_cmd.}\sphinxbfcode{all\_command}}{\emph{all\_arg}, \emph{name\_prj}, \emph{path\_prj}, \emph{path\_bio}, \emph{option\_restart=False}, \emph{erase\_id=True}}{}
This function is used to call HABBY from the command line. The general form is to call:
habby\_cmd command\_name input1 input2 .. input n. The list of the command\_name is given in the documentation and by
calling the command ``python habby\_cmd.py LIST\_COMMAND''. This functiion is usually called direclty by the main()
or it is called by the function restart which read a list of function line by line. Careful, new command cannot
contain the symbol '':'' as it is used by restart.

For the restart function, it is also important that the input folder is just in the folder ``next'' to the restart
path. So the folder should not be moved randolmy inside the project folder or renamed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{all\_arg} -- the list of argument (sys.argv more or less)

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- the name of the project, created by default by the main()

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path to the project created by default bu the main()

\item {} 
\sphinxstyleliteralstrong{path\_bio} -- the path to the project

\item {} 
\sphinxstyleliteralstrong{option\_restart} -- If True the command are coming from a restart log (which have an impact on file name and
location)

\item {} 
\sphinxstyleliteralstrong{erase\_id} -- If True, the files with the same name are erased in merge. If False, ther kept with a time stamp

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{habby\_on\_all() (in module src.func\_for\_cmd)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.func_for_cmd.habby_on_all}}\pysiglinewithargsret{\sphinxcode{src.func\_for\_cmd.}\sphinxbfcode{habby\_on\_all}}{\emph{all\_arg}, \emph{name\_prj}, \emph{path\_prj}, \emph{path\_bio}, \emph{option\_restart=False}}{}
This function is used to execute a command from habby\_cmd on all files in a folder. The form of the command should
be something like ``habby\_cmd ALL COMMAND path\_to\_file/*.ext arg2 ag3'' with the arguments adated to the specific
command.

In other words, the command should be the usual command with the keyword ALL before and with the name of
the input files remplace by *.ext . where ext is the extension of the files.
It is better to not add an output name. Indeed default name for output includes the input file name, which
is practical if different files are given as input. If the default
is overided, the same name will be applied, only the time stamps will be different. To be sure to not overwrite a
file, this function waits one second between each command. Only the input argument should containts the string `*'.
Otherwise, other commands would be treated as input files.

If there is more than one type of input, it is important that the name of the file are the same (or at least
that there are in the same alphabetical order). If the variable \# is used instead of *, the function will be
applied to all second file one by one. So if we have two substrate file and two hydro file, name with * will result
in two merged files while \# will result in four merge file.

If more than one extension is possible (example g01, g02, g03, etc. in hec-ras), remplace the changing part of the
extension with the symbol * (so path\_to\_folder/*.g0* arg1 argn). If the name of the file changed in the extension
as in RUBAR (where the file have the name PROFIL.file), just change for PROFIL.* or something similar. Generally
the matching is done using the function glob, so the shell-type wildcard can be used.

As there are a lot of hdf5 intput, one should be careful to avoid mixing between the different type of hdf5 files.
For example, it is better to write `MERGE*.h5' as just `*.h5' if the folder contains hydraulic and merge files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{all\_arg} -- the list of argument (sys.argv without the argument ALL so {[}sys.argv{[}0{]}, sys.argv{[}2{]}, sys.argv{[}n{]}{]})

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- the name of the project, created by default by the main()

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path to the project created by default bu the main()

\item {} 
\sphinxstyleliteralstrong{path\_bio} -- the path to the project

\item {} 
\sphinxstyleliteralstrong{option\_restart} -- If True the command are coming from a restart log (which have an impact on file name and
location)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{habby\_restart() (in module src.func\_for\_cmd)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.func_for_cmd.habby_restart}}\pysiglinewithargsret{\sphinxcode{src.func\_for\_cmd.}\sphinxbfcode{habby\_restart}}{\emph{file\_comm}, \emph{name\_prj}, \emph{path\_prj}, \emph{path\_bio}}{}
This function reads a list of command from a text file called file\_comm. It then calls all\_command one each line
which does contain the symbol '':'' . If the lines contains the symbol '':'', it considered as an input.
Careful, the intput should be in order!!!! The info on the left and sight of the symbol '':'' are just there so
an human can read them more easily. Space does not matters here. We try to write the restart file created
automatically by HABBY in a ``nice'' layout, but it just to  read it more easily.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{file\_comm} -- a string wehich gives the name of the restart file (with the path)

\item {} 
\sphinxstyleliteralstrong{name\_prj} -- the name of the project, created by default by the main()

\item {} 
\sphinxstyleliteralstrong{path\_prj} -- the path to the project created by default bu the main()

\item {} 
\sphinxstyleliteralstrong{path\_bio} -- the path to the project

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_fstress\_text() (in module src.func\_for\_cmd)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.func_for_cmd.load_fstress_text}}\pysiglinewithargsret{\sphinxcode{src.func\_for\_cmd.}\sphinxbfcode{load\_fstress\_text}}{\emph{path\_fstress}}{}
This function loads the data for fstress from text files. The data is composed of the name of the rive, the
discharge range, and the {[}discharge, height, width{]}. To read the files, the files listriv.txt is given. Form then,
the function looks for the other files in the same folder. The other files are rivdeb.txt and rivqwh.txt. If more
than one river is given in listriv.txt, it load the data for all rivers.

There is a very similar function as a method in the class FStressW() in fstress\_GUI.py but it ised by the GUI
and it includes a way to select the file using the GUI. Changes should be copied in both functions if necessary.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{path\_fstress} -- the path to the listriv.txt function (the other fil should be in the same folder)

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_manning\_txt() (in module src.func\_for\_cmd)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:src.func_for_cmd.load_manning_txt}}\pysiglinewithargsret{\sphinxcode{src.func\_for\_cmd.}\sphinxbfcode{load\_manning\_txt}}{\emph{filename\_path}}{}
This function loads the manning data in case where manning number is not simply a constant. In this case, the manning
parameter is given in a .txt file. The manning parameter used by 1D model such as mascaret or Rubar BE to distribute
velocity along the profiles. The format of the txt file is ``p, dist, n'' where  p is the profile number (start at zero),
dist is the distance along the profile in meter and n is the manning value (in SI unit). White space is neglected
and a line starting with the character \# is also neglected.

There is a very similar function as a method in the class Sub\_HydroW() in hydro\_GUI.py but it used by the GUI
and it includes a way to select the file using the GUI and it used a lot of class attribute. So it cannot be used
by the command line. Changes should be copied in both functions if necessary.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{filename\_path} -- the path and the name of the file containing the manning data

\item[{Returns}] \leavevmode
the manning as an array form

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Various notes}
\label{\detokenize{index:various-notes}}

\section{Figures and matplotlib}
\label{\detokenize{index:figures-and-matplotlib}}
\sphinxstylestrong{The legend of the plots are not shown.}

Generally HABBY is able to save the figure while showing the legend (which is often outside of the figure) appropriately. However,
the figure shown to the user by matplotlib often have the legend outside of the visible area. To see the figure fully, one can modify
the axes in the option of the figure (the menu in the axes on the top of the figure).

\sphinxstylestrong{How to make figures editable in Adobe Illustrator}

It is useful to have figures which we can edit in Adobe Illustrator. To achieve this, the following matplotlib option should be added:
mpl.rcParams{[}'pdf.fonttype'{]} = 42. Moreover, matplolib should be imported (import matplotlib as mpl). It is also useful to add the tranparent option to the function to save the figure (transparent=True). This renders modification easier in many cases. However, it is not good to use mpl.rcParams{[}'ps.fonttype'{]} = 42 as the figure created in the eps format would be corrupted because of a bug in matplotlib.


\section{Translation of HABBY}
\label{\detokenize{index:translation-of-habby}}
In HABBY, it is possible to translate all strings which are in a python file (.py)
which is in the src\_GUI folder.

To add a new string to translate:
\begin{itemize}
\item {} 
Code as usual and write the string in English.

\item {} 
Add self.tr() around the string  a = Qlabel(self.tr(“My message”))

\item {} 
If the code is in a new python file (like the .py was just created), open the habby\_trans.pro file which is src\_GUI. Then add the line SOURCES+= new\_file.py where new\_file.py is the new python file.

\item {} 
If you want to add a new language, add the line TRANSLATIONS += Zen\_ES.ts in the case you want to add Spanish or any other language.

\item {} 
Copy the files ZEN\_EN.ts and ZEN\_FR.ts from HABBY/translation to /src\_GUI

\item {} 
In the src\_GUI folder, run the following command on the cmd: pylupdate5 habby\_trans.pro. it will work if pylupdate is installed.

\item {} 
It should update the .ts file (which is an xml file)

\item {} 
Copy both .ts file back to HABBY/translation

\item {} 
Open Qt  linguist. This is a program that you need to install before. Open the French .ts file. The English should not need translation.

\item {} 
Translate as needed and save in Qt Linguist.

\item {} 
A .qm file is the binary representing the .ts file with all the translation. To create .qm file, type (in the cmd) lrelease  file.ts. It will create a file.qm file

\item {} 
Run HABBY. The string should be updated.

\end{itemize}

\sphinxstylestrong{In the code}

If the user asked for a new language, we need to reload the translator with the following lines:
\begin{quote}

\sphinxstyleemphasis{app = QApplication.instance()}

\sphinxstyleemphasis{self.languageTranslator.load(file.qm, self.path\_trans)}

\sphinxstyleemphasis{app.installTranslator(self.languageTranslator)}
\end{quote}

with the appropriate name for “file.qm”.

In HABBY, the list of the name of all qm file are in the variable self.file\_langue
in class MainWindows. Hence, we can follow the selected language using an integer self.lang
(0 for English and 1 for French). We can now call self.file\_langue{[}self.lang{]} to get the qm
file in the right language. If a new language is added, it is necessary to add one string to this
list and to modify the menu. If the new language is also present in the xml preference file
(which contains the biological info), it is also necessary to update the variable ``bioinfo\_tab.lang''
from central\_widget in the function setlangue from Main\_Windows(). If this is done, the description of
the xml preference file in the ``Biology'' tab will be shown in the selected language. Otherwise, it will be
the first language found.

When the translator has been created, it is necessary to re-do all Widgets and Windows. This is not a problem when we open HABBY, but it can be a bit of work if the user asks for a change in language when HABBY is running. This is the function of the setlangue function. This function would work for all language (it takes an integer as input to know which language to use), but it needs to be modified if one modifies the Main\_Windows Class strongly (notably if one add signals).
The language should be saved in the user setting using Qsettings as it is done at the end of the
setlangue function.

In addition, every xml project file from HABBY has a part called ``FigureOPtion''. In the list of available options, there is the language currently used under the attibute ``LangFig''. The language is given using an int (0 for english, 1 for french). This is useful to translate the axis and the titles of the figures done by HABBY. To this end, one would first called the function ``load\_fig\_option'' in output\_fig\_GUI.py. This returns a dictionnary with a key called ``language'' (0 for english, 1 for french). Then, one can use an if statement to write the xlabel in french or english.


\section{Create a .exe}
\label{\detokenize{index:create-a-exe}}
Here are step to create a .exe using PyInstaller:
\begin{itemize}
\item {} 
install Pyinstaller (pip install pyinstaller)

\item {} 
cd ``folder with source code''

\item {} 
pyinstaller.exe {[}option{]} habby.py, with the option --onefile to get only one .exe and --windowed to not have the cmd which opens with the application.

\end{itemize}

Here are some common problems:
\begin{itemize}
\item {} 
ImportError: (No module named `PyQt5.QtGui'): Copy the folder platform with qwindows.dll and add to the set\_up.py  ``includes'': {[}''PyQt5.QtCore'', ``PyQt5.QtGui''{]}

\item {} 
This application fails to start because ... the Qt platform pugin windows: Copy the folder platform with qwindows.dll in it

\item {} 
ImportError: h5Py ``includes'': {[}''h5py'',''h5py.defs'', ``h5py.utils'', ``h5py.h5ac'', `h5py.\_proxy' {]} etc if necessary

\item {} 
Intel MKL fatal error copy the .dll missing (or just find an old dist and copy all mkl stuff) AND the libiomp5md.dll

\item {} 
The translation does not work: Add the translation folder into the dist folder

\item {} 
Do not find log0.txt (or crash when saving project): create a folder called src\_GUI, copy the files log0.txt and restart\_log0.txt from the src\_GUI folder in the python module

\end{itemize}

Practically:
\begin{itemize}
\item {} 
go to the folder called executable and copy the current HABBY source there.

\item {} 
copy createexe.bat in the habby folder.

\item {} 
run createexe.bat (only on Windows)

\item {} 
ignore the executable created in the ``built'' folder Use the one is in the ``dist'' folder.

\item {} 
copy all files in the mklall folder to the folder dist/habby.

\item {} 
copy all the files in the original src\_GUI folder which are NOT python file to the src\_GUI folder just created (or you know, improve the bat file...).

\item {} 
copy the doc folder in the dist/habby folder

\item {} 
run habby by writing habby on the cmd

\item {} 
test and correct problems. It can be long!

\end{itemize}


\section{Logging}
\label{\detokenize{index:logging}}
\sphinxstylestrong{General information}

There are two different logs for HABBY. By default, the first one is called “name\_projet”.log and
the second is called restart/\_'name\_project'.log. Their name and path can be changed in the xml
project file. Both file are text file.

The first log is in the form of a python file with comments. If python and the necessary modules
are installed on the machine, this log can be renamed “name.py” and started as a python file.
In the command line, the following command should be used: python name.py. This file can be
modified to create a new script to use HABBY in a different ways. For this, python syntax should be used.

The second log, called restart/\_’name\_project’.log, has limited functionalities but allows to
re-start the HABBY simulation from the command line, without the need for python.
Format of this file is described below. It is aimed to be readable and easily modifiable.
To use the restart file, type in the command line: python habby.py restart/\_’name\_project’.log.

This part genreally needs more revisions and tests.

\sphinxstylestrong{Type of log and format}

Currently, there are five types of outputs, which can be sent to the log:
\begin{itemize}
\item {} 
Comment, which should start with \#. They will be sent to the python-type log file and to the GUI of Habby.

\item {} 
Errors, which should start with word “Error”. They will be sent to the python-type log file and to the GUI of Habby. In the GUI, they will appear in red.

\item {} 
Warnings, which should start with the word “Warning”. They will be sent to the python-type log file and to the GUI of Habby. In the GUI, they will appear in orange.

\item {} 
Restart info, which should start with the word “restart’. They will be sent to the restart\_’name\_project’.log. The format will be developed afterwards.

\item {} 
All types of text which do not start with these code words are only shown to the GUI of Habby.

\item {} 
Python code, which should start with the line py followed by four spaces.  It will be sent to the python-type log file. It is usually a function which is part of Habby code. The different arguments of the function should be given in the preceding lines.

\end{itemize}

\sphinxstylestrong{Example}

Let’s write to the log a function which takes an integer and a string as input. The function
is in the module called habby1, which is imported by default in the .log file. The strings to send
as log would be:
\begin{itemize}
\item {} 
``\#  this my fancy function''

\item {} 
``py    my\_int = '' + str(my\_int\_in\_code)

\item {} 
``py    my\_string = ’” + my\_string\_in\_the \_code+ ``'“

\item {} 
``py    habby1.myfunc(my\_int, my\_string)''

\end{itemize}

A comment should be added before each chunk of python code to improve the readability.

\sphinxstylestrong{Update the log}

Let’s consider a scenario where a new function has been written in a non-GUI module (class or
function) and has to be called in the GUI in a method of a class. Let’s call the new function
new\_func and the class in the GUI my\_class.

To create a new line of log for new\_func, one should follow these steps:
\begin{itemize}
\item {} 
A PyQtsignal with a string as argument should be added to my\_class: send\_log = pyqtSignal(str, name='send\_log')

\item {} 
If a log should be sent directly from my\_class (for example, to say that new\_func  has been called), the signal should be emitted: self.send\_log.emit(`\# new\_func has been called'))

\item {} 
In the new function,  error and warning are written as follows: print(“Error: here is an error.n”) or print(“Warning:  This is just a warning.n”)

\item {} 
In my\_class, error and warning are collected by redirecting stdout to a string. The following lines of code should be added around the calling of my\_func():
\begin{itemize}
\item {} 
sys.stdout = mystdout = StringIO()  \# redirect stdout

\item {} 
my\_func(my\_int,my\_string)

\item {} 
sys.stdout = sys.\_\_stdout\_\_   \# re-sent stdout to the cmd

\item {} 
str\_found = mystdout.getvalue()   \# get all warning, error, text,…

\item {} 
str\_found = str\_found.split(`n')  \# separate each message

\item {} 
for i in range(0, len(str\_found)):
\begin{itemize}
\item {} 
if len(str\_found{[}i{]}) \textgreater{} 1:
\begin{itemize}
\item {} 
self.send\_log.emit(str\_found{[}i{]})  \#send the text

\end{itemize}

\end{itemize}

\end{itemize}

\item {} 
To import StringIO, the following statement is needed at the start of the code: from io import StringIO

\item {} 
If new\_func is called from the command line, stdout will not be redirected and the errors or warnings will be printed on the cmd as usual.  Stderr should be re-directed in a similar manner if needed.

\item {} 
The signal should be collected in the function connect\_signal\_log in the Main\_Windows\_1.py.  For this, a line should be added in the function:
*       self.my\_class.send\_log.connect(self.write\_log)

\end{itemize}

\sphinxstylestrong{restart file}

The format of the restart file is based on the format asked by the functions in func\_for\_cmd.py. More information on this format in func\_for\_cmd.py
(notably in the part list\_command).


\section{Git - code management}
\label{\detokenize{index:git-code-management}}
\sphinxstylestrong{Pour commencer:}
\begin{itemize}
\item {} 
Choisir un dossier sur l’ordinateur local ou va se trouver les fichiers sources.

\item {} 
cd  « dossier avec les codes source»

\item {} 
git config - - global user.name « username »

\item {} 
git config - - global user.email  « mail »

\item {} 
git init

\item {} 
lier le repertoire local avec le repertoire distant sur forge.irstea.fr

\end{itemize}

** Pour cloner HABBY**
*       cd « dossier souhaité»
*       git clone \url{https://git.irstea.fr/git/habby}

\sphinxstylestrong{Pour mettre une nouvelle version sur le site web}
\begin{itemize}
\item {} 
cd « dossier avec les codes source»

\item {} 
git pull (prend la dernière version à jour sur le site et mets tous les fichiers ensemble) ou git fetch (prend juste les derniers fichiers sans mettre tous les fichiers ensemble).

\item {} 
git add ‘my\_file.py ou .pyc’ (choisit les fichiers qui doivent être envoyé), le signe * fonctionne.

\item {} 
git log (donne l’historique)

\item {} 
git status (donne les nouveaux fichiers locals)

\item {} 
git commit \textendash{}m « description » (commit localement)

\item {} 
git push

\end{itemize}

\sphinxstylestrong{Pour ajouter une nouvelle branche}
\begin{itemize}
\item {} 
Donc pour avoir une partie du travail sépare du reste

\item {} 
git checkout \textendash{}b {[}branchname{]} pour créer la branche et y travailler

\item {} 
git checkout {[}branchname{]} pour y travailler

\end{itemize}


\section{Test HABBY}
\label{\detokenize{index:test-habby}}
For the moment, there are two automatic tests for HABBY which are in the HABBY folder. This is test\_habby\_quick which takes about 2 minutes to run and which only test one simple habitat calculation, and test\_habby2 which tests the loading of the different hydraulic models, the creation of computational grid for 1D hydraulic models, the habitat calculation on diverse cases and the statistical models. It takes about two hours to run.

The test are bash codes so they run under Windows only, but it is relatively easy to modify the script to run it under another exploitation system. To run it under a new Windows computer, it is also necessary to change the first lines of the bash codes to give the paths of the folders with the original data. These folders are not in the HABBY folder as they need about 7 Giga of space.

There is no test for the GUI at the moment as we did not find a practical tool to test it.


\section{Write the documentation}
\label{\detokenize{index:write-the-documentation}}
Habby uses Sphinx to document the code. Sphinx uses the docstring given in each function. Hence, it is necessary to write a docstring for each function which has to be documented.

To update the html documentation, go to the doc folder and execute the command: “make html”.

To update the Latex documentation, use the commande ``make latex'' and use Miketex to create the pdf. rts2pdf does not work with Python 3.

To add text in the documentation, modify the index.rst file in the doc folder. To add a new module to the
documentation, add the module as written in the index.rts file in the doc folder. To add text comment, the index.rts file can also be direclty modified.

It is important to keep the formatting and the alignment.

If the module is in a new folder, the address of the folder must be added to the config.py file.
It is better to not use absolute path for this, so it is possible to move the documentation on another
computer. If the documentation does not run on a new computer, check the path given in the config.py file.

In the docstring, add as many blank lines as possible (in reasonable limit). This is easier for the
formatting. To make a bullet list, one should use a tab and the symbol ``*''.  Using only the symbol ``*'' will
fail.

To add a new title, do not start the title or the line of symbol under the title with a blank space.


\section{License of used python modules}
\label{\detokenize{index:license-of-used-python-modules}}\begin{itemize}
\item {} 
h5py: BSD License

\item {} 
Element tree (XML): MIT License

\item {} 
numpy: BSD License

\item {} 
matplotlib: BSD License

\item {} 
PyQt5: GNU License

\item {} 
Scipy: BSD license

\item {} 
shutil:

\end{itemize}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{s}
\item {\sphinxstyleindexentry{src}}\sphinxstyleindexpageref{index:\detokenize{module-src}}
\item {\sphinxstyleindexentry{src.bio\_info}}\sphinxstyleindexpageref{index:\detokenize{module-src.bio_info}}
\item {\sphinxstyleindexentry{src.calcul\_hab}}\sphinxstyleindexpageref{index:\detokenize{module-src.calcul_hab}}
\item {\sphinxstyleindexentry{src.dist\_vistess2}}\sphinxstyleindexpageref{index:\detokenize{module-src.dist_vistess2}}
\item {\sphinxstyleindexentry{src.estimhab}}\sphinxstyleindexpageref{index:\detokenize{module-src.estimhab}}
\item {\sphinxstyleindexentry{src.fstress}}\sphinxstyleindexpageref{index:\detokenize{module-src.fstress}}
\item {\sphinxstyleindexentry{src.func\_for\_cmd}}\sphinxstyleindexpageref{index:\detokenize{module-src.func_for_cmd}}
\item {\sphinxstyleindexentry{src.Hec\_ras06}}\sphinxstyleindexpageref{index:\detokenize{module-src.Hec_ras06}}
\item {\sphinxstyleindexentry{src.hec\_ras2D}}\sphinxstyleindexpageref{index:\detokenize{module-src.hec_ras2D}}
\item {\sphinxstyleindexentry{src.lammi}}\sphinxstyleindexpageref{index:\detokenize{module-src.lammi}}
\item {\sphinxstyleindexentry{src.load\_hdf5}}\sphinxstyleindexpageref{index:\detokenize{module-src.load_hdf5}}
\item {\sphinxstyleindexentry{src.manage\_grid\_8}}\sphinxstyleindexpageref{index:\detokenize{module-src.manage_grid_8}}
\item {\sphinxstyleindexentry{src.mascaret}}\sphinxstyleindexpageref{index:\detokenize{module-src.mascaret}}
\item {\sphinxstyleindexentry{src.mesh\_grid2}}\sphinxstyleindexpageref{index:\detokenize{module-src.mesh_grid2}}
\item {\sphinxstyleindexentry{src.new\_create\_vtk}}\sphinxstyleindexpageref{index:\detokenize{module-src.new_create_vtk}}
\item {\sphinxstyleindexentry{src.river2d}}\sphinxstyleindexpageref{index:\detokenize{module-src.river2d}}
\item {\sphinxstyleindexentry{src.rubar}}\sphinxstyleindexpageref{index:\detokenize{module-src.rubar}}
\item {\sphinxstyleindexentry{src.selafin\_habby1}}\sphinxstyleindexpageref{index:\detokenize{module-src.selafin_habby1}}
\item {\sphinxstyleindexentry{src.stathab\_c}}\sphinxstyleindexpageref{index:\detokenize{module-src.stathab_c}}
\item {\sphinxstyleindexentry{src.substrate}}\sphinxstyleindexpageref{index:\detokenize{module-src.substrate}}
\item {\sphinxstyleindexentry{src\_GUI}}\sphinxstyleindexpageref{index:\detokenize{module-src_GUI}}
\item {\sphinxstyleindexentry{src\_GUI.bio\_info\_GUI}}\sphinxstyleindexpageref{index:\detokenize{module-src_GUI.bio_info_GUI}}
\item {\sphinxstyleindexentry{src\_GUI.estimhab\_GUI}}\sphinxstyleindexpageref{index:\detokenize{module-src_GUI.estimhab_GUI}}
\item {\sphinxstyleindexentry{src\_GUI.fstress\_GUI}}\sphinxstyleindexpageref{index:\detokenize{module-src_GUI.fstress_GUI}}
\item {\sphinxstyleindexentry{src\_GUI.hydro\_GUI\_2}}\sphinxstyleindexpageref{index:\detokenize{module-src_GUI.hydro_GUI_2}}
\item {\sphinxstyleindexentry{src\_GUI.Main\_windows\_1}}\sphinxstyleindexpageref{index:\detokenize{module-src_GUI.Main_windows_1}}
\item {\sphinxstyleindexentry{src\_GUI.output\_fig\_GUI}}\sphinxstyleindexpageref{index:\detokenize{module-src_GUI.output_fig_GUI}}
\item {\sphinxstyleindexentry{src\_GUI.stathab\_GUI}}\sphinxstyleindexpageref{index:\detokenize{module-src_GUI.stathab_GUI}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}