<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Welcome to HABBY’s documentation! &#8212; HABBY 1 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">HABBY 1 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="welcome-to-habby-s-documentation">
<h1>Welcome to HABBY&#8217;s documentation!<a class="headerlink" href="#welcome-to-habby-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<p>HABBY is a program to estimate the habitat of fish using various hydrological models and preference curve as input.</p>
</div>
<div class="section" id="how-to-execute-habby">
<h1>How to execute HABBY<a class="headerlink" href="#how-to-execute-habby" title="Permalink to this headline">¶</a></h1>
<dl class="docutils">
<dt>To execute HABBY:</dt>
<dd><ul class="first last simple">
<li>Go to folder which contains habby.py using the command line.</li>
<li>Open the command line and type python habby.py.</li>
</ul>
</dd>
</dl>
<p>The python version should be 3.4. HABBY should also function with most of the python 3 distributions.</p>
<p>If a module is missing, it is possible to install it using pip (&#8220;pip install -m <em>module_name</em>&#8221;). Obviously, pip needs to installed, which should be done by default in python 3.4. If you want to be sure to have the same version of the module than originally, go to the folder zen_file/wheele with the command line and install the missing module from there (something similar to &#8220;pip install -m <em>.whl</em>&#8221;). Not all modules are in this folder, only the ones which were difficult to install.</p>
</div>
<div class="section" id="main-and-source-code">
<h1>Main(   ) and source code<a class="headerlink" href="#main-and-source-code" title="Permalink to this headline">¶</a></h1>
<p>The source code is separated in two folders: one folder which contain the code source for the graphical user interface (GUI) and one folder for the rest of the code source.</p>
<p>The dependency between the different part of the source code can be visualized in the mindmap real_GUI.xmind (xmind should be installed).</p>
<p>The main of HABBY is habby.py. It has the usual form for an application using PyQt5.  The main() creates an application of QWidget and call the Main_Windows class, which we will discuss shortly. The last line closes the application.</p>
</div>
<div class="section" id="graphical-interface">
<h1>Graphical interface<a class="headerlink" href="#graphical-interface" title="Permalink to this headline">¶</a></h1>
<p>Here is the list of all modules contains in the src_GUI folder.</p>
<div class="section" id="main-windows-of-habby">
<h2>Main_windows of HABBY<a class="headerlink" href="#main-windows-of-habby" title="Permalink to this headline">¶</a></h2>
<p>in src_GUI/Main_Windows_1.py</p>
<span class="target" id="module-src_GUI"></span><span class="target" id="module-src_GUI.Main_windows_1"></span><dl class="class">
<dt id="src_GUI.Main_windows_1.CentralW">
<em class="property">class </em><code class="descclassname">src_GUI.Main_windows_1.</code><code class="descname">CentralW</code><span class="sig-paren">(</span><em>rech</em>, <em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW" title="Permalink to this definition">¶</a></dt>
<dd><p>This class create the different tabs of the programm, which are then used as the central widget by the class
MainWindows.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rech</strong> &#8211; A bollean which is True if the tabs for the &#8220;research option&#8221; are shown. False otherwise.</li>
<li><strong>path_prj</strong> &#8211; A string with the path to the project xml file</li>
<li><strong>name_prj</strong> &#8211; A string with the name of the project</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>In the attribute list, there are a series of name which finish by “tab” such as stathab_tab or output_tab. Each of
these names corresponds to one tab and a new name should be added to the attributes to add a new tab.</p>
<p>During the creation of the class, each tab is created. Then, the signals to show the figures are connected between this
class and all the children classes which need it (often this are the classes used to load the hydrological data). When a
class emits the signal “show_fig”, CentralW collect this signal and show the figure, using the showfig function.</p>
<p>Show_fig is mostly a “plt.show()”. To avoid problem between matplotlib and PyQt, it is however important that
matplotlib use the backend “Qt5Agg” in the .py where the “plt.plot” is called. Practically, this means modifying
the matplotlib import.</p>
<p>Showfig shows only one figure. To show all existing figures, one can call the function show_fig2 from the menu.
Show_fig2 call the instance child_win of the class ShowImageW to open a new Windows with all figure. However,
this would only show the figure without any option for the zoom.</p>
<p>Then we call a function which connects all the signals from each class which need to write into the log. It is a good
policy to create a “send_log” signal for each new important class. As there are a lot of signal to connect, these
connections are written in the function “connect_signal_log”, where the signal for a new class can be added.</p>
<p>When this is done, the info for the general tab (created before) is filled. If the user has opened a project in HABBY
before, the name of the project and the other info related to it will be shown on the general tab. If the general
tab is modified in the class WelcomeW(), this part of the code which fill the general tab will probably needs to
be modified.</p>
<p>Finally, each tab is filled. The tabs have been created before, but there were empty. Now we fill each one with the
adequate widget. This is the link with many of the other classes that we describe below. Indeed, many of the widget
are based on more complicated classes created for example in hydro_GUI_2.py.</p>
<p>Then, we create an area under it for the log. Here HABBY will write various infos for the user. Two things to note
here: a) we should show the end of the scroll area. b) The size of the area should be controlled and not be
changing even if a lot of text appears. Hence, the setSizePolicy should be fixed.</p>
<p>The write_log() and write_log_file() method are explained in the section about the log.</p>
<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.connect_signal_log">
<code class="descname">connect_signal_log</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.connect_signal_log" title="Permalink to this definition">¶</a></dt>
<dd><p>connect all the signal linked to the log. This is in a function only to improve lisibility.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to initilize an instance of CentralW. Called by __init___().</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.optfig">
<code class="descname">optfig</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.optfig" title="Permalink to this definition">¶</a></dt>
<dd><p>A small function which open the output tab. It contains the different options for the figures.
Output should be the 6th tab, otherwise it will not work.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.scrolldown">
<code class="descname">scrolldown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.scrolldown" title="Permalink to this definition">¶</a></dt>
<dd><p>Move the scroll bar to the bottow if the ScollArea is getting bigger</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.showfig">
<code class="descname">showfig</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.showfig" title="Permalink to this definition">¶</a></dt>
<dd><p>A small function to show the last figure</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.showfig2">
<code class="descname">showfig2</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.showfig2" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to see all saved figures without possibility to zoom</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.write_log">
<code class="descname">write_log</code><span class="sig-paren">(</span><em>text_log</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.write_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to write the different log. Please read the section of the doc on the log.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>text_log</strong> &#8211; the text which should be added to the log (a string)</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>if text_log start with # -&gt; added it to self.l2 (QLabel) and the .log file (comments)</li>
<li>if text_log start with restart -&gt; added it restart_nameproject.txt</li>
<li>if text_log start with WARNING -&gt; added it to self.l2 (QLabel) and the .log file</li>
<li>if text_log start with ERROR -&gt; added it to self.l2 (QLabel) and the .log file</li>
<li>if text_log start with py -&gt; added to the .log file (python command)</li>
<li>if text_log start with nothing -&gt; just print to the Qlabel</li>
<li>if text_log out from stdout -&gt; added it to self.l2 (QLabel) and the .log file (comments)</li>
</ul>
<p>if logon = false, do not write in log.txt</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.write_log_file">
<code class="descname">write_log_file</code><span class="sig-paren">(</span><em>text_log</em>, <em>pathname_logfile</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.write_log_file" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to write to the .log text. Called by write_log.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>text_log</strong> &#8211; the text to be written (string)</li>
<li><strong>pathname_logfile</strong> &#8211; the path+name where the log is</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.Main_windows_1.EmptyTab">
<em class="property">class </em><code class="descclassname">src_GUI.Main_windows_1.</code><code class="descname">EmptyTab</code><a class="headerlink" href="#src_GUI.Main_windows_1.EmptyTab" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is  used to fill empty tabs with something during the developement.
It will not be use in the final version.</p>
<dl class="method">
<dt id="src_GUI.Main_windows_1.EmptyTab.addtext">
<code class="descname">addtext</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.EmptyTab.addtext" title="Permalink to this definition">¶</a></dt>
<dd><p>This function print a string on the command line. This is useful if you need to check if a button (or similar).
is connected.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.EmptyTab.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.EmptyTab.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initialization.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.Main_windows_1.MainWindows">
<em class="property">class </em><code class="descclassname">src_GUI.Main_windows_1.</code><code class="descname">MainWindows</code><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows" title="Permalink to this definition">¶</a></dt>
<dd><p>The class MainWindows contains the menu and the title of all the HABBY windows.
It also create all the widgets which can be called during execution</p>
<p><strong>Technical comments and walk-through</strong></p>
<p>First, we load the user setting using Qsettings: The settings by default of Qsettings are the name of the program (HABBY) and
the name of the organization which develops the program (irstea).  I have added three user settings (the name of the
last project loaded into HABBY, the path to this project and the language used). The Qsetting are stored in the
registry in Windows. Qsettings also function with Apple and Linux even if the information is stored differently</p>
<p>We set up the translation next. The translation of HABBY in different language is explained in more detail in
the section “Translation of HABBY”. We give here the path to the data related to the translation. More precisely, we indicate
here the path to the translation data and the name of the qm file containing the data related to the translation
in each language. If a new qm is added for a new language, it should be added here to the list.</p>
<p>Now, two important attributes are defined: self.name_prj and self.path_prj. These attribute will be communicated to
children classes. For each project, an xml file is created. This “project” file should be called name_prj.xml
and should be situated in the path indicated by self.path_prj.</p>
<p>We call the central_widget which contains the different tabs.</p>
<p>We create the menu of HABBY calling the function my menu_bar().</p>
<p>Two signal are connected, one to save the project (i.e to update the xml project file) and another to save an
ESTIMHAB calculation.</p>
<p>We show the created widget.</p>
<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.clear_log">
<code class="descname">clear_log</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.clear_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the log in the GUI.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.closeEvent">
<code class="descname">closeEvent</code><span class="sig-paren">(</span><em>event</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.closeEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the program better than before (where it used to crash about 1 times in ten). It is not really clear why.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>event</strong> &#8211; managed by the operating system.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.close_rech">
<code class="descname">close_rech</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.close_rech" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the additional research menu (see open_rech for more information)</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.do_log">
<code class="descname">do_log</code><span class="sig-paren">(</span><em>save_log</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.do_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Save or not save the log</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>save_log</strong> &#8211; an int which indicates if the log should be saved or not</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>0: do not save log</li>
<li>1: save the log in the .log file and restart file</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.erase_pict">
<code class="descname">erase_pict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.erase_pict" title="Permalink to this definition">¶</a></dt>
<dd><p>All files contained in the folder indicated by path_im will be deleted.</p>
<p>From the menu of HABBY, it is possible to ask to erase all files in the folder indicated by path_im
(usually figure_HABBY). Of course, this is a bit dangerous. So the function asks the user for confirmation.
However, it is practical because you do not have to go to the folder to erase all the images when there
are too many of them.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.init_ui">
<code class="descname">init_ui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.init_ui" title="Permalink to this definition">¶</a></dt>
<dd><p>Used by __init__() to create an instance of the class MainWindows</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.my_menu_bar">
<code class="descname">my_menu_bar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.my_menu_bar" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates the menu bar of HABBY.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.new_project">
<code class="descname">new_project</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.new_project" title="Permalink to this definition">¶</a></dt>
<dd><p>This function open a new empty project</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.open_project">
<code class="descname">open_project</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.open_project" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to open an existing habby project by selecting an xml project file. Called by
my_menu_bar()</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.open_rech">
<code class="descname">open_rech</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.open_rech" title="Permalink to this definition">¶</a></dt>
<dd><p>Open the additional research tab, which can be used to create Tab with more experimental contents.</p>
<p>Indeed, it is possible to show extra tab in HABBY. These supplementary tab correspond to open for researcher.
The plan is that these options are less tested than other mainstream options. It is not clear yet what
will be added to these options, but the basic architecture is there when it will be needed.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.save_project">
<code class="descname">save_project</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.save_project" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to save the xml file with the information on the project</p>
<p><strong>Technical comments</strong></p>
<p>This function saves or creates the xml file related to the projet. In this xml file, there are the path and
the name to all files related to the project, notably the hdf5 files containing the hydrological data.</p>
<p>To find or create the xml file, we use the attribute self.path_prj and self.name_proj. If the path to
the project directory is not found an error appears. The error is here sent though additional windows
(to be sure that the user notice this problem), using the Qmesssage module. The user should give the general
info about the project in the general tab of HABBY and they are collected here. User option (using Qsetting)
is next updated so that the user will find his project open the next time it opens HABBY.</p>
<p>When HABBY open, there are therefore  two choice: a) This is a new project b) the project exists already.
If the project is new, the xml file is created and general information is written in this file. In addition,
the text file which are necessary to log the action of HABBY are created now. This part of the reason why it
is not possible to run other part of HABBY (such as loading hydrological data) before a project is saved.
In addition, it would create a lot of problems on where to store the data created. Hence, a project is needed
before using HABBY. If the project exists already (i.e. the name and the path of the project have not been
modified), the xml file is just updated to change its attributes as needed.</p>
<p>Interesting path are a) the biology path (named &#8220;biology&#8221; by default) which contains the biological information
such as the preference curve and b) the path_im which is the path where all figures and most outputs of HABBY
is saved. If path_im is not given, HABBY automatically create a folder called figure_habby when the
user creates a new project. The user can however change this path if he wants. The next step is to communicate
to all the children widget than the name and path of the project have changed.</p>
<p>Finally the log is written (see “log and HABBY in the command line).</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.save_project_estimhab">
<code class="descname">save_project_estimhab</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.save_project_estimhab" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to save the information linked with Estimhab in an hdf5 file.</p>
<p><strong>Technical comments</strong></p>
<p>This function save the data and result from the estimhab calculation. It would look more logic if it was in
the esimhab.py script, but it was easier to call it from here instead of in the child class.</p>
<p>This function get all estimhab input, create an hdf5 file using h5py and save the data in the hdf5. One
specialty of hdf5 is that is cannot use Unicode. Hence all string have to be passed to ascii using the encode
function. The size of each data should also be known.</p>
<p>Finally, we save the name and path of the estimhab file in the xml project file.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.setlangue">
<code class="descname">setlangue</code><span class="sig-paren">(</span><em>nb_lang</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.setlangue" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which change the language of the programme. It change the menu and the central widget.
It uses the self.lang attribute which should be set to the new language before calling this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nb_lang</strong> &#8211; the number representing the language (int)</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>0 is for English</li>
<li>1 for French</li>
<li>n for any additionnal language</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.test_entry_float">
<code class="descname">test_entry_float</code><span class="sig-paren">(</span><em>var_in</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.test_entry_float" title="Permalink to this definition">¶</a></dt>
<dd><p>An utility function to test if var_in are float or not
the boolean self.does_it_work is used to know if the functions run until the end.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>var_in</strong> &#8211; the QlineEdit which contains the data (so var_in.text is a string)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the tested variable var_in</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.Main_windows_1.ShowImageW">
<em class="property">class </em><code class="descclassname">src_GUI.Main_windows_1.</code><code class="descname">ShowImageW</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.ShowImageW" title="Permalink to this definition">¶</a></dt>
<dd><p>The widget which shows the saved images. Used only to show all the saved figure together iwhtout zoom or other
options.</p>
<p><strong>Technical comments</strong></p>
<p>The ShowImageW() class is used to show all the figures created by HABBY. It is a class which can only be
called from the menu (In Option/Option Image). This is not the usual way of opening a figure which is usually done
by plt.show from matplotlib. This is the way to look at all figures  together, which can be useful, even if zooming
is not possible anymore.</p>
<p>To show all image, HABBY open a separate window and show the saved image in .png format.  Currently, the figures
shown are in .png, but other formats could be used. For this, one can change the variable self.imtype.</p>
<p>An important point for the ShowImageW  class  is where the images were saved by the functions which created them.
In HABBY, all figures are saved in the same folder called “path_im”. One “path_im” is chosen at the start of each
project. By default, it is the folder “Figure_Habby”, but the user can modify this folder in the window created by
ShowImageW(). The function for this is called “change_folder”, also in ShowImageW(). The path_im is written in
the xml project file. The different functions which create image read this path and send the figure created
to this folder. ShowImageW() reads all  figure of “.png” type in the” path_im” folder and show the most recent
figure. The user can use the drop-down menu to choose to see another figure. The names of the figure are added to
the drop-down menu in the function update_namefig. The function &#8220;selectionchange&#8221; changes the figure shown based
on the user action.</p>
<dl class="method">
<dt id="src_GUI.Main_windows_1.ShowImageW.change_folder">
<code class="descname">change_folder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.ShowImageW.change_folder" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to change the folder where are stored the image (i.e., the path_im)</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.ShowImageW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.ShowImageW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initialization.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.ShowImageW.selectionchange">
<code class="descname">selectionchange</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.ShowImageW.selectionchange" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to change the figure shown by ShowImageW()
:return:</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.Main_windows_1.ShowImageW.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.Main_windows_1.ShowImageW.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQt signal used to write the log</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.ShowImageW.update_namefig">
<code class="descname">update_namefig</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.ShowImageW.update_namefig" title="Permalink to this definition">¶</a></dt>
<dd><p>This function add the different figure name to the drop-down list.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.Main_windows_1.WelcomeW">
<em class="property">class </em><code class="descclassname">src_GUI.Main_windows_1.</code><code class="descname">WelcomeW</code><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW" title="Permalink to this definition">¶</a></dt>
<dd><p>The class WeLcomeW()  creates the first tab of HABBY (the tab called “General”). This tab is there to create
a new project or to change the name, path, etc. of a project.</p>
<dl class="method">
<dt id="src_GUI.Main_windows_1.WelcomeW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initialization of a new instance of the class WelcomeW()</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.Main_windows_1.WelcomeW.new_proj_signal">
<code class="descname">new_proj_signal</code><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW.new_proj_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQt signal used to open a new project</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.Main_windows_1.WelcomeW.save_signal">
<code class="descname">save_signal</code><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW.save_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQt signal used to save the project</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.Main_windows_1.WelcomeW.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQt signal used to write the log</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.WelcomeW.setfolder">
<code class="descname">setfolder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW.setfolder" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used by the user to select the folder where the xml project file will be located.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="hydrological-information-gui">
<h2>Hydrological information - GUI<a class="headerlink" href="#hydrological-information-gui" title="Permalink to this headline">¶</a></h2>
<p>in src_GUI/hydro_GUI_2.py</p>
<p>This python module contains the class which forms the hydrological tab in HABBY.
It contains the information for the graphical interface and make the link with the scripts
used for the hydrological calculations.</p>
<span class="target" id="module-src_GUI.hydro_GUI_2"></span><dl class="class">
<dt id="src_GUI.hydro_GUI_2.FreeSpace">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">FreeSpace</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.FreeSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">PyQt5.QtWidgets.QWidget</span></code></p>
<p>Simple class with empty space, just to have only Qwidget in the stack.</p>
<p><strong>Technical comment</strong></p>
<p>The idea of this class is that the user see a free space when it opens the “Hydro” Tab instead
of directly seeing one of the hydraulic model. The goal is to avoid the case where a user tries to load data before
selecting the real model. For example, if a user wants to load mascaret data and that an item is selected by
default in the stack of classes related to hydrology (such as HEC-RAS1D), it might be logical for the user to try
to load masacret data using the HEC-RAS class. Because of the FreeSpace class, he actually has to select
the model he wants to load.</p>
</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS1D">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">HEC_RAS1D</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class Hec_ras 1D is there to manage the link between the graphical interface and the functions in
src/hec_ras06.py which loads the hec-ras data in 1D. The class HEC_RAS1D inherits from SubHydroW() so it have all
the methods and the variables from the class ubHydroW(). The class hec-ras 1D is added to the self.stack of Hydro2W(). So the class Hec-Ras 1D is called when
the user is on the hydrological tab and click on hec-ras1D as hydrological model.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS1D.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS1D.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is called by __init__() durring the initialization.</p>
<p><strong>Technical comment</strong></p>
<p>The self.attributexml variable is the name of the attribute in the xml file. To load a hec-ras file, one needs
to give to HABBY one file containing the geometry data and one file containing the simulation result. The name
and path to  these two file are saved in the xml project file under the attribute given in
the self.attributexml variable.</p>
<p>The variable self.extension is a list of list of the accepted file type. The first list is for the file
with geometry data. The second list is the extension of the files containing the simulation results.</p>
<p>Using the function self.was_model_loaded_before, HABBY write the name of the hec-ras files which were loaded
in HABBY in the same project before.</p>
<p>Hec-Ras is a 1.5D model and so HABBY create a 2D grid based on the 1.5D input. The user can choose the interpolation
type and the number of extra profile. If the interpolation type is “interpolation by block”, the number of extra
profile will always be one. See manage_grid.py for more information on how to create a grid.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS1D.load_hec_ras_gui">
<code class="descname">load_hec_ras_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS1D.load_hec_ras_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to execute the loading and saving of the HEC-ras file using Hec_ras.py</p>
<p><strong>Technical comments</strong></p>
<p>This function is called when the user press on the button self.load_b. It is the function which really
calls the load function for hec_ras. First, it updates the xml project file. It adds the name of the new file
to xml project file under the attribute indicated by self.attributexml. It also gets the path_im by reading the
path_im in the xml project file. Then it check if the user want to create the figure or not
(if self.cb.isChecked(), figures should be created). It also manages the log as explained in the section
about the log. Notably, it redirects the  outstream to the mystdout stream. Hence, the “print” statement is
now sent to the log windows at the bottom of HABBY window. Next, it loads the hec-ras data as explained in
the section on hec_ras06.py. It then creates the grid as explained in the manage_grid.py based on the
interpolation type wished by the user (linear, nearest neighbor or by block). It creates the hdf5
with the loaded data. Finally, if necessary, it shows the figure by emitting a signal.
This signal is collected in the MainWindow() class.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS1D.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS1D.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>PyQtsignal to show the figure.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS2D">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">HEC_RAS2D</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class hec_RAS2D is there to manage the link between the graphical interface and the functions in src/hec_ras2D.py
which loads the hec_ras2D data in 2D. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW(). It is very similar to RUBAR2D class and it has the same problem about node/cell
which will need to be corrected.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS2D.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS2D.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is used to by __init__() during the initialization.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS2D.load_hec_2d_gui">
<code class="descname">load_hec_2d_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS2D.load_hec_2d_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls the function which load hecras 2d and save the names of file in the project file.
It is similar to the function to load_rubar2D.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS2D.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS2D.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>PyQtsignal to show the figures.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.Hydro2W">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">Hydro2W</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Hydro2W" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">PyQt5.QtWidgets.QWidget</span></code></p>
<p>The class Hydro2W is the second tab of HABBY. It is the class containing all the classes/Widgets which are used
to load the hydrological data.</p>
<p>List of model supported by Hydro2W:
files separetly. However, sometime the file was not found
*   Telemac (2D)
*   Hec-Ras (1.5D et 2D)
*   Rubar BE et 2(1D et 2D)
*   Mascaret (1D)
*   River2D (2D)</p>
<p><strong>Technical comments</strong></p>
<p>To call the different classes used to load the hydrological data, the user selects the name of the hydrological
model from a QComboBox call self.mod. The method ‘selection_change” calls the class that the user chooses in
self.mod. All the classes used to load the
hydrological data are created when HABBY starts and are kept in a stack called self.stack. The function
selection_change() just changes the selected item of the stack based on the user choice on self.mod.</p>
<p>Any new hydrological model should also be added to the stack and to the list of models contained in self.mod
(name of the list: self.name_model).</p>
<p>In addition to the stack containing the hydrological information, hydro2W has two buttons. One button open
a QMessageBox() which give information about the models, using the method “give_info_model”.  It is useful if a
special type of file is needed to load the data from a model or to give extra information about one hydrological
model. The text which is shown on the QMessageBox is given in one text file for each model.
These text file are contained in the folder ‘model_hydro” which is in the HABBY folder. For the moment,
there are models for which no text files have been prepared. The text file should have the following format:</p>
<ul class="simple">
<li>A short sentence with general info</li>
<li>The keyword:  MORE INFO</li>
<li>All other infomation which are needed.</li>
</ul>
<p>The second button allows the user to load an hdf5 file containing hydrological data from another project.
As long as the hdf5 is in the right format, it does not matter from which hydrological model it was loaded from
or even if this hydrological model is supported by HABBY.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Hydro2W.get_new_hydro_hdf5">
<code class="descname">get_new_hydro_hdf5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Hydro2W.get_new_hydro_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function which allows the user to select an hdf5 file containing the hydrological
data from a previous project and add it to the current project. It modifies the xml project file and test
that the data is in correct form by loading it. The hdf5 should have the same form than the hydrological data
created by HABBY in the method save_hdf5 of the class SubHydroW.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Hydro2W.give_info_model">
<code class="descname">give_info_model</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Hydro2W.give_info_model" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to show extra information about each hydrological model.
The information should be in a text file with the same name as the model in the model_hydo folder.
General info goes as the start of the text file. If the text is too long, add the keyword &#8220;MORE INFO&#8221;
and add the longer text afterwards. The message box will show the supplementary information only if the user
asks for detailed information.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Hydro2W.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Hydro2W.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initialization by __init__()</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Hydro2W.selectionchange">
<code class="descname">selectionchange</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Hydro2W.selectionchange" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the shown widget which represents each hydrological model (all widget are in a stack)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>i</strong> &#8211; the number of the model (0=no model, 1=hecras1d, 2= hecras2D,...)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.Hydro2W.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.Hydro2W.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQt signal to send the log.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.Mascaret">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">Mascaret</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Mascaret" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class Mascaret is there to manage the link between the graphical interface and the functions in src/mascaret.py
which loads the Masacret data in 1D. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW(). It is similar to the HEC-Ras1D class (see this class for more information). However, mascaret is 1D model, so the loading
of mascaret has one additional step compared to the hec-ras load: The velocity must be distributed along the
profile. For this, the load_masacret_gui call the self.distrbute _velocity function. In addition, it prepares
the manning value which is necessary to distribute the velocity. The user has two choices to input the manning
value. The easiest one is just to give a value constant for the whole river. In the second choice, the user loads
a text file with a serie of lines with the following info: p, dist, n where p is the profile number
(starting at zero), dist is the distance in meter along the profile and n in the manning value (see the method
load_manning_text of the class SubHydroW for more information)</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Mascaret.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Mascaret.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initialization by __init__()</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Mascaret.load_mascaret_gui">
<code class="descname">load_mascaret_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Mascaret.load_mascaret_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>The function is used to load the mascaret data, calling the function contained in the script mascaret.py</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.Mascaret.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.Mascaret.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal to show the figure.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.River2D">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">River2D</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class River2D t is there to manage the link between the graphical interface and the functions in src/river2D.py
which loads the River2D data in 2D.</p>
<p><strong>Technical comments</strong></p>
<blockquote>
<div><p>The class River2D inherits from SubHydroW() so it have all the methods and the variables from the class SubHydroW().
It is similar generally to the hec-ras2D class. However, the hydrological model River2D create one file per time step.
Hence, it is necessary to have a way to load all the files automatically. Loading one file after one file would be
annoying. There are four functions to manage the large number of file:</p>
<ul class="simple">
<li>add_all_file: find all files in a folder selected by the user.</li>
<li>add_file_river2D: add just one selected file</li>
<li>Remove_all_file: remove all selected files</li>
<li>Remove_file: remove one selected file</li>
</ul>
<p>None of this four functions load the data, it just add the name and path of the files to be loaded to
self.namefile and self.pathfile. Generally, in HABBY, we load hydrological data in two steps: a) select the files,
b) load the data. For river2D, the step b) is done by the function load_river2d_gui().
This function is similar to the one used by Rubar2D. It has the same problem about the grid which
is identical for all time steps and which contains all reaches together. So a temporary correction was applied.
Data in River2D is given on the nodes as in HABBY.</p>
</div></blockquote>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.add_all_file">
<code class="descname">add_all_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.add_all_file" title="Permalink to this definition">¶</a></dt>
<dd><p>The function finds all .cdg file in one directory to add there names to the list of files to be loaded</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.add_file_river2d">
<code class="descname">add_file_river2d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.add_file_river2d" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to add one file to the list of file to be loaded.
It calls show_dialog, prepare some data for it and update the QWidgetList with
the name of the file containted in the variable self.namefile.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.add_file_to_list">
<code class="descname">add_file_to_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.add_file_to_list" title="Permalink to this definition">¶</a></dt>
<dd><p>This function to add all file contained in self.namefile to the QWidgetlist. Called by add_file_river2D and
add_all_file.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>used by __init__ in the initialization</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.load_river2d_gui">
<code class="descname">load_river2d_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.load_river2d_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to load the river 2d data.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.remove_all_file">
<code class="descname">remove_all_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.remove_all_file" title="Permalink to this definition">¶</a></dt>
<dd><p>This function removes all files from the list of files to be loaded and from the QlistWidget.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.remove_file">
<code class="descname">remove_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.remove_file" title="Permalink to this definition">¶</a></dt>
<dd><p>This is small function to remove a .cdg file from the list of files to be loaded and from the QlistWidget.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.River2D.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal to show the figure.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.Rubar1D">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">Rubar1D</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class Rubar1D is there to manage the link between the graphical interface and the functions in src/rubar.py
which loads the Rubar1D data in 1D. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW(). It is very similar to Mascaret class.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Rubar1D.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar1D.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initalizatin by __init__()</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Rubar1D.load_rubar1d">
<code class="descname">load_rubar1d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar1D.load_rubar1d" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to execute the loading and saving the the rubar file using rubar.py. After loading the data,
it distribute the velocity along the profiles by calling self.distribute_velocity() and it created the 2D grid
by calling the method self.grid_and_interpo.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.Rubar1D.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar1D.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal to show the figures.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.Rubar2D">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">Rubar2D</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class Rubar2D is there to manage the link between the graphical interface and the functions in src/rubar.py
which loads the RUBAR data in 2D. It inherits from SubHydroW() so it have all the methods and the variables from
the class SubHydroW(). The form of the function is similar to hec-ras, but it does not have the part about the grid
creation as we look here as the data created in 2D by RUBAR.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Rubar2D.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar2D.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>used by ___init__() in the initialization.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Rubar2D.load_rubar">
<code class="descname">load_rubar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar2D.load_rubar" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to execture the loading and saving the the rubar file using rubar.py. It is similar to the
load_hec_ras_gui() function. Obviously, it calls rubar and not hec_ras this time. A small difference is that
the rubar2D outputs are only given in one grid for all time steps and all reaches. Moreover, it will be
necessary to cut the grid for each time step as a function of the wetted area and maybe to separate the
grid by reaches. This have not be done yet.</p>
<p>Another problem is that the data of Rubar2D is given on the cells of the grid and not the nodes.
This will need to be corrected as data in HABBY is centered on the node.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Rubar2D.propose_next_file">
<code class="descname">propose_next_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar2D.propose_next_file" title="Permalink to this definition">¶</a></dt>
<dd><p>This function proposes the second RUBAR file when the first is selected.  Indeed, to load rubar, we need
one file with the geometry data and one file with the simulation results. If the user selects a file, this
function looks if a file with the same name but with the extension of the other file type exists in the
selected folder. This could be done for all hydrological models, but the function is harder
to write when more than one extension is possible, so it has not been done yet.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.Rubar2D.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar2D.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal to show the figure.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.SubHydroW">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">SubHydroW</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">PyQt5.QtWidgets.QWidget</span></code></p>
<p>SubHydroW is class which is the parent of the classes which can be used to open the hydrological models. This class
is a bit special. It is not called directly by HABBY but by the classes which load the hydrological data and which
inherits from this class. The advantage of this architecture is that all the children classes can use the methods
written in SubHydroW(). Indeed, all the children classes load hydrological data and therefore they are similar and can use
similar functions.</p>
<p>In other word, there are MainWindows() which provides the windows around the widget and Hydro2W which provide the widget for the
hydrological Tab and one class by hydrological model to really load the model. The latter classes have various
methods in common, so they inherit from SubHydroW, this class.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.distribute_velocity">
<code class="descname">distribute_velocity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.distribute_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>This function make the link between the GUI and the functions of dist_vitesse2. It is used by 1D model,
notably rubar and masacret.</p>
<p>Dist vitess needs a manning parameters. It can be given by the user in two forms: a constant (float) or an array
created by the function load_manning_text.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.drop_hydro">
<code class="descname">drop_hydro</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.drop_hydro" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal signal for the substrate tab so it can account for the new hydrological info.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.find_path_im">
<code class="descname">find_path_im</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.find_path_im" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to find the path where to save the figues, careful a simialr one is in estimhab_GUI.py. By default,
path_im is in a folder calls &#8220;Figure_Habby&#8221;.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.grid_and_interpo">
<code class="descname">grid_and_interpo</code><span class="sig-paren">(</span><em>cb_im</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.grid_and_interpo" title="Permalink to this definition">¶</a></dt>
<dd><p>This function forms the link between GUI and the various grid and interpolation functions. Is called by
the &#8220;loading&#8217; function of hec-ras 1D, Mascaret and Rubar BE.
:param cb_im: A boolean if true, the figures are created and shown.</p>
<p><em>Technical comment to be added</em></p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.load_manning_text">
<code class="descname">load_manning_text</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.load_manning_text" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the manning data in case where manning number is not simply a constant. In this case, the manning
parameter is given in a .txt file.
The manning parameter used by 1D model such as mascaret or Rubar BE to distribute velocity along the profiles.
The format of the txt file is &#8220;p, dist, n&#8221; where  p is the profile number (start at zero), dist is the distance
along the profile in meter and n is the manning value (in SI unit). One point per line so something like:</p>
<p>0, 150, 0.035</p>
<p>0, 200, 0.025</p>
<p>1, 120, 0.035, etc.</p>
<p>White space is neglected and a line starting with the character # is also neglected.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.read_attribute_xml">
<code class="descname">read_attribute_xml</code><span class="sig-paren">(</span><em>att_here</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.read_attribute_xml" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to read the text of an attribute in the xml project file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>att_here</strong> &#8211; the attribute name (string).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.save_hdf5">
<code class="descname">save_hdf5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.save_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>This function save the hydrological data in the hdf5 format.</p>
<p><strong>Technical comments</strong></p>
<p>This function cannot be used outside of the class, so it needs to be re-written if used from the command line.</p>
<p>This function creates an hdf5 file which contains the hydrological data. First it creates an empty hdf5.
Then it fill the hdf5 with data. For 1D model, it fill the data in 1D (the original data), then the 1.5D data
created by dist_vitess2.py and finally the 2D data. For model in 2D it only saved 2D data. Hence, the 2D data
is the data which is common to all model and which can always be loaded from a hydrological hdf5 created by
HABBY. The 1D and 1.5D data is only present if the model is 1D or 1.5D. Here is some general info about the
created hdf5:</p>
<ul class="simple">
<li>Name of the file: name_projet  +  ’_’ +  name model + date/time.h5.  For example, test4_HEC-RAS_25_10_2016_12_23_23.h5.</li>
<li>Position of the file: in the folder  figure_habby currently (probably in a project folder in the final software)</li>
<li>Format of the hdf5 file:<ul>
<li>Dats_gen:  number of time step and number of reach</li>
<li>Data_1D:  xhzv_data_all (given profile by profile)</li>
<li>Data_15D :  vh_pro, coord_pro (given profile by profile in a dict) and nb_pro_reach.</li>
<li>Data_2D : For each time step, for each reach: ikle, point, point_c, inter_h, inter_vel</li>
</ul>
</li>
</ul>
<p>If a list has elements with a changing number of variables, it is necessary to create a dictionary to save
this list in hdf5. For example, a dictionary will be needed to save the following list: [[1,2,3,4], [1,2,3]].
This is used for example, to save data by profile as we can have profile with more or less points. We also note
in the hdf5 attribute some important info such as the project name, path to the project, hdf5 version.
This can be useful if an hdf5 is lost and is not linked with any project. We also add the name of the created
hdf5 to the xml project file. Now we can load the hydrological data using this hdf5 file and the xml project file.</p>
<p>Hdf5 file do not support unicode. It is necessary to encode string to write them in ascii.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.save_xml">
<code class="descname">save_xml</code><span class="sig-paren">(</span><em>i=0</em>, <em>append_name=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.save_xml" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to save the loaded data in the xml file.</p>
<p>This function adds the name and the path of the newly chosen hydrological data to the xml project file. First,
it open the xml project file (and send an error if the project is not saved, or if it cannot find the project
file). Then, it opens the xml file and add the path and name of the file to this xml file. If the model data was
already loaded, it adds the new name without erasing the old name IF the switch append_name is True. Otherwise,
it erase the old name and replace it by a new name. The variable “i” has the same role than in show_dialog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i</strong> &#8211; a int for the case where there is more than one file to load</li>
<li><strong>append_name</strong> &#8211; A boolean. If True, the name found will be append to the existing name in the xml file,
instead of remplacing the old name by the new name.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.send_err_log">
<code class="descname">send_err_log</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.send_err_log" title="Permalink to this definition">¶</a></dt>
<dd><p>This function sends the errors and the warnings to the logs.
The stdout was redirected to self.mystdout.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A Pyqtsignal to write the log.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.show_dialog">
<code class="descname">show_dialog</code><span class="sig-paren">(</span><em>i=0</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.show_dialog" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to obtain the name of the file chosen by the user. This method open a dialog so that the user select
a file. This file is NOT loaded here. The name and path to this file is saved in an attribute. This attribute
is then used to loaded the file in other function, which are different for each children class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>i</strong> &#8211; a int for the case where there is more than one file to load</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.was_model_loaded_before">
<code class="descname">was_model_loaded_before</code><span class="sig-paren">(</span><em>i=0</em>, <em>many_file=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.was_model_loaded_before" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to test if the model loaded before. If yes, it updates the attibutes anf the widgets of the
hydrological model on consideration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i</strong> &#8211; an int used in cases where there is more than one file to load (geometry and output for example)</li>
<li><strong>many_file</strong> &#8211; A bollean. If true this function will load more than one file, separated by &#8216;,&#8217;. If False,
it will only loads the file of one model (see the comment below).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comment</strong></p>
<p>This method opens the xml project file and look in the attribute of the xml file to see if data from the
hydrological model have been loaded before. If yes, the name of the data is written on the GUI of HABBY in the
Widget related to the hydrological model. Now, there are often more than one data loaded. This method allows
choosing what should be written. There are two different case to be separated: a) We have loaded two different
models (like two rivers modeled by HEC-RAS) b) One model type needs two data file (like HEC-RAS would need a
geometry and output data). For the case a), the default is to write only the first model loaded. If we wish to
write all data, the switch “many_file” should be True. This switch is also useful for the river2D model, because
this model create one output file per time step. For the case b), the argument “i”(which is an int) allows us to
choose which data type should be shown. “i” is in the order of the self.attributexml variable. The definition of
this order is given in the definition of the class of each hydrological model.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.SubstrateW">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">SubstrateW</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>This is the widget used to load the substrate. It is practical to re-use some of the method from SubHydroW.
So this class inherit from SubHydroW.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.get_att_name">
<code class="descname">get_att_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.get_att_name" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to get the attribute name of the shapefile which contains the substrate data. it is given by the user
in the GUI.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initialization by __init__().</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.load_sub_gui">
<code class="descname">load_sub_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.load_sub_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to load the substrate data. The substrate data can be in two forms: a) in the form of a shp
file form ArGIS (or another GIS-program). b) in the form of a text file (x,y, substrate data line by line).
Generally this function has some similarities to the functions used to load the hydrological data and it re-uses
some of the methods developed for them.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.log_txt">
<code class="descname">log_txt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.log_txt" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gives the log for the substrate in text form. this is in a function because it is used twice in
the function load_sub_gui()</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.save_hdf5_sub">
<code class="descname">save_hdf5_sub</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.save_hdf5_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>This function save the substrate data in its own hdf5 file and write the name of this hdf5 file in the
xml project file. The format of the hdf5 file is not finalzed yet so it is not documented.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.send_merge_grid">
<code class="descname">send_merge_grid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.send_merge_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls the function merge grid in substrate.py. The goal is to have the substrate and hydrological
data on the same grid. Hence, the hydrological grid will need to be cut to the form of the substrate grid.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal to show the figures.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.update_hydro_hdf5_name">
<code class="descname">update_hydro_hdf5_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.update_hydro_hdf5_name" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a short function used to read all the hydrological data contained in an hdf5 files and available in
one project. When these files are read, they are added to the drop-down menu;
This should be a function because an update to this list can be triggered by the loading of a new hydrological
data. The class SubstrateW() noticed this through the signal drop_hydro send by the hydrological class.
The signal drop_hydro is connected to this function in the class CentralW in MainWindows.py. Indeed, it is not
possible to do it in SubstrateW().</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.TELEMAC">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">TELEMAC</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.TELEMAC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class Telemac is there to manage the link between the graphical interface and the functions in src/selafin_habby1.py
which loads the Telemac data in 2D. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW(). It is very similar to RUBAR2D class, but data from Telemac is on the node as in HABBY.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.TELEMAC.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.TELEMAC.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used by __init__() during the initialization.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.TELEMAC.load_telemac_gui">
<code class="descname">load_telemac_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.TELEMAC.load_telemac_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>The function which call the function which load telemac and save the name of files in the project file</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.TELEMAC.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.TELEMAC.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal to show the figure.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="figure-option-gui">
<h2>Figure Option - GUI<a class="headerlink" href="#figure-option-gui" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>in src_GUI/output_fig_GUI.py</p>
<p>This part is not finished. The idea is to let the user select various options to create
the figures, notably the colour or the size of the text.</p>
</div></blockquote>
<span class="target" id="module-src_GUI.output_fig_GUI"></span><dl class="function">
<dt id="src_GUI.output_fig_GUI.create_default_figoption">
<code class="descclassname">src_GUI.output_fig_GUI.</code><code class="descname">create_default_figoption</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.output_fig_GUI.create_default_figoption" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates the default dictionnary of option for the figure.</p>
</dd></dl>

<dl class="function">
<dt id="src_GUI.output_fig_GUI.load_fig_option">
<code class="descclassname">src_GUI.output_fig_GUI.</code><code class="descname">load_fig_option</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.output_fig_GUI.load_fig_option" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the figure option saved in the xml file and create a dictionnary will be given to the functions
which create the figures to know the different options chosen by the user. If the options are not written, this
function uses data by default which are in the fonction create_default_fig_options().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path_prj</strong> &#8211; the path to the xml project file</li>
<li><strong>name_prj</strong> &#8211; the name to this file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the dictionary containing the figure options</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="src_GUI.output_fig_GUI.outputW">
<em class="property">class </em><code class="descclassname">src_GUI.output_fig_GUI.</code><code class="descname">outputW</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.output_fig_GUI.outputW" title="Permalink to this definition">¶</a></dt>
<dd><p>The class which support the creation and management of the output. It is notably used to select the otions to
create the figures.</p>
<dl class="method">
<dt id="src_GUI.output_fig_GUI.outputW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.output_fig_GUI.outputW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="src_GUI.output_fig_GUI.outputW.save_option_fig">
<code class="descname">save_option_fig</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.output_fig_GUI.outputW.save_option_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which save the options for the figures in the xlm project file. The options for the figures are
contained in a dictionnary. The idea is to give this dictinnory in argument to all the fonction which create
figures. In the xml project file, the options for the figures are saved under the attribute &#8220;Figure_Option&#8221;.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.output_fig_GUI.outputW.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.output_fig_GUI.outputW.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal used to write the log.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-src_GUI.stathab_GUI">
<span id="the-stathab-model-gui"></span><h2>The Stathab model - GUI<a class="headerlink" href="#module-src_GUI.stathab_GUI" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="src_GUI.stathab_GUI.StathabW">
<em class="property">class </em><code class="descclassname">src_GUI.stathab_GUI.</code><code class="descname">StathabW</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW" title="Permalink to this definition">¶</a></dt>
<dd><p>The class to load and manage the widget controlling the Stathab model.</p>
<p><strong>Technical comments</strong></p>
<p>The class StathabW makes the link between the data prepared by the user for Stathab and  the Stathab model
which is in the src folder (stathab_c.py) using the graphical interface.  Most of the Stathab input are given in
form of text file. For more info on the preparation of text files for stathab, read the document called
&#8216;stathabinfo.pdf&#8221;.  To use Stathab in HABBY, all Stathab input should be in the same directory. The user select
this directory (using the button “loadb”) and HABBY tries to find the file it needs. All found files are added to
the list called “file found”. If file are missing, they are added to the “file still needed” list.  The user can then
select the fishes on which it wants to run stathab, then it run it by pressing on the “runb” button.</p>
<p>If file where loaded before by the user in the same project, StathabW looks for them and load them again. Here we
can have two cases: a) the data was saved in hdf5 format (as it is done when a stathab run was done) and the path
to this file noted in the xml project file. b) Only the name of the directory was written in the xml project file,
indicated that data was loaded but not saved in hdf5 yet. HABBY manages both cases.</p>
<p>Next, we check in the xml project file where the folder to save the figure (path_im) is. In case, there are
no path_im saved, Stathab create one folder to save the figure outputs. This should not be the usual case. Generally,
path_im is created with the xml project file, but you cannot be sure.</p>
<p>There is a list of error message which are there for the case where the data which was loaded before do not exist
anymore. For example, somebody erased the directory with the Stathab data in the meantime.  In this case,
a pop-up message open and warn the user.</p>
<p>An important attribute of StathabW() is self.mystathab. This is an object fo the stahab class. The stathab model,
which is in the form of a class and not a function, will be run on this object.</p>
<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.add_all_fish">
<code class="descname">add_all_fish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.add_all_fish" title="Permalink to this definition">¶</a></dt>
<dd><p>This function add the name of all known fish (the ones in Pref.txt) to the QListWidget.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.add_fish">
<code class="descname">add_fish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.add_fish" title="Permalink to this definition">¶</a></dt>
<dd><p>This function add the name of one fish species to the selected list of fish species.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.load_from_hdf5_gui">
<code class="descname">load_from_hdf5_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.load_from_hdf5_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls from the GUI the load_stathab_from_hdf5 function. In addition to call the function to load
the hdf5, it also updates the GUI according to the info contained in the hdf5.</p>
<p><strong>Technical comments</strong></p>
<p>This functino updates the Qlabel similarly to the function “load_from_txt_gui()”.
It also loads the data calling the load_stathab_from_hdf5 function from the Stathab class in src. The info
contains in the hdf5 file are now in the memory in various variables called self.mystathab.”something”.
HABBY used them to update the GUI. First, it updates the list which contains the name of the reaches
(self.list_re.). Next, it checks that each of the variable needed exists and that they contain some data.
Afterwards, HABBY looks which preference file to use. Either, it will use the default preference file
(contained in HABBY/biology) or a custom preference prepared by the user. This custom preference
file should be in the same folder than the hdf5 file. When the preference file was found, HABBY reads all
the fish type which are described and add their name to the self.list_f list which show the available fish
to the user in the GUI. Finally it checks if all the variables were found or if some were missing</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.load_from_txt_gui">
<code class="descname">load_from_txt_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.load_from_txt_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>The main roles of load_from_text_gui() are to call the load_function of the stathab class (which is in
stathab_c.py in the folder src) and to call the function which create an hdf5 file. However, it does some
modifications to the GUI before.</p>
<p><strong>Technical comments</strong></p>
<p>Here is the list of the modifications done to the graphical user interface before calling the load_function of
Stathab.</p>
<p>First, it updates the label. Because a new directory was selected, we need to update the label containing the
directory’s name. We only show the 30 last character of the directory name. In addition, we also need to update
the other label. Indeed, it is possible that the data used by Stathab would be loaded from an hdf5 file.
In this case, the labels on the top of the list of file are slightly modified. Here, we insure that we are in
the “text” version since we will load the data from text file.</p>
<p>Next, it gets the name of all the reach and adds them to the list of reach name. For this, it calls a function
from the stathab class (in src). Then, it looks which files are present and add them to the list which contains
the reach name called self.list_re.</p>
<p>Afterwards, it checks if the files needed by Stathab are here. The list of file is given in the
self.end_file_reach list. The form of the file is always the name of the reach + one item of
self.end_file_reach. If it does not find all files, it add the name of the files not found to self.list_needed,
so that the user can be aware of which file he needs. The exception is Pref.txt. If HABBY do not find it in the
directory, it uses the default “Pref.txt”. All files (apart from Pref.txt) should be in the same directory.</p>
<p>Then, it calls a method of the Stathab class (in src) which reads the “pref.txt” file and adds the name
of the fish to the GUI. Next, if all files are present, it loads the data using the method written in Stathab
(in the src folder). When the data is loaded, it creates an hdf5 file from this data and save the name of this
new hdf5 file in the xml project file (also using a method in the stathab class).</p>
<p>Finally, it sends the log info as explained in the log section of the documentation</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.reach_selected">
<code class="descname">reach_selected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.reach_selected" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which indcates which files are linked with which reach.</p>
<p><strong>Technical comment</strong></p>
<p>This is a small function which only impacts the GUI. When a Stathab model has more than one reach,
the user can click on the name of the reach. When he does this, HABBY selects the first file linked
with this reach and shows it in self.list_f. This first file is highlighted and the list is scrolled
down so that the files linked with the selected reach are shown. This function manages this. It is connected
with the list self.list_re, which is the list with the name of the reaches.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.remove_fish">
<code class="descname">remove_fish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.remove_fish" title="Permalink to this definition">¶</a></dt>
<dd><p>This function remove the name of one fish species to the selected list of fish species.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.run_stathab_gui">
<code class="descname">run_stathab_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.run_stathab_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the function which calls the function to run the Stathab model.  First it read the list called
self.list_s. This is the list with the fishes selected by the user. Then, it calls the function to run
stathab and the one to create the figure if the figures were asked by the user. Finally, it writes the log.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.select_dir">
<code class="descname">select_dir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.select_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to select the directory and find the files to laod stathab from txt files. It calls
load_from_txt_gui() when done.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.select_hdf5">
<code class="descname">select_hdf5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.select_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>This function allows the user to choose an hsdf5 file as input from Stathab.</p>
<p><strong>Technical comment</strong></p>
<p>This function is for example useful if the user would have created an hdf5 file for a Stathab model in another
project and he would like to send the same model on other fish species.</p>
<p>This function writes the name of the new hdf5 file in the xml project file. It also notes that the last data
loaded was of hdf5 type. This is useful when HABBY is restarting because it is possible to have a
directory name and the address of an hdf5 file in the part of the xml project file concerning Stathab.
HABBY should know if the last file loaded was this hdf5 or the files in the directory.
Finally, it calls the function to load the hdf5 called load_from_hdf5_gui.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.send_err_log">
<code class="descname">send_err_log</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.send_err_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Send the errors and warnings to the logs. It is useful to note that the stdout was redirected to self.mystdout.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.stathab_GUI.StathabW.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal used to write the log.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.stathab_GUI.StathabW.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal used to show the figures.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="estimhab-gui">
<h2>Estimhab - GUI<a class="headerlink" href="#estimhab-gui" title="Permalink to this headline">¶</a></h2>
<p>in src_GUI/estimhab_GUI.py</p>
<span class="target" id="module-src_GUI.estimhab_GUI"></span><dl class="class">
<dt id="src_GUI.estimhab_GUI.EstimhabW">
<em class="property">class </em><code class="descclassname">src_GUI.estimhab_GUI.</code><code class="descname">EstimhabW</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW" title="Permalink to this definition">¶</a></dt>
<dd><p>The Estimhab class provides the graphical interface for the version of the Estimhab model written in HABBY.
The Estimhab model is described elsewhere. EstimhabW() just loads the data for Estimhab given by the user.</p>
<dl class="method">
<dt id="src_GUI.estimhab_GUI.EstimhabW.add_fish">
<code class="descname">add_fish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.add_fish" title="Permalink to this definition">¶</a></dt>
<dd><p>The function is used to select a new fish species</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.EstimhabW.change_folder">
<code class="descname">change_folder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.change_folder" title="Permalink to this definition">¶</a></dt>
<dd><p>A small method to change the folder which indicates where is the biological data</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.EstimhabW.find_path_im_est">
<code class="descname">find_path_im_est</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.find_path_im_est" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to find the path where to save the figues. Careful there is similar function in hydro_GUI_2.py.
Do not mix it up</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">path_im a string which indicates the path to the folder where are save the images.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.EstimhabW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to initialized an instance of the EstimhabW() class. It is called be __init__().</p>
<blockquote>
<div><p><strong>Technical comments and walk-through</strong></p>
<p>First we looked if some data for Estimhab was saved before by an user. If yes, we will fill the GUI with
the information saved before. Estimhab information is saved in hdf5 file format and the path/name of the
hdf5 file is saved in the xml project file. So we open the xml project file and look if the name of an hdf5
file was saved for Estimhab. If yes, the hdf5 file is read.</p>
<p>The format of hdf5 file is relatively simple. Each input data for Estimhab has its own dataset (qmes, hmes,
wmes, q50, qrange, and substrate).  Then, we a list of string which are a code for the fish species which
were analyzed.  All the data contained in hdf5 file is loaded into variable.</p>
<p>The different label are written on the graphical interface. Then, two QListWidget are modified. The first
list contains all the fish species on which HABBY has info (see XML Estimhab format for more info).
The second list is the fish selected by the user on which Estimhab will be run. Here, we link these lists
with two functions so that the user can select/deselect fish using the mouse. The function name are add_fish()
and remove_fish().</p>
<p>Then, we fill the first list. HABBY look up all file of xml type in the “Path_bio” folder (the one indicated in
the xml project file under the attribute “Path_bio”).  The name are them modified so that the only the name of
species appears (and not the full path). We set the layout with all the different QLineEdit where the user
can write the needed data.</p>
<p>Estimhab model is saved using a function situated in MainWindows_1.py  (frankly, I am not so sure why I did put
the save function there, but anyway). So the save button just send a signal to MainWindows
here, which save the data.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.EstimhabW.remove_fish">
<code class="descname">remove_fish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.remove_fish" title="Permalink to this definition">¶</a></dt>
<dd><p>The function is used to remove fish species</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.EstimhabW.run_estmihab">
<code class="descname">run_estmihab</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.run_estmihab" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to execute Estimhab by calling the estimhab function.</p>
<p><strong>Technical comment</strong></p>
<p>This is the function making the link between the GUI and the source code proper. The source code for Estimhab
is in src/Estimhab.py.</p>
<p>This function loads in memory the data given in the graphical interface and call sthe Estimhab model.
The data could be written by the user now or it could be data which was saved in the hdf5 file before and
loaded when HABBY was open (and the init function called).  We check that all necessary data is present and
that the data given makes sense (e.g.,the minimum discharge should not be bigger than the maximal discharge,
the data should be a float, etc.). We then remove the duplicate fish species (in case the user select one
specie twice) and the Estimhab model is called. The log is then written (see the paragraph on the log for more
information). Next, the figures created by Estimmhab are shown. As there is only a short number of outputs
for Estimhab, we create a figure in all cases (it could be changed by adding a checkbox on the GUI like
in the Telemac or other hydrological class).</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.estimhab_GUI.EstimhabW.save_signal_estimhab">
<code class="descname">save_signal_estimhab</code><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.save_signal_estimhab" title="Permalink to this definition">¶</a></dt>
<dd><p>PyQtsignal to save the Estimhab data.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.estimhab_GUI.EstimhabW.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>PyQtsignal to write the log.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.estimhab_GUI.EstimhabW.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>PyQtsignal to show the figures.</p>
</dd></dl>

</dd></dl>

<div class="section" id="biological-data-estimhab">
<h3>Biological data - Estimhab<a class="headerlink" href="#biological-data-estimhab" title="Permalink to this headline">¶</a></h3>
<p>The biological data, i.e., the preference curves of Estimhab, are saved in xml files
situated in the folder given by the path written in the xml project file under the
attribute Path_bio. By default, it is HABBY/biology. It is possible to change this folder
using the GUI.</p>
<p>Estimhab is a statistical model, which functions using mathematical regressions.
The different regressions (or preference curve) of each fish are described in an xml file
whose format is given here.</p>
<p>Conceptually, the regressions R are of two types:</p>
<ul class="simple">
<li>Type 0          R = C * Q^{m1} * exp(m2*Q)</li>
<li>Type 1          R = C * (1+m1*exp(m2*Q))</li>
</ul>
<p>Where Q is the discharge, m1 and m2 are coefficients which depend on the fish type, and C is a
constant which depends on the stream characteristic and the fish type.</p>
<p>The constant C is of the form C = a + sum ai * ln(Si) where a and ai are coefficients which depend on
the fish type. Si are particular stream characteristics. Which characteristics should be used is a
function of the fish type and is so given in the xml file. The value of S i is a function of the stream
and is calculated by the program.</p>
<p>In the xml file,</p>
<ul class="simple">
<li>Attribute coeff_q: Give the main coefficients of the regression (m1 and m2)</li>
<li>Attribute func_q : Give the type of regression R used.  Type 0 and type 1, as described above, are known by HABBY.</li>
<li>Attribute coeff_const: Give the coefficient used to construct the constant C (a, a1, a2, a3,…). The number of coefficient differs for each fish, but should be at least one.</li>
<li>Attribute var_const: Give which type of stream characteristics is used. This is not the value of the particular characteristic, but only which type is used. The following list of type is accepted:<ul>
<li>0 for Q50, natural median discharge</li>
<li>1 for H50, the height of the stream at q50</li>
<li>2 for L50, the width of the stream at q50</li>
<li>3 for V50, the velocity of the stream at q50</li>
<li>4 for Re50, the discharge divided by 10 times the width at Q50</li>
<li>5 for Fr50, the Froude number at Q50</li>
<li>6 for Dh50, the mean substrate height divided by h50</li>
<li>7 for Exp(Dh50). Erase the log() of this particular term of the constant</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="section" id="calculation-of-fish-s-habitat">
<h1>Calculation of fish&#8217;s habitat<a class="headerlink" href="#calculation-of-fish-s-habitat" title="Permalink to this headline">¶</a></h1>
<p>The src folder contains the python module which are not linked with the graphical user interface.</p>
<span class="target" id="module-src"></span><div class="section" id="hec-ras-model-1d">
<h2>Hec-ras model 1D<a class="headerlink" href="#hec-ras-model-1d" title="Permalink to this headline">¶</a></h2>
<p>in src/Hec_ras06.py</p>
<p>This module contains the functions used to load the outputs from the hec-ras model in 1.5D.</p>
<span class="target" id="module-src.Hec_ras06"></span><dl class="function">
<dt id="src.Hec_ras06.coord_profile_non_georeferenced">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">coord_profile_non_georeferenced</code><span class="sig-paren">(</span><em>data_bank_all</em>, <em>data_dist_all</em>, <em>data_river_all</em>, <em>data_profile_all</em>, <em>nb_pro_reach</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.coord_profile_non_georeferenced" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to create the coordinates of the profile in the non-georeferenced case.
This function is called by open geo_file(). Hypothesis: The profile are straight and perpendicular to the river.
The last profile is at the end of the river.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_bank_all</strong> &#8211; distance along the profile of bank station</li>
<li><strong>data_dist_all</strong> &#8211; the distance between the profile (left, center channel, right)</li>
<li><strong>data_river_all</strong> &#8211; the coordinate of the river</li>
<li><strong>data_profile_all</strong> &#8211; the (d,z) data of the profile</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the coordinates of the profile</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>For each profile, we create an array composed of five points: Start of profile, left bank, intersection between
river and profile, right bank and end of profile. The intersection with the river is directly given as input to
the function. Then we find the vector perpendicular to this river and we get the four other points on the same line.</p>
<p>To get the distance for these four other point, we must be careful to pass from the distance given in meter and the
distance in the model coordinates (scaled between [0, 1] usually). The way to go from one coordinate system to
another is to use the “alpha” variable.  We only need to correct distance, no problem with a system of coordinate
which would not be in the same direction (as the data is given along a profile). The river passes in the middle of
the right and left bank, so we can find where is left and right bank is. Because we know the total length of the
profile, we can also find the beginning and end of the profile.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.figure_xml">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">figure_xml</code><span class="sig-paren">(</span><em>data_profile</em>, <em>coord_pro_old</em>, <em>coord_r</em>, <em>xy_h_all</em>, <em>zone_v_all</em>, <em>pro</em>, <em>path_im</em>, <em>nb_sim=0</em>, <em>name_profile='no_name'</em>, <em>coord_p2=-99</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.figure_xml" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to plot the results of the loading of hec-ras data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data_profile</strong> &#8211; (list with np.array)</li>
<li><strong>coord_pro_old</strong> &#8211; (x,y) data of the profile (list with np.array)</li>
<li><strong>coord_r</strong> &#8211; (x,y) data of the river (list with np.array)</li>
<li><strong>xy_h_all</strong> &#8211; (x,y, h) for the height data for each simulation (list with np.array)</li>
<li><strong>zone_v_all</strong> &#8211; (x,y, v) for the velocity data. velocity is by zone of profile. for each simulation.
the (x,y) indicates the start of the zone which end with the next velocity</li>
<li><strong>pro</strong> &#8211; a list of int with the profile whcih should be ploted [2,3,4]</li>
<li><strong>nb_sim</strong> &#8211; which simulation should be plotted. In fact, it often relates to the time step.</li>
<li><strong>name_profile</strong> &#8211; a list of string with the name of the profiles</li>
<li><strong>coord_p2</strong> &#8211; the data of the profile when non geo-referenced, optional</li>
<li><strong>path_im</strong> &#8211; the path where the figure should be saved (string)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>We first choose the size of the font to be written. At term, it should be given by the options.</p>
<p>Two main groups of figure will be done: One list of figure with the form of the profil, the water height, and the
velocity for the chosen profiles and one (x,y) view of the position of each profile.</p>
<p>We chose the time step to be written (the variable nb_sim here). The variable pro is a list which says which
profiles are to be plotted. Hence, we get the velocity and water height for the time step and profile of interest.</p>
<p>To plot the velocity, we first get the distance along the profile where the water level cut the profile elevation.
This is the variable xint1 and xint2. We then get the velocity data for the region under the water. We add three
points for velocity at 0, xint1 and xint2. We then used the step function to plot the vecloity. Because of the added
point, we will have a zero velocity from 0 to xint1, then the velocity data, then again zeros from xint2 to the end.</p>
<p>To plot the elevation of the profile, we plot the variable xz and we use the function fill_between to fill
in blue the region under water. This function creates a line at the water elevation and fills in blue between this
line and the profile elevation. We add some titles and save the figures.</p>
<p>For the second type of figure (view in x,y coordinates), We first plot the river position which is saved in the
coord_r variable. Then we plot the coordinate of each profile and their names. If the name of the profile is not
known, we plot the profile number.  We also plot the position of each velocity data and height data (as it could be
useful). If the figure gets too complicated, this can be taken away by changing the two lines which finish
with height or velocity as comment.  We add some titles and save the figures.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.find_coord_height_velocity">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">find_coord_height_velocity</code><span class="sig-paren">(</span><em>coord_pro</em>, <em>data_profile</em>, <em>vel</em>, <em>wse</em>, <em>nb_sim</em>, <em>max_vel_dist=0</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.find_coord_height_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>This function finds the coordinates of the height/velocity. In hec-ras outputs the data are often written in the
form (profile, distance along the profile, data). This function passes this type of information in the usual
coordinate form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coord_pro</strong> &#8211; the coordinate (x,y) of the profile. List of np.array.</li>
<li><strong>data_profile</strong> &#8211; data concening the geometry of the profile, notably its elevation (x,z). List of np.array.</li>
<li><strong>vel</strong> &#8211; the velocity data. List of np.array.</li>
<li><strong>wse</strong> &#8211; the water surface elevation. List of np.array.</li>
<li><strong>nb_sim</strong> &#8211; the number of simulation in case there is more than one</li>
<li><strong>max_vel_dist</strong> &#8211; the minimum number of velocity point by ten meter before a warnings appears</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">for each simulation, a list of np.array representing (x,y,v) and (x,y,h,)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>This is a function called after having loaded the data. Hec-Ras present the data in (profil, distance along
profile, data) form for the height. For the velocity, it is similar but the distance is given by a number between
0 and 1 (0 is the start of the profile, 1 is the end of the profile). This function transforms this data in the form
(x,y, dist, data) using the (x,y) coordinates given in the coord_pro variable. In other word,  we have the
coordinate of the profile, not of the coordinates of the height and velocity data.</p>
<p>First, we get the distance between all points in (x,y) system. Then, we get the length of the profile in
meter or feet. It is possible to have a (x,y) coordinate system in a different unit. Hence, the length of the profil
is valid for the (profile, distance along profile, data) view. We multiply the velocity distance data by this
length. Hence, the distance information is now in meter or feet along the profile for water height and velocity.</p>
<p>There are some lines added to account for the last and first points of the profile (annoying in hec-ras). We then
calculate the new coordinates. For each velocity and water height point, we find the last known point in the (x,y)
coordinates. We do a vectorial addition from this point plus the vector between this point and the next multiplied
by the distance from this point to the point that we tried to calculate.  The variable alpha is used to pass from
one coordinate system to the next one.</p>
<p>Careful the height is on the node and the velocity is by zone.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.get_rid_of_white_space">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">get_rid_of_white_space</code><span class="sig-paren">(</span><em>stream_str</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.get_rid_of_white_space" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a small fonction to get rid of white space at the end of name which could contain white space. Not used
anymore as str.strip() functions well. But, as it was done already, we let it here.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>stream_str</strong> &#8211; the name of the string</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the same name without white space.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.load_xml">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">load_xml</code><span class="sig-paren">(</span><em>xml_file</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.load_xml" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function used by openxml_file and opengml_file to load an xml file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xml_file</strong> &#8211; the name of an xml file (string)</li>
<li><strong>path</strong> &#8211; the path where the xml file is (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the loaded data from the XML file in the form of the root of the xml file.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.main">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.main" title="Permalink to this definition">¶</a></dt>
<dd><p>This is not the main() of HABBY. This function is used to test this module independently of the rest of HABBY.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.open_geofile">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">open_geofile</code><span class="sig-paren">(</span><em>geo_file</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.open_geofile" title="Permalink to this definition">¶</a></dt>
<dd><p>This function opens the geometry file (.g0X) from Hecr-rad. It extracts the (x,z) from each profile
and the (x,y) if georeferenced,</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geo_file</strong> &#8211; the name of the Hec-Ras geometry file (string)</li>
<li><strong>path</strong> &#8211; the path to the geo file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list with each river profile (each profile is represented by a numpy array with the x and the altitude
of each point in the profile), the coordinate of the profile (list of np.array),
the coordinate of the river and the name of the reaches/ river in the file order (list of string)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>The geofile is a text file with contains the geographical information. Because it is written to be read by human,
it is complicated to load and regular expression are needed. It is written profile by profile.</p>
<p>Generally, to give a position, hec-ras indicates the profile number and the distance along this profile. In addition,
data can be georeferenced or not. If it is geo-referenced we have some data in an (x,y) form. Otherwise, we only
have geometrical data in the form (profile, dist).</p>
<p>First, for each profile, we get the elevation of the points forming each profile in the form (dist, elevation).
The list of elevation for each profile starts with the keyword “Sta/Elev”. The data found in the text file is in a
string format. We use the function pass_in_float_from_geo to pass it in float. It is usually done using the function
float. However, there are cases where there are no space between two number. However, in this case, the number of
character per number is constant. In this case, we separate the number first.</p>
<p>Then, we get the coordinate of the river. If no coordinate are available the river is assumed to be straight. Next,
we get the bank limit (even if we do not really used afterwards), and the name of the reach. It is also important
to save the order in which the names of the reach are given. Indeed, we want this order to be the same in all
functions, but they can be different between the geo file and the data output.</p>
<p>Next, we want to get the position (x,y) of each profile. If it is georeferenced, we will be able to get this
position directly from the file and put it in the data_dist_str variable. We will then pass it to float. If not,
we will use the function coord_profil_non_georeferenced to estimate the position of the profile (see below).</p>
<p>If the profile is not georeferenced, it is important to have the distance between two profile, so we extract the
information from the geo file in all cases (georeferenced or not). The last profile of a reach does not have a
distance to the next (not existing) profile. However, if a profile does not have a distance to the next profile
and is not the last profile, we ignore this profile. It is usually not a problem because this profile is usually
not a “real” profile, but the representation of a bridge or a culvert.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.open_hecras">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">open_hecras</code><span class="sig-paren">(</span><em>geo_file</em>, <em>res_file</em>, <em>path_geo</em>, <em>path_res</em>, <em>path_im</em>, <em>save_fig=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.open_hecras" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will open HEC-RAS outputs, i.e. the .geo file and the outputs (either .XML, .sdf or .rep) from HEC-RAS.
All arguments from this function are string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geo_file</strong> &#8211; the name of .goX (example .go3) file which is an output from hec-ras containg the profile data</li>
<li><strong>res_file</strong> &#8211; the name of O0X.xml file for the name of the .sdf file  or the name of the .rep file (output data)</li>
<li><strong>path_res</strong> &#8211; path to the result file</li>
<li><strong>path_geo</strong> &#8211; path to the geo file</li>
<li><strong>path_im</strong> &#8211; the path to the folder where the images should be saved</li>
<li><strong>save_fig</strong> &#8211; if True image is saved</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coord_pro (for each profile, x,y,elev, dist along the profile), vh_pro
(for each profile, dist along the profile, water height, velocity). Both variable are a list of numpy array.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>How to obtain the input files</strong></p>
<p>To obtain the xml file in HEC-RAS version 4:</p>
<ul class="simple">
<li>open the project in HEC-RAS.</li>
<li>click on File , then export geometry and result (RAS Mapper), then OK</li>
</ul>
<p>To obtain the sdf file in HEC-RAS version 5 which should be used if the model is georeferenced:</p>
<ul class="simple">
<li>click on File, then Export GIS data</li>
<li>Export all reaches (select Reaches to export -. Full List -&gt; Ok)</li>
<li>Export all needed profile (select Profile to export -&gt; Select all -&gt; ok)</li>
</ul>
<p>To obtain the report file .rep in HEC-RAS version which should be used if the model is NOT geo-referenced</p>
<ul class="simple">
<li>click on File, generate report</li>
<li>Select Flow data and Geometry data in input data and, in Specific Table, select Flow distribution and
Cross section Table</li>
</ul>
<p><strong>Technical comments</strong></p>
<p>This is function which loads the hec_ras inputs in 1D for the version 4 and 5 of HEC-RAS. It accepts different type
of hec-ras output as input and calls the appropriate sub-function for each input file.  The geometrical data is
always given in the geo file (with the extension g01, G01, g02, G02, g03, etc.). The output data can be in an xml
file for the hec-ras in the version 4, an sdf file for hec-ras in version 5 or a .rep file in the version 5 if the
model is not georeferenced. The xml file is the format which has been tested the most.</p>
<p>First, it loads the geometrical data. Then it select the function to load the output data and loads it. Then, it
transforms the loaded data in a (x,y) coordinates system. Indeed, most of the data in hec-ras is given by indicating
a profile (which crossed the modelled river) and the distance along this profile. For HABBY, it is better to get
(x,y) coordinates. Then it create figure if asked by the switch “save_fig”. Finally, it updates the forms of the
output to be coherent with the dist_velocity_hecras function.  This way, in HABBY, the output from mascaret and
rubar after the velocity distribution have the same form than the output from hec-ras, which is useful afterwards
to save all these data in the hdf5 file.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.open_repfile">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">open_repfile</code><span class="sig-paren">(</span><em>report_file</em>, <em>reach_name</em>, <em>path</em>, <em>data_profile</em>, <em>data_bank</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.open_repfile" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to open the report file (.rep) from HEC-RAS. To obtain the report file, see the doc of the function
open_hecras.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>report_file</strong> &#8211; a string with the name of the report file (.rep)</li>
<li><strong>reach_name</strong> &#8211; a list of string containing the name of the reaches/rivers in the order of the geo file,
which might not be the order of the sdf file.</li>
<li><strong>path</strong> &#8211; the path where the report file is stored (string)</li>
<li><strong>data_profile</strong> &#8211; the data from each profile from the geofile (output from the open_geofile function)</li>
<li><strong>data_bank</strong> &#8211; the position of the bank limit (output from the open_geofile function)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">velocity and the water surface elevation for each river profiles in a list of np.array,
the number of simulation (int) and the name of the river profile (list of string)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments and walk-through</strong></p>
<p>This function is used to open output from models which were not geo-referenced in hec-ras v5. It cannot be used if
the model was georeferenced (or at least one should make some tests before).</p>
<p>First, we obtain the water height. Then, we obtain the number of time step (which is called the number of
simulation by hec-ras). To get the number of time step, we count each outputs given (one by profiles) and we
divided it by the number of profile in the river. It is a bit indirect, but I did not find a simpler solution.</p>
<p>We get the name of each profile and reach. Then, we get the velocity data. We have in a case which is not
geo-referenced. By consequence, there are only three velocities: one the left bank, one in the main river channel
and one the right bank.  Next we get the distance along the profile for these three velocities. Finally, we use
the function reoder_reach for the same reason than in open_sdffile and open_xml.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.open_sdffile">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">open_sdffile</code><span class="sig-paren">(</span><em>sdf_file</em>, <em>reach_name</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.open_sdffile" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to load .sdf file from HEC-RAS v5 used if the model is georeferenced. To find how to obtain the
sdf file, read the doc of open_hecras.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sdf_file</strong> &#8211; the name of the sdf file (string)</li>
<li><strong>reach_name</strong> &#8211; a list of string containing the name of the reaches/rivers in the order of the geo file
which might not be the one of the sdf file. Output from open_geofile.</li>
<li><strong>path</strong> &#8211; the path where the file is stored (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">velocity, water height, river_name, number of  time step (nb_sim)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>To strat loading the sdf file, we open the sdf file. It is mostly a text file. Then we find velocity data and we
pass this velocity data from string to float. The process is a bit similar to the one used in the function
open_geofile with a healthy dose of regular expressions. We do this again for height data.</p>
<p>We also extract the name of the river, reaches and profile. The number of simulation (nb_sim) is a bit confusing
for a variable name. In fact, it is the number of time step. Hec-Ras considers that one simulation is the simulation
for one time step. Hence, nb_sim is more or less nb_timestep.</p>
<p>As in the xml file, we finally re-order the data as in the geo file. Indeed, it is possible to have different order
between the reaches in the geo file and in the sdf file. Here, we use the function reorder_reach for this.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.open_xmlfile">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">open_xmlfile</code><span class="sig-paren">(</span><em>xml_file</em>, <em>reach_name</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.open_xmlfile" title="Permalink to this definition">¶</a></dt>
<dd><p>This function open the xml file from HEC-RAS v4 to get the velocity and water surface elevation. To know how to
obtain this xml file, read the doc of open_hecras.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xml_file</strong> &#8211; the name of O0X.xml file from HEC-RAS. (string)</li>
<li><strong>reach_name</strong> &#8211; a list of string containing the name of the reaches/rivers in the order of the geo file
which might not be the one of the xml file.</li>
<li><strong>path</strong> &#8211; path to the xml file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">velocity and the water surface elevation for each river profiles (list of np.array),
the number of simulation(int) and the name of the river profile (list of string)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>To load the xml file, we first call the load_xml function. It is a function which check that the xml file is well
formed and which return the “root” part fo the xml. With this “root”, it is possible to load other part of the xml
file using the Etree module.</p>
<p>Then, we load the velocity and water height data from the xml file. We also load the name of the profiles and of
the reach names.  Next, we pass the data into float. For each velocity of height point, we get its position along
the profile (see below for format) and the value at this point.</p>
<p>Finally, we re-order the data as in the geo file. Indeed, it is possible to have different order between the reaches
in the geo file and in the xml file. The last part of this function is there to order all the data as in the geo
file. There is a function reorder_reach which does something similar, but could not be used by the output from the
xml file (it is slighty different). However the reorder_reach function and this part of the open_xml function is
very similar.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.pass_in_float_from_geo">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">pass_in_float_from_geo</code><span class="sig-paren">(</span><em>data_str</em>, <em>len_number</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.pass_in_float_from_geo" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to pass the string data into float for open_geofile() and open_sdffile(). It is in a function
because it is possible that two number are not separated by a space in the input data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_str</strong> &#8211; the data in a string form</li>
<li><strong>len_number</strong> &#8211; the number of digit for one number (int)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a np.array of float with 2 columns  (x,y) or (x,z)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.reorder_reach">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">reorder_reach</code><span class="sig-paren">(</span><em>wse</em>, <em>vel</em>, <em>riv_name</em>, <em>reach_name</em>, <em>reach_str</em>, <em>stream_str</em>, <em>nb_sim</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.reorder_reach" title="Permalink to this definition">¶</a></dt>
<dd><p>The order of the reach in HABBY is in the order given in the geo file. However, it can be given in any order
in the other file. (xml, sdf, rep,...). This function re-order the reaches based on their name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>wse</strong> &#8211; water height data (list of np.array for each profile)</li>
<li><strong>vel</strong> &#8211; velocity data (list of np.array for each profile)</li>
<li><strong>riv_name</strong> &#8211; the name of the profile (yeah I know it is not really logical as a name)</li>
<li><strong>reach_name</strong> &#8211; the name of the reach and stream (stream,reach) in the geo file order</li>
<li><strong>reach_str</strong> &#8211; the name of the reach in the anaylsed file order</li>
<li><strong>stream_str</strong> &#8211; the name of the stream in the anaylsed file order</li>
<li><strong>nb_sim</strong> &#8211; the number of simulation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">wse, vel, riv_name all re-ordered</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>The reach name should not have white space at the end/start but can have white space into them.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.update_output">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">update_output</code><span class="sig-paren">(</span><em>zone_v</em>, <em>coord_pro_old</em>, <em>data_profile</em>, <em>xy_h</em>, <em>nb_pro_reach_old</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.update_output" title="Permalink to this definition">¶</a></dt>
<dd><p>This function updates the form of the output so it is coherent with mascaret and rubar after the lateral
distribution of velocity for these two models. There are three important changes. First, coord_pro contains dist along
the profile (x) and height in addition to the coordinates. Secondly, vh_pro contains only height if height is above
or equal to zero. Thirdly, a point is created at the water limits and v and height are given at the same points.
nb_pro_reach is also modified as in mascaret. We want to modify it so it start by zero and is additive, i.e., that
it gives total number of profile before, not the number of profile by reach.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>zone_v</strong> &#8211; (x,y, dist along profile, v) for each time step. However, the zone are the one from the models.
They are different than the one from xy_h, which is unpractical for the rest of HABBY.</li>
<li><strong>coord_pro_old</strong> &#8211; the (x,y) coordinate for the profile</li>
<li><strong>data_profile</strong> &#8211; the distance along the porfile and height of each profile</li>
<li><strong>xy_h</strong> &#8211; the water height</li>
<li><strong>nb_pro_reach_old</strong> &#8211; the number of the profile by reach in the old form.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coord_pro, vh_pro, nb_pro_reach</p>
</td>
</tr>
</tbody>
</table>
<p>[doc to be finished]</p>
</dd></dl>

<div class="section" id="notes-on-hec-ras-outputs">
<h3>Notes on hec-ras outputs<a class="headerlink" href="#notes-on-hec-ras-outputs" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Data in HEC-RAS can be geo-referenced or not georeferenced. It is advised to geo-reference
all model in HEC-RAS. If the model is not geo-referenced, the function makes some assumptions to
load the data: 1) the river profile are straight and perpendicular to the river.
2) the last profile is at the end of the river.</li>
<li>To geo-reference a model in hec_ras: In the “geometric data” window, GIS tool, GIS Cut Line, Accept Display location, choose all profile</li>
<li>Numerical data are sometime not separated (0.4556 0.3453233.454 05.343). In this case, the number of digit is assumed to be 8 for the profile and 16 for the river coordinates.</li>
<li>Part of the profile can be vertical: The function also functions in this case.</li>
<li>There is sometimes more than one reach in the modelled river and these reaches sometimes form loops: The function load each reach one after the other.</li>
<li>The river reaches are sometimes not in the same order in the xml file and in the .goX file. The order of the .goX is used by the function. Reach are automatically re-ordered.</li>
<li>If the river is straight, the coordinates of the river are given differently. The function try to load the river in the “straight” style if the usual style fail.</li>
<li>The .goX file includes data on bridges and culvert. Currently, the function neglects this information.</li>
<li>Sometimes distances between profiles are not given in the .goX file. The function neglects the distance data of this profile as long as it is not the last profile.</li>
<li>The velocity data for the end and the beginning of the river profile is indicated by a large number (example 1.23e35 or -1.234e36). The function considers that velocity info is situated at the start of the profile if x&gt;-1e30 and at the end of the profile if x&gt; 1e30.</li>
<li>There are two concepts called “profile” in HEC-RAS: The river profiles and the simulation profiles. The river profiles are the geometry perpendicular to the river and the simulation profile are the different simulations.</li>
<li>Data in many of the example cases of HEC-RAS are in foot and miles. 1 miles = 5280 foot, and not 1000 foot.</li>
</ul>
</div>
</div>
<div class="section" id="hec-ras-model-2d">
<h2>Hec-ras model 2D<a class="headerlink" href="#hec-ras-model-2d" title="Permalink to this headline">¶</a></h2>
<p>in src/Hec_ras2D.py</p>
<p>This module contains the functions used to load the outputs from the hec-ras model in 2D.</p>
<span class="target" id="module-src.hec_ras2D"></span><dl class="function">
<dt id="src.hec_ras2D.figure_hec_ras2d">
<code class="descclassname">src.hec_ras2D.</code><code class="descname">figure_hec_ras2d</code><span class="sig-paren">(</span><em>v_all, h_all, elev_all, coord_p_all, coord_c_all, ikle_all, path_im, time_step=[0], flow_area=[0], max_point=-99</em><span class="sig-paren">)</span><a class="headerlink" href="#src.hec_ras2D.figure_hec_ras2d" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to plot figure of the output from hec-ras 2D. This function is only used to debug, not directly by HABBY.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>v_all</strong> &#8211; a list of np array representing the velocity at the center of the cells</li>
<li><strong>h_all</strong> &#8211; a list of np array representing the water depth at the center of the cells</li>
<li><strong>elev_all</strong> &#8211; a list of np array representing the mimium elevation of each cells</li>
<li><strong>coord_p_all</strong> &#8211; a list of np array representing the coordinates of the points of the grid</li>
<li><strong>coord_c_all</strong> &#8211; a list of np array representing the coordinates of the centers of the grid</li>
<li><strong>ikle_all</strong> &#8211; a list of np array representing the connectivity table
one array by flow area</li>
<li><strong>time_step</strong> &#8211; which time_step should be plotted (default, the first one)</li>
<li><strong>flow_area</strong> &#8211; which flow_area should be plotted (default, the first one)</li>
<li><strong>max_point</strong> &#8211; the number of cell to be drawn when reconstructing the grid (it might long)</li>
<li><strong>path_im</strong> &#8211; the path where the figure should be saved</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comment</strong></p>
<p>This function creates three figures which represent: a) the grid of the loaded models b) the water height and
c) the velocity.</p>
<p>The two last figures will be modified when the data will be loaded by node and not by cells. So we will not explai
n them here as they should be re-written.</p>
<p>The first figure is used to plot the gird. If we would plot the grid by drawing one side of each triangle
separately, it would be very long to draw. To optimize the process, we use the prepare_grid function.</p>
</dd></dl>

<dl class="function">
<dt id="src.hec_ras2D.get_triangular_grid_hecras">
<code class="descclassname">src.hec_ras2D.</code><code class="descname">get_triangular_grid_hecras</code><span class="sig-paren">(</span><em>ikle_all</em>, <em>coord_c_all</em>, <em>point_all</em>, <em>h</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#src.hec_ras2D.get_triangular_grid_hecras" title="Permalink to this definition">¶</a></dt>
<dd><p>In Hec-ras, it is possible to have non-triangular cells, often rectangular cells This function transform the
&#8220;mixed&#8221; grid to a triangular grid. For this,
it uses the centroid of each cell with more than three side and it create a triangle by side (linked with the
center of the cell). A similar function exists in rubar.py, but, as there are only one reach in rubar
and because ikle is different in hec-ras, it was hard to marge both functions together.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ikle_all</strong> &#8211; the connectivity table by reach (list of np.array)</li>
<li><strong>coord_c_all</strong> &#8211; the coordinate of the centroid of the cell by reach</li>
<li><strong>point_all</strong> &#8211; the points of the grid</li>
<li><strong>h</strong> &#8211; data on water height by reach by time step</li>
<li><strong>v</strong> &#8211; data on velocity by reach by time step</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the updated ikle, coord_c (the center of the cell , must be updated ) and xy (the grid coordinate)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.hec_ras2D.load_hec_ras2d">
<code class="descclassname">src.hec_ras2D.</code><code class="descname">load_hec_ras2d</code><span class="sig-paren">(</span><em>filename</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.hec_ras2D.load_hec_ras2d" title="Permalink to this definition">¶</a></dt>
<dd><p>The goal of this function is to load 2D data from Hec-RAS in the version 5.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> &#8211; the name of the file containg the results of HEC-RAS in 2D. (string)</li>
<li><strong>path</strong> &#8211; the path where the file is (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">velocity and height at the center of the cells, the coordinate of the point of the cells,
the coordinates of the center of the cells and the connectivity table. Each output is a list of numpy array
(one array by 2D flow area)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>How to obtain the input file</strong></p>
<p>The file neede as input is an hdf5 file (.hdf) created automatically by Hec-Ras. There are many .hdf created by
Hec-Ras. The one to choose is the one with the extension p0X.hdf (not g0x.hdf). It is usually the largest file in
the results folder.</p>
<p><strong>Technical comments</strong></p>
<p>Outputs from HEC-RAS in 2D are in the hdf5 format. However, it is not possible to directly use the output of HEC-RAS
as an hdf5 input for HABBY. Indeed, even if they are both in hdf5, the formats of the hdf5 files are different
(and would miss some important info for HABBY).  So we still need to load the HEC-RAS data in HABBY even if in 2D.</p>
<p>This function call the function get_trianglar grid which is in rubar.py.</p>
<p><strong>Walk-through</strong></p>
<p>The name and path of the file is given as input to the load_hec_ras_2D function. Usually this is done by the class
HEC_RAS() in the GUI.  We load the file using the h5py module. This module opens and reads hdf5 file.</p>
<p>Then we can read different part of the hdf5 file when we know the address of it (this is a bit like a file system).
In hdf5 file of Hec-RAS, this first thing is to get the names of the flow area in “Geometry/2D Flow Area”. In
general, this is the name of each reach, but it could be lake or pond also. In an hdf5 file, to see the name of
the member in a group, use: list(&#8220;group&#8221;.keys())</p>
<p>Then, we go to “Geometry/2D Flow Area/&lt;name&gt;/FacePoint Coordinates” to get the points forming the grid.
We can also get the connectivity table (or ikle) to the path “Geometry/2D Flow Area/&lt;name&gt;/Cells Face Point Indexes”
We also get the elevations of the cells. However, this is just the minimum elevation of the cells, so it is
to be used only for a quick estimation. We then get the water depth by cell.
The velocity is given by face of the cells and is averaged to get it on the middle of the cells.</p>
<p>To get Hec-Ras data by nodes, it is necessary to intepolate the data. There is a function to do this in
manage_grid_8.</p>
</dd></dl>

<dl class="function">
<dt id="src.hec_ras2D.main">
<code class="descclassname">src.hec_ras2D.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.hec_ras2D.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module independantly of HABBY.</p>
</dd></dl>

<dl class="function">
<dt id="src.hec_ras2D.prepare_grid">
<code class="descclassname">src.hec_ras2D.</code><code class="descname">prepare_grid</code><span class="sig-paren">(</span><em>ikle</em>, <em>coord_p</em>, <em>max_point=-99</em><span class="sig-paren">)</span><a class="headerlink" href="#src.hec_ras2D.prepare_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to put in the new form the data forming the grid to accelerate the plotting of the grid. This function creates
a list of points of the grid which are re-ordered compared to the usual list of grid point (the variable coord_p
here). These points are reordered so that it is possible to draw only one line to form the grid (one point can
appears more than once). The grid is drawn as one long line and not as a succession of small lines, which is
quicker. When this new list is created by prepare_function(), it is send back to figure-hec_ras_2D and plotted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ikle</strong> &#8211; the connectivity table</li>
<li><strong>coord_p</strong> &#8211; the coordinates of the point</li>
<li><strong>max_point</strong> &#8211; if the grid is very big, it is possible to only plot the first points, up to max_points (int)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list of x and y coordinates ordered.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.hec_ras2D.scatter_plot">
<code class="descclassname">src.hec_ras2D.</code><code class="descname">scatter_plot</code><span class="sig-paren">(</span><em>coord</em>, <em>data</em>, <em>data_name</em>, <em>my_cmap</em>, <em>s1</em>, <em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#src.hec_ras2D.scatter_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to plot the scatter of the data. Will not be used in the final version, but can be useful to
plot data by cells.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coord</strong> &#8211; the coordinates of the point</li>
<li><strong>data</strong> &#8211; the data to be plotted (np.array)</li>
<li><strong>data_name</strong> &#8211; the name of the data (string)</li>
<li><strong>my_cmap</strong> &#8211; the color map (string with matplotlib colormap name)</li>
<li><strong>s1</strong> &#8211; the size of the dot for the scatter</li>
<li><strong>t</strong> &#8211; the time step being plotted</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="mascaret">
<h2>Mascaret<a class="headerlink" href="#mascaret" title="Permalink to this headline">¶</a></h2>
<p>in src/mascaret.py</p>
<p>This module contains the functions used to load the outputs from the mascaret model.</p>
<span class="target" id="module-src.mascaret"></span><dl class="function">
<dt id="src.mascaret.correct_duplicate">
<code class="descclassname">src.mascaret.</code><code class="descname">correct_duplicate</code><span class="sig-paren">(</span><em>seq</em>, <em>send_warn</em>, <em>idfun=None</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.correct_duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>It is possible to have a vertical line on a profile (different h, identical x). This is not possible for HABBY and
the 2D grid. So this function correct duplicates along the profile.</p>
<p>A similiar function exists in rubar, for the case where input is (x,y) coordinates and not distance along the profile.
This function is inspired by <a class="reference external" href="https://www.peterbe.com/plog/uniqifiers-benchmark">https://www.peterbe.com/plog/uniqifiers-benchmark</a></p>
<p>It should be tested more as manage_grid sometime still send warning about duplicate data in profile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>seq</strong> &#8211; the list to be corrected (list)</li>
<li><strong>send_warn</strong> &#8211; a bool to avoid printing certains warning too many time</li>
<li><strong>idfun</strong> &#8211; support an optional transform function (not used)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the profile data without duplicate and the bollean which manages the warning.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.define_stream_network">
<code class="descclassname">src.mascaret.</code><code class="descname">define_stream_network</code><span class="sig-paren">(</span><em>node_number</em>, <em>start_node</em>, <em>end_node</em>, <em>angles</em>, <em>nb_pro_reach</em>, <em>nb_reach</em>, <em>abcisse</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.define_stream_network" title="Permalink to this definition">¶</a></dt>
<dd><p>This function extracts the stream network from the node and angle data. This is used if we have more than one
reach to define the geometry of the junction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>node_number</strong> &#8211; the start/end number of the reaches for each nodes (list of list)</li>
<li><strong>start_node</strong> &#8211; the numbers indicating the start of each reach (list)</li>
<li><strong>end_node</strong> &#8211; the numbers indicating the end of each reach</li>
<li><strong>angles</strong> &#8211; for each node the angle between the reach</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach</li>
<li><strong>nb_reach</strong> &#8211; the number of reach</li>
<li><strong>abcisse</strong> &#8211; the distance along the river of each reach</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the river coordinates and the unit vector indicating the river direction</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.figure_mascaret">
<code class="descclassname">src.mascaret.</code><code class="descname">figure_mascaret</code><span class="sig-paren">(</span><em>coord_pro, coord_r, xhzv_data, on_profile, nb_pro_reach, name_pro, name_reach, path_im, pro, plot_timestep=[-1], reach_plot=[0]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.figure_mascaret" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to plot the figures related to mascaret.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coord_pro</strong> &#8211; the cordinates (x,y,h, dist along the river) of the profiles</li>
<li><strong>coord_r</strong> &#8211; the coordinate (x,y) of the river</li>
<li><strong>name_pro</strong> &#8211; the name of the profile</li>
<li><strong>name_reach</strong> &#8211; the name of the reach</li>
<li><strong>on_profile</strong> &#8211; which result are on the profile. Some output are not the profiles.</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach (careful this is the number of profile, not the number of output)</li>
<li><strong>xhzv_data</strong> &#8211; the height and velcoity (x,h,v) list by time step</li>
<li><strong>profile</strong> (<em>pro</em>) &#8211; which profile to be plotted (list of int)</li>
<li><strong>plot_timestep</strong> &#8211; which timestep to be plotted</li>
<li><strong>reach_plot</strong> &#8211; the reach to be plotted for the river view</li>
<li><strong>path_im</strong> &#8211; the path where to save the figure</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.find_node">
<code class="descclassname">src.mascaret.</code><code class="descname">find_node</code><span class="sig-paren">(</span><em>node_number</em>, <em>reach_to_find</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.find_node" title="Permalink to this definition">¶</a></dt>
<dd><p>This function finds which node is a stream end or a stream start. It is associated by the function
define_stream_network()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>node_number</strong> &#8211; the list of list of the reaches linked with one node</li>
<li><strong>reach_to_find</strong> &#8211; the number indicating the start or end of the reach</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the node number, ordered as in the xcas file</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.flat_coord_pro">
<code class="descclassname">src.mascaret.</code><code class="descname">flat_coord_pro</code><span class="sig-paren">(</span><em>coord_pro</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.flat_coord_pro" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is not used anymroe.</p>
<p>The variable coord_pro was a list of profile by reach. Finally, it was useful to have each profile one after the
other with accounting for the reach. So we stop to use this function whose goal was to pass from one form of
coord_pro to the other form 9with or wihtout reach information).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coord_pro</strong> &#8211; the list of profile (x,y,h, dist along the river) by reach</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">coord_pro_f: a list of profile without the reach information. The list is flatten</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.get_geo_name_from_xcas">
<code class="descclassname">src.mascaret.</code><code class="descname">get_geo_name_from_xcas</code><span class="sig-paren">(</span><em>file_gen</em>, <em>path_gen</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.get_geo_name_from_xcas" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets the name of the .geo file from the .xcas xml file. It is not used yet, but it could be useful
in the GUI to simplify the loading of mascaret. The user would not need to give the name of the geo and the xcas
files separetly. However, it is not written in yet.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_gen</strong> &#8211; the xcas file</li>
<li><strong>path_gen</strong> &#8211; the path to the xcas file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the name of the .geo file (no path indicated)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.get_name_from_cas">
<code class="descclassname">src.mascaret.</code><code class="descname">get_name_from_cas</code><span class="sig-paren">(</span><em>file_gen</em>, <em>path_gen</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.get_name_from_cas" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets the name of the .geo file from the .cas text file. It is not used yet, but it could be useful
in the GUI to simplify the loading of mascaret. The user would not need to give the name of the geo and the cas
files separetly. However, it is not written in yet.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_gen</strong> &#8211; the name of .cas file (string)</li>
<li><strong>path_gen</strong> &#8211; the path to the cas file (string</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the name of the .geo file (no path indicated)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.is_this_res_on_the_profile">
<code class="descclassname">src.mascaret.</code><code class="descname">is_this_res_on_the_profile</code><span class="sig-paren">(</span><em>abscisse</em>, <em>xhzv_data_all</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.is_this_res_on_the_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>The output of mascaret can be given at points of the river where there is no profile.
The function here says which results are on the profiles. All profiles are linked with an output, but some output
are not linked with a profile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>abscisse</strong> &#8211; the distance between each profile (list of float)</li>
<li><strong>xhzv_data_all</strong> &#8211; the outputs from mascaret by time step</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list of bool of the length of xhzv_data, True on profile, False not on profile</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comment</strong></p>
<p>In the mascaret outputs, some rounding are suprising. For example, 0.49 can be transformed to 0.50 in an otehr file
(not 0.5). To avoid this type of problem, we says that outputs with a distance smaller than 3cm of the profile are
on the profile. If there are more than one output by profile, we takes the output which is the closest to the
profile.</p>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.load_mascaret">
<code class="descclassname">src.mascaret.</code><code class="descname">load_mascaret</code><span class="sig-paren">(</span><em>file_gen</em>, <em>file_geo</em>, <em>file_res</em>, <em>path_gen</em>, <em>path_geo</em>, <em>path_res</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.load_mascaret" title="Permalink to this definition">¶</a></dt>
<dd><p>The function is used to load the mascaret data. It load the geofile and the general file. Then, it re-forms the
geometrical data. Next, it loads the output data from mascaret. Fianally, it looks which outputs is close to
a profile and which outputs is not linked with a profile as there are some outputs given between profiles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_gen</strong> &#8211; the xcas .xml file giving general info about the model (string)</li>
<li><strong>file_geo</strong> &#8211; the file containting the profile data (.geo) (string)</li>
<li><strong>file_res</strong> &#8211; the files containting the mascaret output in the Optyca format (.opt) (string)</li>
<li><strong>path_gen</strong> &#8211; the path to the xcas file or .cas file (string). By default, choose the xcas file.</li>
<li><strong>path_geo</strong> &#8211; the path to the geo file (string)</li>
<li><strong>path_res</strong> &#8211; the path to the res file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the coordinates of the profile (x,y,z, dist along the profile), the coordinate of the river (x,y), name of
reach and profile, data height and velocity (list by time step), list of bollean indicating which data is
on the profile and the number of profile by reach.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.main">
<code class="descclassname">src.mascaret.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module separately.</p>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.open_geo_mascaret">
<code class="descclassname">src.mascaret.</code><code class="descname">open_geo_mascaret</code><span class="sig-paren">(</span><em>file_geo</em>, <em>path_geo</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.open_geo_mascaret" title="Permalink to this definition">¶</a></dt>
<dd><p>This function load the mascaret geo file. Generally, the profile are not geo-referenced when using this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_geo</strong> &#8211; the name of the geo file (string)</li>
<li><strong>path_geo</strong> &#8211; the path to the geo file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the profile data (x,y), profile name (list of string),
brief name (list of string), the number of profile in each reach and distance along the river/abcisse (list)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.open_res_file">
<code class="descclassname">src.mascaret.</code><code class="descname">open_res_file</code><span class="sig-paren">(</span><em>file_res</em>, <em>path_res</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.open_res_file" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to load the output from mascaret (.opt file). The format is Optyca.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_res</strong> &#8211; the name of the .opt file (string)</li>
<li><strong>path_res</strong> &#8211; the path to this file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.open_rub_file">
<code class="descclassname">src.mascaret.</code><code class="descname">open_rub_file</code><span class="sig-paren">(</span><em>file_res</em>, <em>path_res</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.open_rub_file" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to open the binary output file from mascaret (.rub format).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_res</strong> &#8211; the name of the rub binary file (string)</li>
<li><strong>path_res</strong> &#8211; the path to this file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">xhzv_data, timestep</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comment</strong></p>
<p>The binary output file was done using a program written in FORTRAN. So there are often suprising
octet which are added to the binary file. Be careful before changing anything.</p>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.profil_coord_non_georef">
<code class="descclassname">src.mascaret.</code><code class="descname">profil_coord_non_georef</code><span class="sig-paren">(</span><em>coord_pro</em>, <em>coord_r</em>, <em>nr</em>, <em>nb_pro_reach</em>, <em>bt=None</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.profil_coord_non_georef" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets the coordinates (x,y) of the profile as masacret outputs are not georeferenced.</p>
<p>Hypothesis: The river and the profile are straight. The profile is perpendicular to the river.
The river pass at the minimum elevation of the river bed. If there is a distinction between the main bed the
secondary bed is given, we take the minimum elevation of the main bed</p>
<p>The origin of the coordinate system is the start of the river.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coord_pro</strong> &#8211; the coordinate of the profile. This variable is not in the general coordinate system,
just distance along the profile and bed elevation (p, dist, h)</li>
<li><strong>coord_r</strong> &#8211; the river coordinates</li>
<li><strong>n</strong> &#8211; the vector indicating the river direction</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach (additive)</li>
<li><strong>bt</strong> &#8211; optional, it indicates which points in the profiles are in the minor/major bed</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the velocity and height data, the timestep</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.river_coord_non_georef_from_cas">
<code class="descclassname">src.mascaret.</code><code class="descname">river_coord_non_georef_from_cas</code><span class="sig-paren">(</span><em>file_gen</em>, <em>path_gen</em>, <em>abcisse</em>, <em>nb_pro_reach</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.river_coord_non_georef_from_cas" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the coordinates of the river based on the cas text file. If there are only one river, this is an easy task as
the river is straight. If there are more than one reach, the junctions and the angles between the reach sould be
managed using the define_stream_network function and the information in the .cas file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_gen</strong> &#8211; the .cas file whcih contains general info (string)</li>
<li><strong>path_gen</strong> &#8211; the path to this file (string)</li>
<li><strong>abcisse</strong> &#8211; ditance along the profiles</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of reach by profile</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the river coordinate and the unit vector indicating the river direction</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.river_coord_non_georef_from_xcas">
<code class="descclassname">src.mascaret.</code><code class="descname">river_coord_non_georef_from_xcas</code><span class="sig-paren">(</span><em>file_gen</em>, <em>path_gen</em>, <em>abcisse</em>, <em>nb_pro_reach</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.river_coord_non_georef_from_xcas" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the coordinates of the river based on the xcas xml file. If there are only one river, this is an easy task as
the river is straight. If there are more than one reach, the junctions and the angles between the reach sould be
managed using the define_stream_network function and the information in the .xcas file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_gen</strong> &#8211; the .xcas file with the information concerning the reach (string)</li>
<li><strong>path_gen</strong> &#8211; the path to the xcas file (string)</li>
<li><strong>abcisse</strong> &#8211; the distance along the river</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coord_r the coordinate of the river</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="river-2d">
<h2>River 2D<a class="headerlink" href="#river-2d" title="Permalink to this headline">¶</a></h2>
<p>in src/river2D.py</p>
<p>This module contains the functions used to load the outputs from the River2D model.</p>
<span class="target" id="module-src.river2d"></span><dl class="function">
<dt id="src.river2d.figure_river2d">
<code class="descclassname">src.river2d.</code><code class="descname">figure_river2d</code><span class="sig-paren">(</span><em>xyzhv</em>, <em>ikle</em>, <em>path_im</em>, <em>t=0</em><span class="sig-paren">)</span><a class="headerlink" href="#src.river2d.figure_river2d" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to plot the output from river 2d. Need hec-ras2d as import because it re-used most of the plot from this
script. It is only used to debug. It is not used directly by HABBY.</p>
<p>Plot only one time step because river 2d output have one file by time step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xyzhv</strong> &#8211; the x,y, coordinates of the node (h,v are nodal output in river 2d), the river bed, the water height
and the velocity (one data by column, row are node)</li>
<li><strong>ikle</strong> &#8211; connectivity table</li>
<li><strong>path_im</strong> &#8211; the path where to save the figure</li>
<li><strong>t</strong> &#8211; the time step which is being plotted</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.river2d.get_rid_of_lines">
<code class="descclassname">src.river2d.</code><code class="descname">get_rid_of_lines</code><span class="sig-paren">(</span><em>datahere</em>, <em>nb_data</em><span class="sig-paren">)</span><a class="headerlink" href="#src.river2d.get_rid_of_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>There are lines which are useless in the cdg file. This function is used to correct ikle and data_node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>datahere</strong> &#8211; the data with the empty lines</li>
<li><strong>nb_data</strong> &#8211; nb_node or nb_el</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">datahere wihtout the useless lines</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.river2d.load_river2d_cdg">
<code class="descclassname">src.river2d.</code><code class="descname">load_river2d_cdg</code><span class="sig-paren">(</span><em>file_cdg</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.river2d.load_river2d_cdg" title="Permalink to this definition">¶</a></dt>
<dd><p>The file to load the output data from River2D. Careful the input data of River2D has the same ending and nearly
the same format as the output. However, it is nessary to have the output here. River2D gives one cdg. file by timestep.
Hence, this function read only one timeste. HABBY read all time step by calling this function once for each time step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_cdg</strong> &#8211; the name of the cdg file (string)</li>
<li><strong>path</strong> &#8211; the path to this file (string).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the velcoity and height data, the coordinate and the connectivity table.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.river2d.main">
<code class="descclassname">src.river2d.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.river2d.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module.</p>
</dd></dl>

</div>
<div class="section" id="rubar">
<h2>Rubar<a class="headerlink" href="#rubar" title="Permalink to this headline">¶</a></h2>
<p>in src/rubar.py</p>
<p>This module contains the functions used to load the Rubar data in 2D and 1D.</p>
<span class="target" id="module-src.rubar"></span><dl class="function">
<dt id="src.rubar.correct_duplicate_xy">
<code class="descclassname">src.rubar.</code><code class="descname">correct_duplicate_xy</code><span class="sig-paren">(</span><em>seq3D</em>, <em>send_warn</em>, <em>idfun=None</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.correct_duplicate_xy" title="Permalink to this definition">¶</a></dt>
<dd><p>It is possible to have a vertical line on a profile (different h, identical x). This is not possible for HABBY and
the 2D grid. So this function correct duplicates along the profile.</p>
<p>A similiar function exists in mascaret, for the case where the input is the distance along the profile and not
(x,y) coordinates. This function is inspired by <a class="reference external" href="https://www.peterbe.com/plog/uniqifiers-benchmark">https://www.peterbe.com/plog/uniqifiers-benchmark</a>.</p>
<p>It should be tested more as manage_grid sometime still send warning about duplicate data in profile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>seq3D</strong> &#8211; the list to be corrected in this case (x,y,z,dist along the profile)</li>
<li><strong>send_warn</strong> &#8211; a bool to avoid printing the warning too many time</li>
<li><strong>idfun</strong> &#8211; support an optional transform function (not tested)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the list wihtout duplicate and the boolean which helps manage the warnings</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.figure_rubar1d">
<code class="descclassname">src.rubar.</code><code class="descname">figure_rubar1d</code><span class="sig-paren">(</span><em>coord_pro, lim_riv, data_xhzv, name_profile, path_im, pro, plot_timestep, nb_pro_reach=[0, 10000000000]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.figure_rubar1d" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to plot the loaded RUBAR 1D data (Rubar BE).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coord_pro</strong> &#8211; the coordinate of the profile (x, y, z, dist along the river)</li>
<li><strong>lim_riv</strong> &#8211; the right bank, river center, left bank</li>
<li><strong>data_xhzv</strong> &#8211; the data by time step with x the distance along the river, h the water height and v the vlocity</li>
<li><strong>cote</strong> &#8211; the altitude of the river center</li>
<li><strong>name_profile</strong> &#8211; the name of the profile</li>
<li><strong>path_im</strong> &#8211; the path where to save the image</li>
<li><strong>pro</strong> &#8211; the profile number which should be plotted</li>
<li><strong>plot_timestep</strong> &#8211; which timestep should be plotted</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">none</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.figure_rubar2d">
<code class="descclassname">src.rubar.</code><code class="descname">figure_rubar2d</code><span class="sig-paren">(</span><em>xy, coord_c, ikle, v, h, path_im, time_step=[-1]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.figure_rubar2d" title="Permalink to this definition">¶</a></dt>
<dd><p>This functions plots the rubar 2d data. This function is only used to debug. It is not used direclty by Habby.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>xy</strong> &#8211; coordinates of the points</li>
<li><strong>coord_c</strong> &#8211; the center of the point</li>
<li><strong>ikle</strong> &#8211; connectivity table</li>
<li><strong>v</strong> &#8211; speed</li>
<li><strong>h</strong> &#8211; height</li>
<li><strong>path_im</strong> &#8211; the path where to save the figure</li>
<li><strong>time_step</strong> &#8211; The time step which will be plotted</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.get_triangular_grid">
<code class="descclassname">src.rubar.</code><code class="descname">get_triangular_grid</code><span class="sig-paren">(</span><em>ikle</em>, <em>coord_c</em>, <em>xy</em>, <em>h</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.get_triangular_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>In Rubar, it is possible to have non-triangular cells. It is possible to have a grid composed of a mix
of pentagonal, 4-sided and triangualr cells. This function transform the &#8220;mixed&#8221; grid to a triangular grid. For this,
it uses the centroid of each cell with more than three side and it create a triangle by side (linked with the
center of the cell). A similar function exists in hec-ras2D.py, but, as there is only one reach in rubar
and because ikle is different in hec-ras, it was hard to marge both functions together.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ikle</strong> &#8211; the connectivity table (list)</li>
<li><strong>coord_c</strong> &#8211; the coordinate of the centroid of the cell (list)</li>
<li><strong>xy</strong> &#8211; the points of the grid (np.array)</li>
<li><strong>h</strong> &#8211; data on water height</li>
<li><strong>v</strong> &#8211; data on velocity</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the updated ikle, coord_c (the center of the cell , must be updated ) and xy (the grid coordinate)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_coord_1d">
<code class="descclassname">src.rubar.</code><code class="descname">load_coord_1d</code><span class="sig-paren">(</span><em>name_rbe</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_coord_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>the function to load the rbe file, which is an xml file. The gives the geometry of the river system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name_rbe</strong> &#8211; The name fo the rbe file (string)</li>
<li><strong>path</strong> &#8211; the path to this file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the coordinates of the profiles and the coordinates of the right bank, center of the river, left bank
(list of np.array with x,y,z coordinate), name of the profile (list of string), dist along the river (list of float)
number of cells (int)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_dat_2d">
<code class="descclassname">src.rubar.</code><code class="descname">load_dat_2d</code><span class="sig-paren">(</span><em>geofile</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_dat_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>This  function is used to load the geomtery info for the 2D case, using the .dat file
The .dat file has the same role than the .mai file but with more information (number of side and more
complicated connectivity table).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geofile</strong> &#8211; the .dat file which contain the connectivity table and the (x,y)</li>
<li><strong>path</strong> &#8211; the path to this file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">connectivity table, point coordinates, coordinates of the cell centers</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_data_1d">
<code class="descclassname">src.rubar.</code><code class="descname">load_data_1d</code><span class="sig-paren">(</span><em>name_data_vh</em>, <em>path</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_data_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the output data for Rubar BE (in 1D). The geometry data should be loaded before using this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name_data_vh</strong> &#8211; the name of the profile.ETUDE file (string)</li>
<li><strong>path</strong> &#8211; the path to this file</li>
<li><strong>x</strong> &#8211; the distance along the river (from the .geo file)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">data x, velocity height, cote for each time step (list of np.array), time step</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_mai_1d">
<code class="descclassname">src.rubar.</code><code class="descname">load_mai_1d</code><span class="sig-paren">(</span><em>mailfile</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_mai_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is not used anymore. It was used to load the coordinate of the 1D data. It might become useful again
in the case where we found a Rubar model with more than one reach (which we do not have yet).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mailfile</strong> &#8211; the name of the file which contain the (x,z) data</li>
<li><strong>path</strong> &#8211; the path to this file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">x of the river, np.array and the number of mail</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_mai_2d">
<code class="descclassname">src.rubar.</code><code class="descname">load_mai_2d</code><span class="sig-paren">(</span><em>geofile</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_mai_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to load the geomtery info for the 2D case when we use the .mai file. It would also be possible
to use the .dat file. In fact, it is advised to use the dat file when possible as there are more info in the .dat file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geofile</strong> &#8211; the .mai file which contain the connectivity table and the (x,y)</li>
<li><strong>path</strong> &#8211; the path to this file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">connectivity table, point coordinates, coordinates of the cell centers</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_rubar1d">
<code class="descclassname">src.rubar.</code><code class="descname">load_rubar1d</code><span class="sig-paren">(</span><em>geofile</em>, <em>data_vh</em>, <em>pathgeo</em>, <em>pathdata</em>, <em>path_im</em>, <em>savefig</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_rubar1d" title="Permalink to this definition">¶</a></dt>
<dd><p>the function to load the RUBAR BE data (in 1D).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geofile</strong> &#8211; the name of .rbe file which gives the coordinates of each profile (string)</li>
<li><strong>data_vh</strong> &#8211; the name of the profile.ETUDE file which contains the height and velocity data (string)</li>
<li><strong>pathgeo</strong> &#8211; the path to the geofile - string</li>
<li><strong>pathdata</strong> &#8211; the path to the data_vh file</li>
<li><strong>path_im</strong> &#8211; the file where to save the image</li>
<li><strong>savefig</strong> &#8211; a boolean. If True create and save the figure.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coordinates of the profile (x,y,z dist along the profile) coordinates (x,y) of the river and the bed,
data xhzv by time step where x is the distance along the river, h the water height, z the elevation of the bed
and v the velocity</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_rubar2d">
<code class="descclassname">src.rubar.</code><code class="descname">load_rubar2d</code><span class="sig-paren">(</span><em>geofile</em>, <em>tpsfile</em>, <em>pathgeo</em>, <em>pathtps</em>, <em>path_im</em>, <em>save_fig</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_rubar2d" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the function used to load the RUBAR data in 2D</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geofile</strong> &#8211; the name of the .mai or .dat file which contains the connectivity table and the coordinates (string)</li>
<li><strong>tpsfile</strong> &#8211; the name of the .tps file (string)</li>
<li><strong>pathgeo</strong> &#8211; path to the geo file (string)</li>
<li><strong>pathtps</strong> &#8211; path to the tps file which contains the outputs (string)</li>
<li><strong>path_im</strong> &#8211; the path where to save the figure (string)</li>
<li><strong>save_fig</strong> &#8211; a boolean indicating if the figures should be created or not</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">velocity and height at the center of the cells, the coordinate of the point of the cells,
the coordinates of the center of the cells and the connectivity table.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_tps_2d">
<code class="descclassname">src.rubar.</code><code class="descname">load_tps_2d</code><span class="sig-paren">(</span><em>tpsfile</em>, <em>path</em>, <em>nb_cell</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_tps_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to load the output data in the 2D rubar case. The geometry file (.mai or .dat) should be loaded before.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>tpsfile</strong> &#8211; the name of the file with the data for the 2d case</li>
<li><strong>path</strong> &#8211; the path to the tps file.</li>
<li><strong>nb_cell</strong> &#8211; the number of cell extracted from the .mai file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">v, h, timestep (all in list of np.array)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.m_file_load_coord_1d">
<code class="descclassname">src.rubar.</code><code class="descname">m_file_load_coord_1d</code><span class="sig-paren">(</span><em>geofile_name</em>, <em>pathgeo</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.m_file_load_coord_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the m.ETUDE file which is based on .st format from cemagref. When we use the M.ETUDE file
instead of the rbe file, more than one reach can be studied but the center and side of the river is not
indicated anymore.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geofile_name</strong> &#8211; The name to the m.ETUDE file (string)</li>
<li><strong>pathgeo</strong> &#8211; the path to this file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the coordinates of the profiles (list of np.array with x,y,z coordinate), name of the profile
(list of string), dist along the river (list of float), number of profile by reach</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.main">
<code class="descclassname">src.rubar.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module</p>
</dd></dl>

</div>
<div class="section" id="telemac">
<h2>Telemac<a class="headerlink" href="#telemac" title="Permalink to this headline">¶</a></h2>
<p>in src/selafin_habby1.py</p>
<p>This module contains the functions used to load the Telemac data.</p>
<span class="target" id="module-src.selafin_habby1"></span><dl class="class">
<dt id="src.selafin_habby1.Selafin">
<em class="property">class </em><code class="descclassname">src.selafin_habby1.</code><code class="descname">Selafin</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin" title="Permalink to this definition">¶</a></dt>
<dd><p>Selafin file format reader for Telemac 2D. Create an object for reading data from a slf file.
Adapted from the original script &#8216;parserSELAFIN.py&#8217; from the open Telemac distribution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; the name of the binary Selafin file</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="src.selafin_habby1.Selafin.addcontent">
<code class="descname">addcontent</code><span class="sig-paren">(</span><em>fileName</em>, <em>times</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.addcontent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.appendcoretimeslf">
<code class="descname">appendcoretimeslf</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.appendcoretimeslf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.appendcorevarsslf">
<code class="descname">appendcorevarsslf</code><span class="sig-paren">(</span><em>varsor</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.appendcorevarsslf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.appendheaderslf">
<code class="descname">appendheaderslf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.appendheaderslf" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the header file</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.getheaderfloatsslf">
<code class="descname">getheaderfloatsslf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.getheaderfloatsslf" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the mesh coordinates</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.getheaderintegersslf">
<code class="descname">getheaderintegersslf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.getheaderintegersslf" title="Permalink to this definition">¶</a></dt>
<dd><p>Get dimensions and descritions (mesh)</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.getheadermetadataslf">
<code class="descname">getheadermetadataslf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.getheadermetadataslf" title="Permalink to this definition">¶</a></dt>
<dd><p>Get header information</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.gettimehistoryslf">
<code class="descname">gettimehistoryslf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.gettimehistoryslf" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the timesteps</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.getvalues">
<code class="descname">getvalues</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.getvalues" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the values for the variables at time t</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.getvariablesat">
<code class="descname">getvariablesat</code><span class="sig-paren">(</span><em>frame</em>, <em>varindexes</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.getvariablesat" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the values for the variables at a particular time step</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.putcontent">
<code class="descname">putcontent</code><span class="sig-paren">(</span><em>fileName</em>, <em>times</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.putcontent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="src.selafin_habby1.getendianfromchar">
<code class="descclassname">src.selafin_habby1.</code><code class="descname">getendianfromchar</code><span class="sig-paren">(</span><em>fileslf</em>, <em>nchar</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.getendianfromchar" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Get the endian encoding</dt>
<dd>&#8220;&lt;&#8221; means little-endian
&#8220;&gt;&#8221; means big-endian</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="src.selafin_habby1.getfloattypefromfloat">
<code class="descclassname">src.selafin_habby1.</code><code class="descname">getfloattypefromfloat</code><span class="sig-paren">(</span><em>fileslf</em>, <em>endian</em>, <em>nfloat</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.getfloattypefromfloat" title="Permalink to this definition">¶</a></dt>
<dd><p>Get float precision</p>
</dd></dl>

<dl class="function">
<dt id="src.selafin_habby1.load_telemac">
<code class="descclassname">src.selafin_habby1.</code><code class="descname">load_telemac</code><span class="sig-paren">(</span><em>namefilet</em>, <em>pathfilet</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.load_telemac" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which load the telemac data using the Selafin class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>namefilet</strong> &#8211; the name of the selafin file (string)</li>
<li><strong>pathfilet</strong> &#8211; the path to this file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the velocity, the height, the coordinate of the points of the grid, the connectivity table.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.selafin_habby1.plot_vel_h">
<code class="descclassname">src.selafin_habby1.</code><code class="descname">plot_vel_h</code><span class="sig-paren">(</span><em>coord_p2, h, v, path_im, timestep=[-1]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.plot_vel_h" title="Permalink to this definition">¶</a></dt>
<dd><p>a function to plot the velocity and height which are the output from TELEMAC. It is used to debug.
It is not used direclty by HABBY.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coord_p2</strong> &#8211; the coordinates of the point forming the grid</li>
<li><strong>h</strong> &#8211; the  water height</li>
<li><strong>v</strong> &#8211; the velocity</li>
<li><strong>path_im</strong> &#8211; the path where the image should be saved (string)</li>
<li><strong>timestep</strong> &#8211; which time step should be plotted</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="load-habby-hdf5-file">
<h2>Load HABBY hdf5 file<a class="headerlink" href="#load-habby-hdf5-file" title="Permalink to this headline">¶</a></h2>
<p>in src/load_hdf5.py</p>
<p>This module contains some functions to load and manage hdf5 input/outputs. This is still in progress.</p>
<span class="target" id="module-src.load_hdf5"></span><dl class="function">
<dt id="src.load_hdf5.get_all_filename">
<code class="descclassname">src.load_hdf5.</code><code class="descname">get_all_filename</code><span class="sig-paren">(</span><em>dirname</em>, <em>ext</em><span class="sig-paren">)</span><a class="headerlink" href="#src.load_hdf5.get_all_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets the name of all file with a particular extension in a folder. Useful to get all the output
from one hydraulic model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dirname</strong> &#8211; the path to the directory (string)</li>
<li><strong>ext</strong> &#8211; the extension (.txt for example). It is a string, the point needs to be the first character.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list with the filename (filename+dir) for each extension</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.load_hdf5.load_hdf5_hyd">
<code class="descclassname">src.load_hdf5.</code><code class="descname">load_hdf5_hyd</code><span class="sig-paren">(</span><em>hdf5_name_hyd</em><span class="sig-paren">)</span><a class="headerlink" href="#src.load_hdf5.load_hdf5_hyd" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to load the 2D hydrological data contains in the hdf5 file in the form required by HABBY.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hdf5_name_hyd</strong> &#8211; path and filename of the hdf5 file (string)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the connectivity table, the coordinates of the point, the height data, the velocity data on the coordinates.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.load_hdf5.load_hdf5_sub">
<code class="descclassname">src.load_hdf5.</code><code class="descname">load_hdf5_sub</code><span class="sig-paren">(</span><em>hdf5_name_sub</em><span class="sig-paren">)</span><a class="headerlink" href="#src.load_hdf5.load_hdf5_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to load the substrate data contained in the hdf5 file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hdf5_name_sub</strong> &#8211; path and file name to the hdf5 file (string)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.load_hdf5.open_hdf5">
<code class="descclassname">src.load_hdf5.</code><code class="descname">open_hdf5</code><span class="sig-paren">(</span><em>hdf5_name</em><span class="sig-paren">)</span><a class="headerlink" href="#src.load_hdf5.open_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function which open an hdf5 file and check that it exists. it does not load the data. It only opens the
files.
:param hdf5_name: the path and name of the hdf5 file (string)</p>
</dd></dl>

<div class="section" id="form-of-the-hdf5-files">
<h3>Form of the hdf5 files<a class="headerlink" href="#form-of-the-hdf5-files" title="Permalink to this headline">¶</a></h3>
<p>Here is the actual form of the hdf5 containing the 2D hydrological data.</p>
<ul class="simple">
<li>Number of timestep: Data_gen/Nb_timestep</li>
<li>Number of reach: Data_gen/Nb_reach</li>
<li>Connectivity table for the whole profile: Data_2D/Whole_Profile/Reach_&lt;r&gt;/ikle</li>
<li>Connectivity table for the wetted area (by time step): Data_2D/Timestep&lt;t&gt;/Reach_&lt;r&gt;/ikle</li>
<li>Coordinates for the whole profile: Data_2D/Whole_Profile/Reach_&lt;r&gt;/point_all</li>
<li>Coordinates for the wetted area (by time steps): Data_2D/Timestep&lt;t&gt;/Reach_&lt;r&gt;/point_all</li>
<li>Data for the velocity: Data_2D/Timestep&lt;t&gt;/Reach_&lt;r&gt;/inter_vel_all</li>
<li>Data for the height:  Data_2D/Timestep&lt;t&gt;/Reach_&lt;r&gt;/inter_h_all</li>
</ul>
<p>Here is the actual form of the hdf5 containing the substrate data.</p>
<ul class="simple">
<li>the coordinate of the point forming the substrate &#8220;grid&#8221;: coord_p_sub/</li>
<li>the connectivity table of the substrate &#8220;grid&#8221;: ikle_sub/</li>
<li>Substrate data; not done yet</li>
</ul>
</div>
</div>
<div class="section" id="velocity-distribution">
<h2>Velocity distribution<a class="headerlink" href="#velocity-distribution" title="Permalink to this headline">¶</a></h2>
<p>in src/dist_vitesse2.py</p>
<p>The goal of this list of function is to distribute the velocity along the cross-section
for 1D model such as mascaret or Rubar BE. Hec-Ras outputs do not need to uses this type
of function as they are already distributed along the profiles.</p>
<p>The method of velocity distribution in HABBY is similar to the one used by Hec-Ras to distribute
velocity.</p>
<span class="target" id="module-src.dist_vistess2"></span><dl class="function">
<dt id="src.dist_vistess2.dist_velocity_hecras">
<code class="descclassname">src.dist_vistess2.</code><code class="descname">dist_velocity_hecras</code><span class="sig-paren">(</span><em>coord_pro</em>, <em>xhzv_data_all</em>, <em>manning_pro</em>, <em>nb_point=-99</em>, <em>eng=1.0</em>, <em>on_profile=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.dist_vistess2.dist_velocity_hecras" title="Permalink to this definition">¶</a></dt>
<dd><p>This function distribute the velocity along the profile using the method from hec-ras
which is described in the hydraulic reference manual p 4-20 (Flow distribtion calculation)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coord_pro</strong> &#8211; the coordinates and elevation of the river bed for each profile (x,y, h, dist along the profile)
this list is flatten No reach info.</li>
<li><strong>xhzv_data_all</strong> &#8211; water height and velocity at each profile, 1D</li>
<li><strong>manning_pro</strong> &#8211; the manning coefficient for zone between point of each profile.
For a particular profile, the length of manning_pro is the length of coord_pro[0]</li>
<li><strong>nb_point</strong> &#8211; number of velocity points (-99 takes the number of measured elevation as the number of velocity points).</li>
<li><strong>eng</strong> &#8211; in case the output from hec-ras are in US unit (eng=1 for SI unit and 1.486 for US unit)</li>
<li><strong>on_profile</strong> &#8211; Mascaret also gives outputs in poitns between profile. on_profile is true if the results are
close or on the profile (les than 3cm of difference). This is not important for rubar or other models</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the velocity for each profile by time step (x,v)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comment and walk-through</strong></p>
<p>First, we decide on which point along the profile we will calculate the velocity. This is controlled by the
variable nb_point. If nb_point=-99, we will calculate the velocity at the same point than the profile (i.e., the
velocity will be calculated at each point on which the elevation of the profile was measured). There are cases where
this is not adequate. Let’s imagine for example a rectangular canal. The calculation would only give two velocity
points, which is not enough. So, it is possible to give the number of velocity point on which the calculation must
be made, using the variable nb_point.</p>
<p>Currently, the velocity points are determined by dividing the whole profile in nb_point segments. This means that
some velocity point are not used afterwards because they are in the dry part of the profile and that it is not
possible to select for a part of the profile where more velocity points would be calculated. This could be modified
in the future if it is judged necessary.</p>
<p>To determine the point where velocity should be calculated we need to get two array: one “x” array, the distance
along the profile and one “h” array, the elevation of the profile at this point. As we choose the position of the
velocity point as regularly placed along the profile, the “x” array is easy to determine using linespace. For the
“h” array, we use the hypothesis that the elevation of the profile changes linearly between the measured elevation
points. We find between which elevation point are the new point and we use a linear interpolation to find the new”h”.
To find between which points we are, we use the bisect.bisect function. It is a bit like the np.where function,
but it is quicker when the array is ordered (as it is the case here).</p>
<p>Then, we get the manning array as created by the get_manning_arr and the get_manning function. It should be a float.</p>
<p>Next, we cut the profile to keep only the part under water. For this, we do two things: First we had a point on the
profile where h==0. We should account for the fact that we might have  “islands” (part of the profile which are
dry, but surrounded by water on both side.). So we cannot only looked which part are dry, we need to look
for each point where we pass from “wet to dry” or from “dry to wet”. At this place, we add one point where h= 0.
For these new points water height is obviously known, but x (the distlance along profile) should be determined.
It is determined assuming a linear change between the measured points of the profile.</p>
<p>If the profile is not entirely dry, we will now distribute the velocity along the profile. First, for each part of
the profile where velocity will be calculated, it looks where is the higher height (like if this part of the profile
is going up or down). Next, we calculate the area, the wetted perimeter and the hydraulic radius of each part of the
profile. By combining this geometrical information with the manning parameter, we can calculate the conveyance
of each part of the profile. See manual of hec-ras p.4-20 for the conveyance definition.</p>
<p>We now calculate the conveyance of the whole profile. Normally, the sum of the conveyance of the part is higher
than the total conveyance. The next part of the script corrects for this, using the ratio of the total conveyance
and the sum of the parts of the conveyance. Next, we calculate the velocity using the modelled energy slope (Sf)
and the manning equation. We then then add a velocity of zero where there are no water (velocity is not defined
at his point).</p>
</dd></dl>

<dl class="function">
<dt id="src.dist_vistess2.get_manning">
<code class="descclassname">src.dist_vistess2.</code><code class="descname">get_manning</code><span class="sig-paren">(</span><em>manning1</em>, <em>nb_point</em>, <em>nb_profil</em>, <em>coord_pro</em><span class="sig-paren">)</span><a class="headerlink" href="#src.dist_vistess2.get_manning" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates an array with the manning value when a single float is given, so when the manning value
is a constant for the whole river.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>manning1</strong> &#8211; the manning value (can be a value or an array)</li>
<li><strong>nb_point</strong> &#8211; the number of velocity point by profile</li>
<li><strong>nb_profil</strong> &#8211; the number of profile</li>
<li><strong>coord_pro</strong> &#8211; necessary if the number is -99 as we need to know the length of each profile</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>The function dist_velcoity_hec_ras needs a manning array with a length equal to the number of profile, where each
row (representing a profile) have one value by velocity point which will be calculated. This function creates an
array of this form based on a float. It creates a list of manning value which is identical for each point of the
river. It can be used for the cases where the same number of point is asked for each profile or for the case where
the number of point is defined by the form of the profile (nb_point = -99).</p>
</dd></dl>

<dl class="function">
<dt id="src.dist_vistess2.get_manning_arr">
<code class="descclassname">src.dist_vistess2.</code><code class="descname">get_manning_arr</code><span class="sig-paren">(</span><em>manning_arr</em>, <em>nb_point</em>, <em>coord_pro</em><span class="sig-paren">)</span><a class="headerlink" href="#src.dist_vistess2.get_manning_arr" title="Permalink to this definition">¶</a></dt>
<dd><p>This function create the manning array when manning data is loaded using a text file. In this case, the manning
value do not needs to be a constant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>manning_arr</strong> &#8211; the data for manning</li>
<li><strong>nb_point</strong> &#8211; the number of velocity point by profile</li>
<li><strong>coord_pro</strong> &#8211; x,y,dist</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comment</strong></p>
<p>The user creates a txt file with a list of manning info. Each manning value is given the following way:
the profile, the distance along the profile and the manning value. One value by line in SI unit.</p>
<p>This function automatically fills the missing value, so that the user do not needs to give each manning value.
He can describe one profile and this profile will be replicated until the next profile written in the text file.</p>
</dd></dl>

<dl class="function">
<dt id="src.dist_vistess2.main">
<code class="descclassname">src.dist_vistess2.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.dist_vistess2.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module.</p>
</dd></dl>

<dl class="function">
<dt id="src.dist_vistess2.plot_dist_vit">
<code class="descclassname">src.dist_vistess2.</code><code class="descname">plot_dist_vit</code><span class="sig-paren">(</span><em>v_pro</em>, <em>coord_pro</em>, <em>xhzv_data</em>, <em>plot_timestep</em>, <em>pro</em>, <em>name_pro=[]</em>, <em>on_profile=[]</em>, <em>zone_v_all=[]</em>, <em>data_profile=[]</em>, <em>xy_h_all=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.dist_vistess2.plot_dist_vit" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to plot the distribution of velocity and the elevation of the profile. It is quite close to the
similar function which is in hec-ras (see this function for a more detailed explanation)</p>
<p>It can be used to test the program if we provide the variable zone_v_all where zone_v_all is an hec-ras output with a
velocity distribution. In this case, it would plot the comparison between the output from this script and the
output from hec-ras. Of course, for this, it is necessary to have prepared the 1D output from hec-ras
(using the function preparetest_velocity) and to have the same points on which to calculate the velocity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>v_pro</strong> &#8211; the calculated velcocity distribution by time step</li>
<li><strong>coord_pro</strong> &#8211; the coordinate of the profiles</li>
<li><strong>xhzv_data</strong> &#8211; the output data from the model, before the velocity distrbution</li>
<li><strong>plot_timestep</strong> &#8211; which time step to be plottied</li>
<li><strong>name_pro</strong> &#8211; the name of the profile (optionnal just for the title)</li>
<li><strong>pro</strong> &#8211; which porfile to be plotted</li>
<li><strong>on_profile</strong> &#8211; select the data which is on the profile</li>
<li><strong>zone_v</strong> &#8211; output from hec-ras used to test dist_vitesse</li>
<li><strong>data_profile</strong> &#8211; output from hec-ras used to test dist_vitesse</li>
<li><strong>xy_h</strong> &#8211; output from hec-ras used to test dist_vitesse</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.dist_vistess2.preparetest_velocity">
<code class="descclassname">src.dist_vistess2.</code><code class="descname">preparetest_velocity</code><span class="sig-paren">(</span><em>coord_pro</em>, <em>vh_pro_orr</em>, <em>v_in</em><span class="sig-paren">)</span><a class="headerlink" href="#src.dist_vistess2.preparetest_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a debugging function. It takes as input the output from the hec-ras model and gives a 1D velocity as
output. This is only to test this program. It will not be used by HABBY directly. To use this function, it is
necessary to use the function to load hec-ras data from HABBY, so that the hec-ras data is in the right form.
The 1D-velocity is assumed to be the velocity as the lowest part of the profile. This is where a 1D-model would
estimate the position of the river (the lowest part of the river bed).</p>
<p>A complicated point to test the program is to put the velocity point at the same point than hec-ras. As hec-ras
calculate velocity between zones and not on one point, this is more or less impossible to do with precision.
However, one can count the number of velocity zone and give this as an input to dist_velocity_hecras() for the
variable nb_point. However, both line will not be exactly at the same place. The results should however be close
enough.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coord_pro</strong> &#8211; the coordinate of the profile (x,y,h,dist along profile)</li>
<li><strong>vh_pro_orr</strong> &#8211; the velocity distribution which is the output from hec ras (produced by hec-ras06.py)</li>
<li><strong>v_in</strong> &#8211; the uni-dimensional velocity</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="create-a-grid">
<h2>Create a grid<a class="headerlink" href="#create-a-grid" title="Permalink to this headline">¶</a></h2>
<p>in src/manage_grid_8</p>
<p>This module is composed of the functions used to manage the grid,
notably to create 2D grid from the output from 1D model.</p>
<p>There are two main way to go from data in 1.5D in a profile form to a 2D grid:</p>
<ul class="simple">
<li>through the usage of the triangle module in create_grid().</li>
<li>through the definition of a middle profile used as a guide to create the grid in create_grid_only_one_profile().</li>
</ul>
<p>For an in-depth explanation on how to create the grids, please see the pdf document <a class="reference download internal" href="_downloads/Grid_info.pdf" download=""><code class="xref download docutils literal"><span class="pre">More</span> <span class="pre">info</span> <span class="pre">on</span> <span class="pre">the</span> <span class="pre">grid</span></code></a></p>
<span class="target" id="module-src.manage_grid_8"></span><dl class="function">
<dt id="src.manage_grid_8.add_point">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">add_point</code><span class="sig-paren">(</span><em>point_all</em>, <em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.add_point" title="Permalink to this definition">¶</a></dt>
<dd><p>To manage the substrate data, we modify the hydrological grid to avoid to have cells with two substrate type.
This function add one coordinate point to the list of coordinates which compose the hydrological grid. This point
is the intersection between one side of one triangluar cell of the hydrological grid and one side of the
sibstrate layer (which is a shp). It only adds this intersection point if it is not already in point_all.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>point_all</strong> &#8211; the coordinates of the hydrological grid</li>
<li><strong>point</strong> &#8211; one intersection point between substrat and hydrological grids</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the updated point_all (the coordinates of the hydrological grid)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.create_dummy_substrate">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">create_dummy_substrate</code><span class="sig-paren">(</span><em>coord_pro</em>, <em>sqrtnp</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.create_dummy_substrate" title="Permalink to this definition">¶</a></dt>
<dd><p>For testing purposes, it can be useful to create a substrate input even if one does not exist.
This substrate is compose of n triangle situated on the rivers in the same coodinates system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coord_pro</strong> &#8211; the coordinate of each profile</li>
<li><strong>sqrtnp</strong> &#8211; the number of point which will compose one side of the new substrate grid (so the total number
of point is sqrtnb squared).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">dummy coord_sub, ikle_sub</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.create_grid">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">create_grid</code><span class="sig-paren">(</span><em>coord_pro, extra_pro, coord_sub, ikle_sub, nb_pro_reach=[0, 10000000000.0], vh_pro_t=[], q=[], pnew_add=1</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.create_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>It creates a grid from the coord_pro data using the triangle module.
It creates the grid up to the end of the profile if vh_pro_t is not present
or up to the water limit if vh_pro_t is present</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>q</strong> &#8211; used in the secondary process (like in hydro_gui2) when we do not call this function direclty, but we
call it in a second process so that the GUI do not crash if something go wrong</li>
<li><strong>coord_pro</strong> &#8211; the profile coordinates (x,y, h, dist along) the profile</li>
<li><strong>extra_pro</strong> &#8211; the number of &#8220;extra&#8221; profiles to be added between profile to simplify the grid</li>
<li><strong>coord_sub</strong> &#8211; (not used anymore)
the coordinate of the point forming the substrate layer (often created with substrate.load_sub)</li>
<li><strong>ikle_sub</strong> &#8211; (not used anymore)
the connectivity table of the substrate grid (often created with substrate.load_sub)</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of reach by profile starting with 0</li>
<li><strong>vh_pro_t</strong> &#8211; the velocity and height of the water (used to cut the limit of the river).</li>
<li><strong>pnew_add</strong> &#8211; (not used anymore) a parameter to cut the substrate side in smaller part (improve grid quality)
in the form dist along profile, h , v for the analyzed time step. f not given, gird is contructed on the whole profile.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">connectivity table and grid point</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Form of the function in summary</strong></p>
<ul class="simple">
<li>if vh_pro_t:<ul>
<li>find cordinate under water and used this to update coord_pro</li>
<li>see if there is islands, find the island limits and the holes indicating the inside/outside of the islands</li>
</ul>
</li>
<li>find the point which give the end/start of the segment defining the grid limit</li>
<li>find all point which need to be added to the grid and add extra profile if needed</li>
<li>based on the start/end points and the island limits, create the segments which gives the grid limit</li>
<li>triangulate and so create the grid</li>
<li>flag point which are overlapping in two grids</li>
</ul>
<p>For more info, see the document &#8220;More info on the grid&#8221;.</p>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.create_grid_only_1_profile">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">create_grid_only_1_profile</code><span class="sig-paren">(</span><em>coord_pro, nb_pro_reach=[0, 10000000000.0], vh_pro_t=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.create_grid_only_1_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates the grid from the coord_pro data using one additional profil in the middle. No triangulation.
The interpolation of the data is done in this function also, contrarily to create_grid().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coord_pro</strong> &#8211; the profile coordinates (x,y, h, dist along) the profile</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach</li>
<li><strong>vh_pro_t</strong> &#8211; the data with heigh and velocity, giving the river limits</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the connevtivity table, the coordinate of the grid, the centroid of the grid, the velocity data on this
grid, the height data on this grid.</p>
</td>
</tr>
</tbody>
</table>
<p>For more info on this function, see the document &#8220;More info on the grid&#8221;.</p>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.cut_2d_grid">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">cut_2d_grid</code><span class="sig-paren">(</span><em>ikle</em>, <em>point_all</em>, <em>water_height</em>, <em>velocity</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.cut_2d_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>This function cut the grid of the 2D model to have correct wet surface. If we have a node with h&lt;0 and other node(s)
with h&gt;0, this function cut the cells to find the wetted perimeter, assuminga linear decrease in the water elevation.
This function works for one time steps and for one reach</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ikle</strong> &#8211; the connectivity table of the 2D grid</li>
<li><strong>point_all</strong> &#8211; the coordinate of the point</li>
<li><strong>water_height</strong> &#8211; the water height data given on the nodes</li>
<li><strong>velocity</strong> &#8211; the velcoity given on the nodes</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the update connectivity table, the coodinate of the point, the height of the water and the velocity on the updated grid</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.find_profile_between">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">find_profile_between</code><span class="sig-paren">(</span><em>coord_pro_p0</em>, <em>coord_pro_p1</em>, <em>nb_pro</em>, <em>trim=True</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.find_profile_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Find n profile between two profiles which are not straight. This functions is useful to create the grid from 1D model
as profile in 1D model are often far away from another.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coord_pro_p0</strong> &#8211; the coord_pro (x,y,h, z) of the first profile</li>
<li><strong>coord_pro_p1</strong> &#8211; the coord_pro (x,y,h, z) of the second profile</li>
<li><strong>nb_pro</strong> &#8211; the number of profile to add</li>
<li><strong>trim</strong> &#8211; If True cut the end and start of profile to avoid to have part of the grid outside of the water limit</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list with the updated profiles</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.get_crossing_segment_sub">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">get_crossing_segment_sub</code><span class="sig-paren">(</span><em>p1sub, p2sub, lim_here, lim_by_reachr, point_all, island, ind_seg_sub_ini=[0]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.get_crossing_segment_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>This function looks at one substrate segment and find the crossing points of this semgent with the different
segment which composed the hydrological grid. This function is useful to cut the grid as a function of the form
of the substrate layer (to avoid having cells in the hydrological grid which have two substrate value).</p>
<p>If island switch is True, lim_here is the limit of the island, so
inside the polygon is outside the river. If island is false, lim_here is the limit of the reach under investigation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p1sub</strong> &#8211; the start point of the substrate semgent</li>
<li><strong>p2sub</strong> &#8211; the end point of the substrate segment</li>
<li><strong>lim_here</strong> &#8211; the reach?island limit given in the coordinate system</li>
<li><strong>lim_by_reachr</strong> &#8211; the limits for reach r which will be given to triangle given by point_all indices.</li>
<li><strong>point_all</strong> &#8211; all the point (ccordinates) which will be given to triangle</li>
<li><strong>island</strong> &#8211; a boolean indicating if we are on an island or not</li>
<li><strong>ind_seg_sub_ini</strong> &#8211; the indices of the first segment add by p1sub et p2sub by the reach. Only used island = true</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the updated point_all and lim_by_reach</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.get_new_point_and_cell_1_profil">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">get_new_point_and_cell_1_profil</code><span class="sig-paren">(</span><em>coord_pro_p</em>, <em>vh_pro_t_p</em>, <em>point_mid_x</em>, <em>point_mid_y</em>, <em>point_all</em>, <em>ikle</em>, <em>point_c</em>, <em>dir</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.get_new_point_and_cell_1_profil" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is use by create_grid_one_profile. It creates the grid for one profile (one &#8220;line&#8221; of triangle).
To create the whole grod this function is called for each profile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coord_pro_p</strong> &#8211; the coordinates of the profile</li>
<li><strong>vh_pro_t_p</strong> &#8211; the height and velocity data of the profile analysed</li>
<li><strong>point_mid_x</strong> &#8211; the x coodinate of the points forming the middle profile</li>
<li><strong>point_mid_y</strong> &#8211; the y coordinate of the points forming the middle profile</li>
<li><strong>point_all</strong> &#8211; the point of the grid</li>
<li><strong>ikle</strong> &#8211; the connectivity table of the grid</li>
<li><strong>point_c</strong> &#8211; the central point of each cell</li>
<li><strong>dir</strong> &#8211; in which direction are we going around the profile (upstream/downstram)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">point_all, ikle, point_c (the centroid of the cell)</p>
</td>
</tr>
</tbody>
</table>
<p>For more info, see the document &#8220;More info on the grid&#8221;.</p>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.inside_polygon">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">inside_polygon</code><span class="sig-paren">(</span><em>seg_poly</em>, <em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.inside_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>This function find if a point is inside a polygon, using a ray casting algorythm. It is called by various functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>seg_poly</strong> &#8211; the segmentS forming the polygon</li>
<li><strong>point</strong> &#8211; the point which is indide or outside the polygon</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True is the point is inside the polygon, false otherwise</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.interp_weights">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">interp_weights</code><span class="sig-paren">(</span><em>xyz</em>, <em>uvw</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.interp_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>This fucntion is used by the function pass_grid_cell_to_node_lin(). To optimize the interpolation when more than one time step
is done on the same grid, the first step of scipy.griddata.interolate are done here and are called only once for all
time step. Hence, this function is the first part of a quicker &#8220;scipy.interpolate.griddata&#8221;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>xyz</strong> &#8211; </li>
<li><strong>uvw</strong> &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.interpo_linear">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">interpo_linear</code><span class="sig-paren">(</span><em>point_all</em>, <em>coord_pro</em>, <em>vh_pro_t</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.interpo_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Using scipy.gridata, this function interpolates the 1.5 D velocity and height to the new grid
It can be used for only one time step. The interpolation is linear.
It is usually called after create_grid have been called.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>point_all</strong> &#8211; the coordinate of the grid point</li>
<li><strong>coord_pro</strong> &#8211; the coordinate of the profile. It should be coherent with the coordinate from vh_pro.
To insure this, pass coord_pro through the function &#8220;create_grid&#8221; with the same vh_pro as input</li>
<li><strong>vh_pro_t</strong> &#8211; for each profile, dist along the profile, water height and velocity at a particular time step</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the new interpolated data for velocity and water height</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.interpo_nearest">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">interpo_nearest</code><span class="sig-paren">(</span><em>point_all</em>, <em>coord_pro</em>, <em>vh_pro_t</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.interpo_nearest" title="Permalink to this definition">¶</a></dt>
<dd><p>Using scipy.gridata, this function interpolates the 1.5 D velocity and height to the new grid
It can be used for only one time step. The interpolation is nearest neighbours.
It is usually called after create_grid have been called.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>point_all</strong> &#8211; the coordinate of the grid point</li>
<li><strong>coord_pro</strong> &#8211; the coordinate of the profile. It should be coherent with the coordinate from vh_pro.
To insure this, pass coord_pro through the function &#8220;create_grid&#8221; with the same vh_pro as input</li>
<li><strong>vh_pro_t</strong> &#8211; for each profile, dist along the profile, water height and velocity at a particular time step</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the new interpolated data for velocity and water height</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.interpolate_opti">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">interpolate_opti</code><span class="sig-paren">(</span><em>values</em>, <em>vtx</em>, <em>wts</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.interpolate_opti" title="Permalink to this definition">¶</a></dt>
<dd><p>This fucntion is called by interp_weights(). It is used in the optimization of the function pass_grid_cell_to_node_lin().
This idea of this optimization is to not re-do some calculation when many interpolation are done on the same grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>values</strong> &#8211; </li>
<li><strong>vtx</strong> &#8211; </li>
<li><strong>wts</strong> &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.intersection_seg">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">intersection_seg</code><span class="sig-paren">(</span><em>p1hyd</em>, <em>p2hyd</em>, <em>p1sub</em>, <em>p2sub</em>, <em>col=True</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.intersection_seg" title="Permalink to this definition">¶</a></dt>
<dd><p>This function finds if there is an intersection between two segment (AB and CD). Idea from :
<a class="reference external" href="http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect">http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect</a>
It is based on the caluclaion of the cross-product z= 0 for 2D</p>
<p>Careful there is many function using this function, so change here should be thought about.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p1hyd</strong> &#8211; point A</li>
<li><strong>p2hyd</strong> &#8211; point B</li>
<li><strong>p1sub</strong> &#8211; point C</li>
<li><strong>p2sub</strong> &#8211; point D</li>
<li><strong>col</strong> &#8211; if True, colinear segment crossed. If false, they do not cross</li>
<li><strong>uncer</strong> &#8211; if True, two segment with a distance lower than 10**-8 will be crossing, otherwise no precision change.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">intersect (True or False) and the crossing point (if True, empty is False)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.linear_h_cross">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">linear_h_cross</code><span class="sig-paren">(</span><em>p1</em>, <em>p2</em>, <em>h1</em>, <em>h2</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.linear_h_cross" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is called by cut_2D_grid. It find the intersection point along a side of the triangle if part of a
cells is dry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p1</strong> &#8211; the coordinate (x,y) of the first point</li>
<li><strong>p2</strong> &#8211; the coordinate (x,y) of the first point</li>
<li><strong>h1</strong> &#8211; the water height at p1 (might be negative or positive)</li>
<li><strong>h2</strong> &#8211; the water height at p2 (might be negative or positive)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the intersection point</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.main">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module</p>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.newp">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">newp</code><span class="sig-paren">(</span><em>p0</em>, <em>p1</em>, <em>extra_pro</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.newp" title="Permalink to this definition">¶</a></dt>
<dd><p>This function find the start/end of the added profile. If only one profile is needed, it is just the
point in the middle of the start/end of the profile. If mroe than one profile is needed, there are linearly
distributed. This function only give the start and the end of the profile, the profile in full are constructed using
find_profile_between()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p0</strong> &#8211; the point at the profile p</li>
<li><strong>p1</strong> &#8211; the point at the profile p-1</li>
<li><strong>extra_pro</strong> &#8211; the number of extra profile needed</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the start/end of the new profile</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.pass_grid_cell_to_node_lin">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">pass_grid_cell_to_node_lin</code><span class="sig-paren">(</span><em>point_all</em>, <em>coord_c</em>, <em>vel_in</em>, <em>height_in</em>, <em>warn1=True</em>, <em>vtx_all=[]</em>, <em>wts_all=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.pass_grid_cell_to_node_lin" title="Permalink to this definition">¶</a></dt>
<dd><p>HABBY uses nodal information. Some hydraulic models have only ouput on the cells. This function pass
from cells information to nodal information. The interpolation is linear and the cell centroid is used as the
point where the cell information is carried. It can be used for one time step only.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>point_all</strong> &#8211; the coordinates of grid points (new grid here)</li>
<li><strong>coord_c</strong> &#8211; the coordintesof the centroid of the cells (old grid here)</li>
<li><strong>vel_in</strong> &#8211; the velocity data by cell</li>
<li><strong>height_in</strong> &#8211; the height data by cell</li>
<li><strong>warn1</strong> &#8211; if True , show the warning (usually warn1 is True for t=0, False afterwards)</li>
<li><strong>vtx_all</strong> &#8211; if it exists it means than the same grid was interpolated before. This info can be reused to
speed up the interpolation of mulitple time step. (optional, need wts)</li>
<li><strong>wts_all</strong> &#8211; if it exists it means than the same grid was interpolated before. This info can be reused to
speed up the interpolation of mulitple time step. (optional, need vtx)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">velocity and height data by node</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical Comment</strong></p>
<dl class="docutils">
<dt>This function can be very slow when a lot of time step needs to be interpolated if done directlty with</dt>
<dd>scipy.interpolate. It was optimized for this case:</dd>
</dl>
<p><a class="reference external" href="http://stackoverflow.com/questions/20915502/speedup-scipy-griddata-for-multiple">http://stackoverflow.com/questions/20915502/speedup-scipy-griddata-for-multiple</a>-
interpolations-between-two-irregular-grids</p>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.plot_grid">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">plot_grid</code><span class="sig-paren">(</span><em>point_all_reach</em>, <em>ikle_all</em>, <em>lim_by_reach</em>, <em>hole_all</em>, <em>overlap</em>, <em>point_c_all=[]</em>, <em>inter_vel_all=[]</em>, <em>inter_h_all=[]</em>, <em>path_im=[]</em>, <em>coord_pro2=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.plot_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to plot a grid and the output. It is mosty used to debug the grid creation. Contrarily to the more
simple function plot_grid_simple, it is posible to plot the position of the holes (which indicates the dry area),
the limits of the reaches used by triangle, the overlap between two reaches, and so on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>point_all_reach</strong> &#8211; the grid point by reach</li>
<li><strong>ikle_all</strong> &#8211; the connectivity table by reach</li>
<li><strong>lim_by_reach</strong> &#8211; the segment giving the limits of the grid</li>
<li><strong>hole_all</strong> &#8211; the coordinates of the holes</li>
<li><strong>overlap</strong> &#8211; the point of each reach which are also on an other reach</li>
<li><strong>point_c_all</strong> &#8211; the centroid of each element</li>
<li><strong>inter_vel_all</strong> &#8211; the interpolated velocity for each reach</li>
<li><strong>inter_h_all</strong> &#8211; the interpolated height</li>
<li><strong>path_im</strong> &#8211; the path where to save the image</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.plot_grid_simple">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">plot_grid_simple</code><span class="sig-paren">(</span><em>point_all_reach</em>, <em>ikle_all</em>, <em>inter_vel_all=[]</em>, <em>inter_h_all=[]</em>, <em>path_im=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.plot_grid_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the function to plot grid output for one time step. The data is one the node. A more complicated function
exists to plot the grid and additional information (manage-grid_8.plot_grid()) in case there are needed to debug.
The present function only plot the grid and output without more information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>point_all_reach</strong> &#8211; the coordinate of the point. This is given by reaches.</li>
<li><strong>ikle_all</strong> &#8211; the connectivity table. This is given by reaches.</li>
<li><strong>inter_vel_all</strong> &#8211; the velcoity data. This is given by reaches.</li>
<li><strong>inter_h_all</strong> &#8211; the height data. This is given by reaches.</li>
<li><strong>path_im</strong> &#8211; the path where the figure should be saved</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.update_coord_pro_with_vh_pro">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">update_coord_pro_with_vh_pro</code><span class="sig-paren">(</span><em>coord_pro</em>, <em>vh_pro_t</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.update_coord_pro_with_vh_pro" title="Permalink to this definition">¶</a></dt>
<dd><p>The points describing the profile elevation and the points where velocity is measured might not be the same.
Additionally,part of the profile might be dry and we have added points giving the wetted limit in vh_pro_t. They were
are not in the original profil (coord_pro). In this function,
coord_pro is recalculated to account for these modicfications. It is used by create_grid() and
create_grid_one_profile, but only if vh_pro_t exists.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coord_pro</strong> &#8211; the original coord_pro</li>
<li><strong>vh_pro_t</strong> &#8211; the value and position of h and velcoity measurement with the river limits</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">updated coord_pro</p>
</td>
</tr>
</tbody>
</table>
<p>More information in the document &#8220;More info on the grid&#8221; (linked above)</p>
</dd></dl>

</div>
<div class="section" id="estimhab-source">
<h2>Estimhab -source<a class="headerlink" href="#estimhab-source" title="Permalink to this headline">¶</a></h2>
<p>in src/estimhab.py</p>
<p>The module contains the Estimhab model. For an explanation on the estimhab model, please see
the pdf document <a class="reference download internal" href="_downloads/estimhab2008.pdf" download=""><code class="xref download docutils literal"><span class="pre">estimhab2008</span></code></a></p>
<span class="target" id="module-src.estimhab"></span><dl class="function">
<dt id="src.estimhab.estimhab">
<code class="descclassname">src.estimhab.</code><code class="descname">estimhab</code><span class="sig-paren">(</span><em>qmes</em>, <em>width</em>, <em>height</em>, <em>q50</em>, <em>qrange</em>, <em>substrat</em>, <em>path_bio</em>, <em>fish_name</em>, <em>path_im</em>, <em>pict=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.estimhab.estimhab" title="Permalink to this definition">¶</a></dt>
<dd><p>This the function which forms the Estimhab model in HABBY. It is a reproduction in python of the excel file which
forms the original Estimhab model.. Unit in meter amd m^3/sec</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>qmes</strong> &#8211; the two measured discharge</li>
<li><strong>width</strong> &#8211; the two measured width</li>
<li><strong>height</strong> &#8211; the two measured height</li>
<li><strong>q50</strong> &#8211; the natural median discharge</li>
<li><strong>qrange</strong> &#8211; the range of discharge</li>
<li><strong>substrat</strong> &#8211; mean height of substrat</li>
<li><strong>pict</strong> &#8211; if true the figure is shown. If false, the figure is not shown</li>
<li><strong>path_im</strong> &#8211; the path where the image should be saved</li>
<li><strong>path_bio</strong> &#8211; the path to the xml file with the information on the fishes</li>
<li><strong>fish_name</strong> &#8211; the name of the fish which have to be analyzed</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">habitat value and useful surface (VH and SPU) as a function of discharge</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments and walk-through</strong></p>
<p>First, we get all the discharges on which we want to calculate the SPU (surface ponderée utile),
using the inputs from the user.</p>
<p>Next we use hydrological rating curves (info on google if needed) to get the height and the width of the river for
all discharge. The calculation is based on the width and height of the river measured at two discharges (given by the
user).</p>
<p>Next, we get other parameters which are used in the preference curves such as the Froude number of
the mean discharge or the Reynolds number.</p>
<p>Next, we load the fish data contains in the xml files in the biology folder. Careful, this is not the xml project
file. This are the xml files described above in the “Class EstimhabW” section. There are one xml file per fish and
they described the preference curves. For the argumentation on the form of the relationship, report yourself to the
documentation of Estimhab (one pdf file should in the folder “doc “ in HABBY).</p>
<p>Then, we calculate the habitat values (VH and SPU). Finally, we plot the results in a figure and we save it as
a text file.</p>
</dd></dl>

<dl class="function">
<dt id="src.estimhab.main">
<code class="descclassname">src.estimhab.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.estimhab.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module.</p>
</dd></dl>

<dl class="function">
<dt id="src.estimhab.pass_to_float_estimhab">
<code class="descclassname">src.estimhab.</code><code class="descname">pass_to_float_estimhab</code><span class="sig-paren">(</span><em>var_name</em>, <em>root</em><span class="sig-paren">)</span><a class="headerlink" href="#src.estimhab.pass_to_float_estimhab" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to pass from an xml element to a float</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>root</strong> &#8211; the root of the open xml file</li>
<li><strong>var_name</strong> &#8211; the name of the attribute in the xml file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the float data</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="stathab-source">
<h2>Stathab - source<a class="headerlink" href="#stathab-source" title="Permalink to this headline">¶</a></h2>
<p>in src/stathab_c</p>
<p>This module contains the function used to run the model stathab.For an explanation on
the form of the stathab input, please see the pdf document <a class="reference download internal" href="_downloads/stathabinfo.pdf" download=""><code class="xref download docutils literal"><span class="pre">stathabinfo</span></code></a></p>
<span class="target" id="module-src.stathab_c"></span><dl class="class">
<dt id="src.stathab_c.Stathab">
<em class="property">class </em><code class="descclassname">src.stathab_c.</code><code class="descname">Stathab</code><span class="sig-paren">(</span><em>name_prj</em>, <em>path_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab" title="Permalink to this definition">¶</a></dt>
<dd><p>The class for the Stathab model</p>
<dl class="method">
<dt id="src.stathab_c.Stathab.create_hdf5">
<code class="descname">create_hdf5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.create_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to create an hdf5 file from the loaded txt. It creates &#8220;name_prj&#8221;_STATHAB.h5, an hdf5 file with the
info from stathab</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.dengauss">
<code class="descname">dengauss</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.dengauss" title="Permalink to this definition">¶</a></dt>
<dd><p>gaussian density, used only for debugging purposes.
This is not used in Habby, but can be useful if scipy is not available (remplace all stat.norm.cdf with
dengauss)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> &#8211; the parameter of the gaussian</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the gaussian density</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.dist_h">
<code class="descname">dist_h</code><span class="sig-paren">(</span><em>sh0</em>, <em>h0</em>, <em>bornh</em>, <em>h</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.dist_h" title="Permalink to this definition">¶</a></dt>
<dd><p>The calculation of height distribution  acrros the river
The distribution is a mix of an exponential and guassian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sh0</strong> &#8211; the sh of the original data
sh is the parameter of the distribution, gives the relative importance of ganussian and exp distrbution</li>
<li><strong>h</strong> &#8211; the mean height data</li>
<li><strong>h0</strong> &#8211; the mean height</li>
<li><strong>bornh</strong> &#8211; the limits of each class of height</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">disth the distribution of heights across the river for the mean height h.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.dist_v">
<code class="descname">dist_v</code><span class="sig-paren">(</span><em>h</em>, <em>d</em>, <em>bornv</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.dist_v" title="Permalink to this definition">¶</a></dt>
<dd><p>The calculation of velocity distribution across the river
The distribution is a mix of an exponential and guassian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>h</strong> &#8211; the height which is related to the mean velocity v</li>
<li><strong>d</strong> &#8211; granulo moyenne</li>
<li><strong>bornv</strong> &#8211; the born of the velocity</li>
<li><strong>v</strong> &#8211; the mean velocity</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the distribution of velocity across the river</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.find_sh0">
<code class="descname">find_sh0</code><span class="sig-paren">(</span><em>disthmesr</em>, <em>h0</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.find_sh0" title="Permalink to this definition">¶</a></dt>
<dd><p>the function to find sh0, using a minimzation technique. Not used because the output was string.
Possibly an error on the bornes? We remplaced this function by the function find_sh0_maxvrais().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>disthmesr</strong> &#8211; the measured distribution of height</li>
<li><strong>h0</strong> &#8211; the measured mean height</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the optimized sh0</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.find_sh0_maxvrais">
<code class="descname">find_sh0_maxvrais</code><span class="sig-paren">(</span><em>disthmesr</em>, <em>h0</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.find_sh0_maxvrais" title="Permalink to this definition">¶</a></dt>
<dd><p>the function to find sh0, using the maximum of vraisemblance.
This function aims at reproducing the results from the c++ code. Hence, no use of scipy</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>disthmesr</strong> &#8211; the measured distribution of height</li>
<li><strong>h0</strong> &#8211; the measured mean height</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the optimized sh0</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.load_stathab_from_hdf5">
<code class="descname">load_stathab_from_hdf5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.load_stathab_from_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to load the file from an hdf5 whose name is given in the xml project file</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.load_stathab_from_txt">
<code class="descname">load_stathab_from_txt</code><span class="sig-paren">(</span><em>reachname_file</em>, <em>end_file_reach</em>, <em>name_file_allreach</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.load_stathab_from_txt" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to read and check the input from stathab based on the text files.
All files should be in the same folder.
The file Pref.txt is read in run_stathab.
If self.fish_chosen is not present, all fish in the preference file are read.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>reachname_file</strong> &#8211; the file with the name of the reaches to study (usually listirv.txt)</li>
<li><strong>end_file_reach</strong> &#8211; the ending of the files whose names depends on the reach</li>
<li><strong>name_file_allreach</strong> &#8211; the name of the file common to all reaches</li>
<li><strong>path</strong> &#8211; the path to the file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the inputs needed for run_stathab</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.power_law">
<code class="descname">power_law</code><span class="sig-paren">(</span><em>qwh_r</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.power_law" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to calculate power law for discharge and width
ln(h0 = a1 + a2 ln(Q)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>qwh_r</strong> &#8211; an array where each line in one observatino of Q, width and height</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the coeff of the regression</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.savefig_stahab">
<code class="descname">savefig_stahab</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.savefig_stahab" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to save the results in text and the figure</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.savetxt_stathab">
<code class="descname">savetxt_stathab</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.savetxt_stathab" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to save the stathab result in .txt form</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.stathab_calc">
<code class="descname">stathab_calc</code><span class="sig-paren">(</span><em>path_pref='.'</em>, <em>name_pref='Pref.txt'</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.stathab_calc" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to calculate stathab output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path_pref</strong> &#8211; the path to the preference file</li>
<li><strong>name_pref</strong> &#8211; the name of the preference file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the biological preferrence index (np.array of [reach, specices, nbclaq] size), surface or volume by class, etc.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.test_stathab">
<code class="descname">test_stathab</code><span class="sig-paren">(</span><em>path_ori</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.test_stathab" title="Permalink to this definition">¶</a></dt>
<dd><p>A short function to test part of the outputs against the C++ code,
It is not used in Habby but it is practical to debug.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path_ori</strong> &#8211; the path to the files from stathab based on the c++ code</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="src.stathab_c.load_float_stathab">
<code class="descclassname">src.stathab_c.</code><code class="descname">load_float_stathab</code><span class="sig-paren">(</span><em>filename</em>, <em>check_neg</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.load_float_stathab" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to load float with extra checks</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> &#8211; the file to load with the path</li>
<li><strong>check_neg</strong> &#8211; if true negative value are not allowed in the data</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">data if ok, -99 if failed</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.stathab_c.load_namereach">
<code class="descclassname">src.stathab_c.</code><code class="descname">load_namereach</code><span class="sig-paren">(</span><em>path</em>, <em>name_file_reach='listriv.txt'</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.load_namereach" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to only load the reach names (useful for the GUI)</p>
<p>:param path : the path to the file listriv.txt
:param name_file_reach: In case the file name is not listriv.txt
:return: the list of reach name</p>
</dd></dl>

<dl class="function">
<dt id="src.stathab_c.load_pref">
<code class="descclassname">src.stathab_c.</code><code class="descname">load_pref</code><span class="sig-paren">(</span><em>filepref</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.load_pref" title="Permalink to this definition">¶</a></dt>
<dd><p>The function loads the different pref coeffficient contained in filepref</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filepref</strong> &#8211; the name of the file (usually Pref.txt)</li>
<li><strong>path</strong> &#8211; the path to this file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the name of the fish, a np.array with the differen coeff</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.stathab_c.main">
<code class="descclassname">src.stathab_c.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.main" title="Permalink to this definition">¶</a></dt>
<dd><p>used to test this module.</p>
</dd></dl>

</div>
<div class="section" id="substrate">
<h2>Substrate<a class="headerlink" href="#substrate" title="Permalink to this headline">¶</a></h2>
<p>in src/substrate.py</p>
<p>This module contains the function to manage the substrate data. This is still a work in progress.</p>
<span class="target" id="module-src.substrate"></span><dl class="function">
<dt id="src.substrate.fig_merge_grid">
<code class="descclassname">src.substrate.</code><code class="descname">fig_merge_grid</code><span class="sig-paren">(</span><em>point_all_both_t</em>, <em>ikle_both_t</em>, <em>path_im</em>, <em>ikle_orr=[]</em>, <em>point_all_orr=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.fig_merge_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to plot the grid after it was merged with the substrate data.
It plots one time step at the time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>point_all_both_t</strong> &#8211; the coordinate of the points of the updated grid</li>
<li><strong>ikle_both_t</strong> &#8211; the connectivity table</li>
<li><strong>path_im</strong> &#8211; the path where the image should be saved</li>
<li><strong>ikle_orr</strong> &#8211; the orginial ikle</li>
<li><strong>point_all_orr</strong> &#8211; the orginal point_all</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.substrate.fig_substrate">
<code class="descclassname">src.substrate.</code><code class="descname">fig_substrate</code><span class="sig-paren">(</span><em>coord_p, ikle, sub_info, path_im, xtxt=[-99], ytxt=[-99], subtxt=[-99]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.fig_substrate" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to plot the raw substrate data, which was loaded before</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coord_p</strong> &#8211; the coordinate of the point</li>
<li><strong>ikle</strong> &#8211; the connectivity table</li>
<li><strong>sub_info</strong> &#8211; the information on subtrate by element</li>
<li><strong>xtxt</strong> &#8211; if the data was given in txt form, the orignal x data</li>
<li><strong>ytxt</strong> &#8211; if the data was given in txt form, the orignal y data</li>
<li><strong>subtxt</strong> &#8211; if the data was given in txt form, the orignal sub data</li>
<li><strong>path_im</strong> &#8211; the path where to save the figure</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.substrate.grid_update_sub2">
<code class="descclassname">src.substrate.</code><code class="descname">grid_update_sub2</code><span class="sig-paren">(</span><em>ikle</em>, <em>coord_p</em>, <em>point_crossing</em>, <em>coord_sub</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.grid_update_sub2" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to find the updated grid with the substrate. More complicated than grid_update3 because it tries to makes
new cell based on the lines linkes the centroid and the side of the trianlge. Looks more elegant at first but
quite complicated and do not work for all cases. So it is not used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ikle</strong> &#8211; the hydrological grid to be merge with the substrate grid</li>
<li><strong>coord_p</strong> &#8211; the coordinate of the point of the hydrological grid</li>
<li><strong>point_crossing</strong> &#8211; the crossing point, with the elemtn of the hydrological grid linked with it and the
direction (nx,ny) of the substrate line at this point</li>
<li><strong>coord_sub</strong> &#8211; the coordinate of the substrate, only useful to if the the substrate cut two time the samie of a
cell of the hydrological grid</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the new grid</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.substrate.grid_update_sub3">
<code class="descclassname">src.substrate.</code><code class="descname">grid_update_sub3</code><span class="sig-paren">(</span><em>ikle</em>, <em>coord_p</em>, <em>point_crossing</em>, <em>coord_sub</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.grid_update_sub3" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to update the grid after finding the crossing points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ikle</strong> &#8211; the hydrological grid to be merge with the substrate grid</li>
<li><strong>coord_p</strong> &#8211; the coordinate of the point of the hydrological grid</li>
<li><strong>point_crossing</strong> &#8211; the crossing point, with the elemtn of the hydrological grid linked with it and the
direction (nx,ny) of the substrate line at this point</li>
<li><strong>coord_sub</strong> &#8211; the coordinate of the substrate, only useful to if the the substrate cut two time the samie of a
cell of the hydrological grid</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the new grid</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.substrate.intersec_cross">
<code class="descclassname">src.substrate.</code><code class="descname">intersec_cross</code><span class="sig-paren">(</span><em>hyd1</em>, <em>hyd2</em>, <em>sub1</em>, <em>sub2</em>, <em>e=-99</em>, <em>nx=[]</em>, <em>ny=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.intersec_cross" title="Permalink to this definition">¶</a></dt>
<dd><p>A function function to calculate the intersection, segment are not parrallel,
used in case where we know that the intersection exists
Also save various info with the intersection (element, direction, etc.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>hyd1</strong> &#8211; the first hydrological point</li>
<li><strong>hyd2</strong> &#8211; the second</li>
<li><strong>sub1</strong> &#8211; the first substrate point</li>
<li><strong>sub2</strong> &#8211; the second</li>
<li><strong>e</strong> &#8211; the element of the hydrological grid (optional)</li>
<li><strong>nx</strong> &#8211; the direction of the cutting part of the substrate grid (x dir)</li>
<li><strong>ny</strong> &#8211; the direction of the cutting part of the substrate grid (y dir)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">intersection and the direction of cutting part.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.substrate.load_sub_shp">
<code class="descclassname">src.substrate.</code><code class="descname">load_sub_shp</code><span class="sig-paren">(</span><em>filename</em>, <em>path</em>, <em>name_att='SUBSTRATE'</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.load_sub_shp" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to load the substrate in form of shapefile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> &#8211; the name of the shapefile</li>
<li><strong>path</strong> &#8211; the path where the shapefile is</li>
<li><strong>name_att</strong> &#8211; the name of the substrate column in the attribute table</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">grid in form of list of coordinate and connectivity table (two list)
and an array with substrate type</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.substrate.load_sub_txt">
<code class="descclassname">src.substrate.</code><code class="descname">load_sub_txt</code><span class="sig-paren">(</span><em>filename</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.load_sub_txt" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to load the substrate in form of a text file. The text file must have 3 column x,y coordinate and
substrate info, no header or title. It is transform to a grid using a voronoi transformation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> &#8211; the name of the shapefile</li>
<li><strong>path</strong> &#8211; the path where the shapefile is</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">grid in form of list of coordinate and connectivity table (two list)
and an array with substrate type and (x,y,sub) of the orginal data</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.substrate.main">
<code class="descclassname">src.substrate.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module.</p>
</dd></dl>

<dl class="function">
<dt id="src.substrate.merge_grid_hydro_sub">
<code class="descclassname">src.substrate.</code><code class="descname">merge_grid_hydro_sub</code><span class="sig-paren">(</span><em>hdf5_name_hyd</em>, <em>hdf5_name_sub</em>, <em>default_data</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.merge_grid_hydro_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>After the data for the substrate and the hydrological data are loaded, they are still in different grids.
This functions will merge both grid together. This is done for all time step and all reaches</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>hdf5_name_hyd</strong> &#8211; the path and name of the hdf5 file with the hydrological data</li>
<li><strong>hdf5_name_sub</strong> &#8211; the path and the name of the hdf5 with the substrate data</li>
<li><strong>default_data</strong> &#8211; The substrate data given in the region of the hydrological grid where no substrate is given</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the connectivity table, the coordinates, the substrated data, the velocity and height data all in a merge form.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.substrate.point_cross2">
<code class="descclassname">src.substrate.</code><code class="descname">point_cross2</code><span class="sig-paren">(</span><em>ikle</em>, <em>coord_p</em>, <em>ikle_sub</em>, <em>coord_p_sub</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.point_cross2" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which find where the crossing points are. Crossing pitn are the points on the triangular side of the
hydrological grid which cross with a side of the substrate grid. The algo based on finding if points of one elements
are in the same polygon using a ray casting method</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ikle</strong> &#8211; the connectivity table for the hydrological data</li>
<li><strong>coord_p</strong> &#8211; the coordinates of the points of the hydrological grid</li>
<li><strong>ikle_sub</strong> &#8211; the connecity vity table of the substrate</li>
<li><strong>coord_p_sub</strong> &#8211; the coordinates of the points of the substrate grid</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">intersection</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.substrate.point_cross_bis">
<code class="descclassname">src.substrate.</code><code class="descname">point_cross_bis</code><span class="sig-paren">(</span><em>ikle</em>, <em>coord_p</em>, <em>ikle_sub</em>, <em>coord_p_sub</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.point_cross_bis" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which find where the crossing points are. Crossing pitn are the points on the triangular side of the
hydrological grid which cross with a side of the substrate grid. Easier than point_cross 2 but slow, so it is not used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ikle</strong> &#8211; the connectivity table for the hydrological data</li>
<li><strong>coord_p</strong> &#8211; the coordinates of the points of the hydrological grid</li>
<li><strong>ikle_sub</strong> &#8211; the connecity vity table of the substrate</li>
<li><strong>coord_p_sub</strong> &#8211; the coordinates of the points of the substrate grid</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">intersection</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="various-notes">
<h1>Various notes<a class="headerlink" href="#various-notes" title="Permalink to this headline">¶</a></h1>
<div class="section" id="translation-of-habby">
<h2>Translation of HABBY<a class="headerlink" href="#translation-of-habby" title="Permalink to this headline">¶</a></h2>
<p>In HABBY, it is possible to translate all strings which are in a python file (.py)
which is in the src_GUI folder. It should be possible to translate also strings which
are in a .py file which is in the .src folder if one modifies the .pro file,
but this is not done yet. Also, it might not be necessary because ./src contains
code which is not linked with the graphical interface. Hence, English might be sufficient here.</p>
<p>To add a new string to translate:</p>
<ul class="simple">
<li>Code as usual and write the string in English.</li>
<li>Add self.tr() around the string  a = Qlabel(self.tr(“My message”))</li>
<li>If the code is in a new python file (like the .py was just created), open the habby_trans.pro file which is src_GUI. Then add the line SOURCES+= new_file.py where new_file.py is the new python file.</li>
<li>If you want to add a new language, add the line TRANSLATIONS += Zen_ES.ts in the case you want to add Spanish or any other language.</li>
<li>Copy the files ZEN_EN.ts and ZEN_FR.ts from HABBY/translation to /src_GUI</li>
<li>In the src_GUI folder, run the following command on the cmd: pylupdate5 habby_trans.pro. it will work if pylupdate is installed.</li>
<li>It should update the .ts file (which is an xml file)</li>
<li>Copy both .ts file back to HABBY/translation</li>
<li>Open Qt  linguist. This is a program that you need to install before. Open the French .ts file. The English should not need translation.</li>
<li>Translate as needed and save in Qt Linguist.</li>
<li>A .qm file is the binary representing the .ts file with all the translation. To create .qm file, type (in the cmd) lrelease  file.ts. It will create a file.qm file</li>
<li>Run HABBY. The string should be updated.</li>
</ul>
<p><strong>In the code</strong></p>
<p>If the user asked for a new language, we need to reload the translator with the following lines:</p>
<blockquote>
<div><p><em>app = QApplication.instance()</em></p>
<p><em>self.languageTranslator.load(file.qm, self.path_trans)</em></p>
<p><em>app.installTranslator(self.languageTranslator)</em></p>
</div></blockquote>
<p>with the appropriate name for “file.qm”.</p>
<p>In HABBY, the list of the name of all qm file are in the variable self.file_langue
in class MainWindows. Hence, we can follow the selected language using an integer self.lang
(0 for English and 1 for French). We can now call self.file_langue[self.lang] to get the qm
file in the right language. If a new language is added, it is necessary to add one string to this
list and to modify the menu.</p>
<p>When the translator has been created, it is necessary to re-do all Widgets and Windows. This is not a problem when we open HABBY, but it can be a bit of work if the user asks for a change in language when HABBY is running. This is the function of the setlangue function. This function would work for all language (it takes an integer as input to know which language to use), but it needs to be modified if one modifies the Main_Windows Class strongly (notably if one add signals).
The language should be saved in the user setting using Qsettings as it is done at the end of the
setlangue function.</p>
</div>
<div class="section" id="create-a-exe">
<h2>Create a .exe<a class="headerlink" href="#create-a-exe" title="Permalink to this headline">¶</a></h2>
<p>Here are step to create a .exe using PyInstaller</p>
<ul class="simple">
<li>install Pyinstaller (pip install pyinstaller)</li>
<li>cd &#8220;folder with source code&#8221;</li>
<li>pyinstaller.exe [option] habby.py, with the option &#8211;onefile to get only one .exe and &#8211;windowed to not have the cmd which opens with the application.</li>
</ul>
<p>Here are some common problems:</p>
<ul class="simple">
<li>ImportError: (No module named &#8216;PyQt5.QtGui&#8217;): Copy the folder platform with qwindows.dll and add to the set_up.py  &#8220;includes&#8221;: [&#8220;PyQt5.QtCore&#8221;, &#8220;PyQt5.QtGui&#8221;]</li>
<li>This application fails to start because ... the Qt platform pugin windows: Copy the folder platform with qwindows.dll in it</li>
<li>ImportError: h5Py &#8220;includes&#8221;: [&#8220;h5py&#8221;,&#8221;h5py.defs&#8221;, &#8220;h5py.utils&#8221;, &#8220;h5py.h5ac&#8221;, &#8216;h5py._proxy&#8217; ] etc if necessary</li>
<li>Intel MKL fatal error copy the .dll missing (or just find an old dist and copy all mkl stuff) AND the libiomp5md.dll</li>
<li>The translation does not work: Add the translation folder into the dist folder</li>
<li>Do not find log0.txt (or crash when saving project): create a folder called src_GUI, copy the files log0.txt and restart_log0.txt from the src_GUI folder in the python module</li>
</ul>
</div>
<div class="section" id="logging">
<h2>Logging<a class="headerlink" href="#logging" title="Permalink to this headline">¶</a></h2>
<p><strong>General information</strong></p>
<p>There are two different logs for HABBY. By default, the first one is called “name_projet”.log and
the second is called restart/_&#8217;name_project&#8217;.log. Their name and path can be changed in the xml
project file. Both file are text file.</p>
<p>The first log is in the form of a python file with comments. If python and the necessary modules
are installed on the machine, this log can be renamed “name.py” and started as a python file.
In the command line, the following command should be used: python name.py. This file can be
modified to create a new script to use HABBY in a different ways. For this, python syntax should be used.</p>
<p>The second log, called restart/_’name_project’.log, has limited functionalities but allows to
re-start the HABBY simulation from the command line, without the need for python.
Format of this file is described below. It is aimed to be readable and easily modifiable.
To use the restart file, type in the command line: habby restart/_’name_project’.log. (not done yet)</p>
<p><strong>Type of log and format</strong></p>
<p>Currently, there are five types of outputs, which can be sent to the log:</p>
<ul class="simple">
<li>Comment, which should start with #. They will be sent to the python-type log file and to the GUI of Habby.</li>
<li>Errors, which should start with word “Error”. They will be sent to the python-type log file and to the GUI of Habby. In the GUI, they will appear in red.</li>
<li>Warnings, which should start with the word “Warning”. They will be sent to the python-type log file and to the GUI of Habby. In the GUI, they will appear in orange.</li>
<li>Restart info, which should start with the word “restart’. They will be sent to the restart_’name_project’.log. The format will be developed afterwards.</li>
<li>All types of text which do not start with these code words are only shown to the GUI of Habby.</li>
<li>Python code, which should start with the line py followed by four spaces.  It will be sent to the python-type log file. It is usually a function which is part of Habby code. The different arguments of the function should be given in the preceding lines.</li>
</ul>
<p><strong>Example</strong></p>
<p>Let’s write to the log a function which takes an integer and a string as input. The function
is in the module called habby1, which is imported by default in the .log file. The strings to send
as log would be:</p>
<ul class="simple">
<li>&#8220;#  this my fancy function&#8221;</li>
<li>&#8220;py    my_int = &#8221; + str(my_int_in_code)</li>
<li>&#8220;py    my_string = ’” + my_string_in_the _code+ &#8220;&#8217;“</li>
<li>&#8220;py    habby1.myfunc(my_int, my_string)&#8221;</li>
</ul>
<p>A comment should be added before each chunk of python code to improve the readability.</p>
<p><strong>Update the log</strong></p>
<p>Let’s consider a scenario where a new function has been written in a non-GUI module (class or
function) and has to be called in the GUI in a method of a class. Let’s call the new function
new_func and the class in the GUI my_class.</p>
<p>To create a new line of log for new_func, one should follow these steps:</p>
<ul class="simple">
<li>A PyQtsignal with a string as argument should be added to my_class: send_log = pyqtSignal(str, name=&#8217;send_log&#8217;)</li>
<li>If a log should be sent directly from my_class (for example, to say that new_func  has been called), the signal should be emitted: self.send_log.emit(&#8216;# new_func has been called&#8217;))</li>
<li>In the new function,  error and warning are written as follows: print(“Error: here is an error.n”) or print(“Warning:  This is just a warning.n”)</li>
<li>In my_class, error and warning are collected by redirecting stdout to a string. The following lines of code should be added around the calling of my_func():<ul>
<li>sys.stdout = mystdout = StringIO()  # redirect stdout</li>
<li>my_func(my_int,my_string)</li>
<li>sys.stdout = sys.__stdout__   # re-sent stdout to the cmd</li>
<li>str_found = mystdout.getvalue()   # get all warning, error, text,…</li>
<li>str_found = str_found.split(&#8216;n&#8217;)  # separate each message</li>
<li>for i in range(0, len(str_found)):<ul>
<li>if len(str_found[i]) &gt; 1:<ul>
<li>self.send_log.emit(str_found[i])  #send the text</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>To import StringIO, the following statement is needed at the start of the code: from io import StringIO</li>
<li>If new_func is called from the command line, stdout will not be redirected and the errors or warnings will be printed on the cmd as usual.  Stderr should be re-directed in a similar manner if needed.</li>
<li>The signal should be collected in the function connect_signal_log in the Main_Windows_1.py.  For this, a line should be added in the function:
*       self.my_class.send_log.connect(self.write_log)</li>
</ul>
<p><strong>Format of the restart file</strong></p>
<p>To be determined.</p>
</div>
<div class="section" id="git-code-management">
<h2>Git - code management<a class="headerlink" href="#git-code-management" title="Permalink to this headline">¶</a></h2>
<p><strong>Pour commencer:</strong></p>
<ul class="simple">
<li>Choisir un dossier sur l’ordinateur local ou va se trouver les fichiers sources.</li>
<li>cd  « dossier avec les codes source»</li>
<li>git config - - global user.name « username »</li>
<li>git config - - global user.email  « mail »</li>
<li>git init</li>
<li>lier le repertoire local avec le repertoire distant sur forge.irstea.fr</li>
</ul>
<p><strong>Pour mettre une nouvelle version sur le site web</strong></p>
<ul class="simple">
<li>cd « dossier avec les codes source»</li>
<li>git pull (prend la dernière version à jour sur le site et mets tous les fichiers ensemble) ou git fetch (prend juste les derniers fichiers sans mettre tous les fichiers ensemble).</li>
<li>git add ‘my_file.py ou .pyc’ (choisit les fichiers qui doivent être envoyé), le signe * fonctionne.</li>
<li>git log (donne l’historique)</li>
<li>git status (donne les nouveaux fichiers locals)</li>
<li>git commit –m « description » (commit localement)</li>
<li>git push</li>
</ul>
<p><strong>Pour ajouter une nouvelle branche</strong></p>
<ul class="simple">
<li>Donc pour avoir une partie du travail sépare du reste</li>
<li>git checkout –b [branchname] pour créer la branche et y travailler</li>
<li>git checkout [branchname] pour y travailler</li>
</ul>
</div>
<div class="section" id="write-the-documentation">
<h2>Write the documentation<a class="headerlink" href="#write-the-documentation" title="Permalink to this headline">¶</a></h2>
<p>Habby uses Sphinx to document the code. Sphinx uses the docstring given in each function. Hence, it is necessary to write a docstring for each function which has to be documented.</p>
<p>To update the html documentation, go to the doc folder and execute the command: “make html”.</p>
<p>To update the Latex documentation, use the commande &#8220;make latex&#8221; and use Miketex to create the pdf. rts2pdf does not work with Python 3.</p>
<p>To add text in the documentation, modify the index.rst file in the doc folder. To add a new module to the
documentation, add the module as written in the index.rts file in the doc folder. To add text comment, the index.rts file can also be direclty modified.</p>
<p>It is important to keep the formatting and the alignment.</p>
<p>If the module is in a new folder, the address of the folder must be added to the config.py file.
It is better to not use absolute path for this, so it is possible to move the documentation on another
computer. If the documentation does not run on a new computer, check the path given in the config.py file.</p>
<p>In the docstring, add as many blank lines as possible (in reasonable limit). This is easier for the
formatting. To make a bullet list, one should use a tab and the symbol “*”.  Using only the symbol * will
fail.</p>
<p>To add a new title, do not start the title or the line of symbol under the title with a blank space.</p>
</div>
<div class="section" id="license-of-used-python-modules">
<h2>License of used python modules<a class="headerlink" href="#license-of-used-python-modules" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>h5py: BSD License</li>
<li>Element tree (XML): MIT License</li>
<li>numpy: BSD License</li>
<li>matplotlib: BSD License</li>
<li>PyQt5: GNU License</li>
</ul>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Welcome to HABBY&#8217;s documentation!</a></li>
<li><a class="reference internal" href="#how-to-execute-habby">How to execute HABBY</a></li>
<li><a class="reference internal" href="#main-and-source-code">Main(   ) and source code</a></li>
<li><a class="reference internal" href="#graphical-interface">Graphical interface</a><ul>
<li><a class="reference internal" href="#main-windows-of-habby">Main_windows of HABBY</a></li>
<li><a class="reference internal" href="#hydrological-information-gui">Hydrological information - GUI</a></li>
<li><a class="reference internal" href="#figure-option-gui">Figure Option - GUI</a></li>
<li><a class="reference internal" href="#module-src_GUI.stathab_GUI">The Stathab model - GUI</a></li>
<li><a class="reference internal" href="#estimhab-gui">Estimhab - GUI</a><ul>
<li><a class="reference internal" href="#biological-data-estimhab">Biological data - Estimhab</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#calculation-of-fish-s-habitat">Calculation of fish&#8217;s habitat</a><ul>
<li><a class="reference internal" href="#hec-ras-model-1d">Hec-ras model 1D</a><ul>
<li><a class="reference internal" href="#notes-on-hec-ras-outputs">Notes on hec-ras outputs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hec-ras-model-2d">Hec-ras model 2D</a></li>
<li><a class="reference internal" href="#mascaret">Mascaret</a></li>
<li><a class="reference internal" href="#river-2d">River 2D</a></li>
<li><a class="reference internal" href="#rubar">Rubar</a></li>
<li><a class="reference internal" href="#telemac">Telemac</a></li>
<li><a class="reference internal" href="#load-habby-hdf5-file">Load HABBY hdf5 file</a><ul>
<li><a class="reference internal" href="#form-of-the-hdf5-files">Form of the hdf5 files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#velocity-distribution">Velocity distribution</a></li>
<li><a class="reference internal" href="#create-a-grid">Create a grid</a></li>
<li><a class="reference internal" href="#estimhab-source">Estimhab -source</a></li>
<li><a class="reference internal" href="#stathab-source">Stathab - source</a></li>
<li><a class="reference internal" href="#substrate">Substrate</a></li>
</ul>
</li>
<li><a class="reference internal" href="#various-notes">Various notes</a><ul>
<li><a class="reference internal" href="#translation-of-habby">Translation of HABBY</a></li>
<li><a class="reference internal" href="#create-a-exe">Create a .exe</a></li>
<li><a class="reference internal" href="#logging">Logging</a></li>
<li><a class="reference internal" href="#git-code-management">Git - code management</a></li>
<li><a class="reference internal" href="#write-the-documentation">Write the documentation</a></li>
<li><a class="reference internal" href="#license-of-used-python-modules">License of used python modules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">HABBY 1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Diane von Gunten, Yann Le Coarer and Fabrice Zaoui.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1.
    </div>
  </body>
</html>
