<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Welcome to HABBY’s documentation! &#8212; HABBY 1 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">HABBY 1 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="welcome-to-habby-s-documentation">
<h1>Welcome to HABBY&#8217;s documentation!<a class="headerlink" href="#welcome-to-habby-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<p>HABBY is a program to estimate the habitat of fish using various hydrological models and preference curve as input.</p>
</div>
<div class="section" id="how-to-execute-habby">
<h1>How to execute HABBY<a class="headerlink" href="#how-to-execute-habby" title="Permalink to this headline">¶</a></h1>
<dl class="docutils">
<dt>To execute HABBY:</dt>
<dd><ul class="first last simple">
<li>Go to folder which contains habby.py using the command line.</li>
<li>Open the command line and type python habby.py.</li>
</ul>
</dd>
</dl>
<p>The python version should be 3.4. HABBY should also function with most of the python 3 distributions.</p>
<p>If a module is missing, it is possible to install it using pip (&#8220;pip install -m <em>module_name</em>&#8221;). Obviously, pip needs to installed, which should be done by default in python 3.4. If you want to be sure to have the same version of the module than originally, go to the folder zen_file/wheele with the command line and install the missing module from there (something similar to &#8220;pip install -m <em>.whl</em>&#8221;). Not all modules are in this folder, only the ones which were difficult to install.</p>
</div>
<div class="section" id="main-and-source-code">
<h1>Main(   ) and source code<a class="headerlink" href="#main-and-source-code" title="Permalink to this headline">¶</a></h1>
<p>The source code is separated in two folders: one folder which contain the code source for the graphical user interface (GUI) and one folder for the rest of the code source.</p>
<p>The dependency between the different part of the source code can be visualized in the mindmap real_GUI.xmind (xmind should be installed).</p>
<p>The main of HABBY is habby.py. It has the usual form for an application using PyQt5.  The main() creates an application of QWidget and call the Main_Windows class, which we will discuss shortly. The last line closes the application.</p>
</div>
<div class="section" id="graphical-interface">
<h1>Graphical interface<a class="headerlink" href="#graphical-interface" title="Permalink to this headline">¶</a></h1>
<p>Here is the list of all modules contains in the src_GUI folder.</p>
<div class="section" id="main-windows-of-habby">
<h2>Main_windows of HABBY<a class="headerlink" href="#main-windows-of-habby" title="Permalink to this headline">¶</a></h2>
<p>in src_GUI/Main_Windows_1.py</p>
<span class="target" id="module-src_GUI"></span><span class="target" id="module-src_GUI.Main_windows_1"></span><dl class="class">
<dt id="src_GUI.Main_windows_1.CentralW">
<em class="property">class </em><code class="descclassname">src_GUI.Main_windows_1.</code><code class="descname">CentralW</code><span class="sig-paren">(</span><em>rech</em>, <em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW" title="Permalink to this definition">¶</a></dt>
<dd><p>This class create the different tabs of the programm, which are then used as the central widget by the class
MainWindows.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rech</strong> &#8211; A bollean which is True if the tabs for the &#8220;research option&#8221; are shown. False otherwise.</li>
<li><strong>path_prj</strong> &#8211; A string with the path to the project xml file</li>
<li><strong>name_prj</strong> &#8211; A string with the name of the project</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>In the attribute list, there are a series of name which finish by “tab” such as stathab_tab or output_tab. Each of
these names corresponds to one tab and a new name should be added to the attributes to add a new tab.</p>
<p>During the creation of the class, each tab is created. Then, the signals to show the figures are connected between this
class and all the children classes which need it (often this are the classes used to load the hydrological data). When a
class emits the signal “show_fig”, CentralW collect this signal and show the figure, using the showfig function.</p>
<p>Show_fig is mostly a “plt.show()”. To avoid problem between matplotlib and PyQt, it is however important that
matplotlib use the backend “Qt5Agg” in the .py where the “plt.plot” is called. Practically, this means modifying
the matplotlib import.</p>
<p>Showfig shows only one figure. To show all existing figures, one can call the function show_fig2 from the menu.
Show_fig2 call the instance child_win of the class ShowImageW to open a new Windows with all figure. However,
this would only show the figure without any option for the zoom.</p>
<p>Then we call a function which connects all the signals from each class which need to write into the log. It is a good
policy to create a “send_log” signal for each new important class. As there are a lot of signal to connect, these
connections are written in the function “connect_signal_log”, where the signal for a new class can be added.</p>
<p>When this is done, the info for the general tab (created before) is filled. If the user has opened a project in HABBY
before, the name of the project and the other info related to it will be shown on the general tab. If the general
tab is modified in the class WelcomeW(), this part of the code which fill the general tab will probably needs to
be modified.</p>
<p>Finally, each tab is filled. The tabs have been created before, but there were empty. Now we fill each one with the
adequate widget. This is the link with many of the other classes that we describe below. Indeed, many of the widget
are based on more complicated classes created for example in hydro_GUI_2.py.</p>
<p>Then, we create an area under it for the log. Here HABBY will write various infos for the user. Two things to note
here: a) we should show the end of the scroll area. b) The size of the area should be controlled and not be
changing even if a lot of text appears. Hence, the setSizePolicy should be fixed.</p>
<p>The write_log() and write_log_file() method are explained in the section about the log.</p>
<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.connect_signal_log">
<code class="descname">connect_signal_log</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.connect_signal_log" title="Permalink to this definition">¶</a></dt>
<dd><p>connect all the signal linked to the log. This is in a function only to improve lisibility.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to initilize an instance of CentralW. Called by __init___().</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.optfig">
<code class="descname">optfig</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.optfig" title="Permalink to this definition">¶</a></dt>
<dd><p>A small function which open the output tab. It contains the different options for the figures.
Output should be the 6th tab, otherwise it will not work.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.scrolldown">
<code class="descname">scrolldown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.scrolldown" title="Permalink to this definition">¶</a></dt>
<dd><p>Move the scroll bar to the bottow if the ScollArea is getting bigger</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.showfig">
<code class="descname">showfig</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.showfig" title="Permalink to this definition">¶</a></dt>
<dd><p>A small function to show the last figure</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.showfig2">
<code class="descname">showfig2</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.showfig2" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to see all saved figures without possibility to zoom</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.write_log">
<code class="descname">write_log</code><span class="sig-paren">(</span><em>text_log</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.write_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to write the different log. Please read the section of the doc on the log.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>text_log</strong> &#8211; the text which should be added to the log (a string)</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>if text_log start with # -&gt; added it to self.l2 (QLabel) and the .log file (comments)</li>
<li>if text_log start with restart -&gt; added it restart_nameproject.txt</li>
<li>if text_log start with WARNING -&gt; added it to self.l2 (QLabel) and the .log file</li>
<li>if text_log start with ERROR -&gt; added it to self.l2 (QLabel) and the .log file</li>
<li>if text_log start with py -&gt; added to the .log file (python command)</li>
<li>if text_log start with nothing -&gt; just print to the Qlabel</li>
<li>if text_log out from stdout -&gt; added it to self.l2 (QLabel) and the .log file (comments)</li>
</ul>
<p>if logon = false, do not write in log.txt</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.write_log_file">
<code class="descname">write_log_file</code><span class="sig-paren">(</span><em>text_log</em>, <em>pathname_logfile</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.write_log_file" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to write to the .log text. Called by write_log.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>text_log</strong> &#8211; the text to be written (string)</li>
<li><strong>pathname_logfile</strong> &#8211; the path+name where the log is</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.Main_windows_1.EmptyTab">
<em class="property">class </em><code class="descclassname">src_GUI.Main_windows_1.</code><code class="descname">EmptyTab</code><a class="headerlink" href="#src_GUI.Main_windows_1.EmptyTab" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is  used to fill empty tabs with something during the developement.
It will not be use in the final version.</p>
<dl class="method">
<dt id="src_GUI.Main_windows_1.EmptyTab.addtext">
<code class="descname">addtext</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.EmptyTab.addtext" title="Permalink to this definition">¶</a></dt>
<dd><p>This function print a string on the command line. This is useful if you need to check if a button (or similar).
is connected.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.EmptyTab.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.EmptyTab.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initialization.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.Main_windows_1.MainWindows">
<em class="property">class </em><code class="descclassname">src_GUI.Main_windows_1.</code><code class="descname">MainWindows</code><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows" title="Permalink to this definition">¶</a></dt>
<dd><p>The class MainWindows contains the menu and the title of all the HABBY windows.
It also create all the widgets which can be called during execution</p>
<p><strong>Technical comments and walk-through</strong></p>
<p>First, we load the user setting using Qsettings: The settings by default of Qsettings are the name of the program (HABBY) and
the name of the organization which develops the program (irstea).  I have added three user settings (the name of the
last project loaded into HABBY, the path to this project and the language used). The Qsetting are stored in the
registry in Windows. Qsettings also function with Apple and Linux even if the information is stored differently</p>
<p>We set up the translation next. The translation of HABBY in different language is explained in more detail in
the section “Translation of HABBY”. We give here the path to the data related to the translation. More precisely, we indicate
here the path to the translation data and the name of the qm file containing the data related to the translation
in each language. If a new qm is added for a new language, it should be added here to the list.</p>
<p>Now, two important attributes are defined: self.name_prj and self.path_prj. These attribute will be communicated to
children classes. For each project, an xml file is created. This “project” file should be called name_prj.xml
and should be situated in the path indicated by self.path_prj.</p>
<p>We call the central_widget which contains the different tabs.</p>
<p>We create the menu of HABBY calling the function my menu_bar().</p>
<p>Two signal are connected, one to save the project (i.e to update the xml project file) and another to save an
ESTIMHAB calculation.</p>
<p>We show the created widget.</p>
<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.clear_log">
<code class="descname">clear_log</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.clear_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the log in the GUI.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.closeEvent">
<code class="descname">closeEvent</code><span class="sig-paren">(</span><em>event</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.closeEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the program better than before (where it used to crash about 1 times in ten). It is not really clear why.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>event</strong> &#8211; managed by the operating system.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.close_rech">
<code class="descname">close_rech</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.close_rech" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the additional research menu (see open_rech for more information)</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.do_log">
<code class="descname">do_log</code><span class="sig-paren">(</span><em>save_log</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.do_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Save or not save the log</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>save_log</strong> &#8211; an int which indicates if the log should be saved or not</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>0: do not save log</li>
<li>1: save the log in the .log file and restart file</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.erase_pict">
<code class="descname">erase_pict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.erase_pict" title="Permalink to this definition">¶</a></dt>
<dd><p>All files contained in the folder indicated by path_im will be deleted.</p>
<p>From the menu of HABBY, it is possible to ask to erase all files in the folder indicated by path_im
(usually figure_HABBY). Of course, this is a bit dangerous. So the function asks the user for confirmation.
However, it is practical because you do not have to go to the folder to erase all the images when there
are too many of them.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.init_ui">
<code class="descname">init_ui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.init_ui" title="Permalink to this definition">¶</a></dt>
<dd><p>Used by __init__() to create an instance of the class MainWindows</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.my_menu_bar">
<code class="descname">my_menu_bar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.my_menu_bar" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates the menu bar of HABBY.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.open_rech">
<code class="descname">open_rech</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.open_rech" title="Permalink to this definition">¶</a></dt>
<dd><p>Open the additional research tab, which can be used to create Tab with more experimental contents.</p>
<p>Indeed, it is possible to show extra tab in HABBY. These supplementary tab correspond to open for researcher.
The plan is that these options are less tested than other mainstream options. It is not clear yet what
will be added to these options, but the basic architecture is there when it will be needed.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.save_project">
<code class="descname">save_project</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.save_project" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to save the xml file with the information on the project</p>
<p><strong>Technical comments</strong></p>
<p>This function saves or creates the xml file related to the projet. In this xml file, there are the path and
the name to all files related to the project, notably the hdf5 files containing the hydrological data.</p>
<p>To find or create the xml file, we use the attribute self.path_prj and self.name_proj. If the path to
the project directory is not found an error appears. The error is here sent though additional windows
(to be sure that the user notice this problem), using the Qmesssage module. The user should give the general
info about the project in the general tab of HABBY and they are collected here. User option (using Qsetting)
is next updated so that the user will find his project open the next time it opens HABBY.</p>
<p>When HABBY open, there are therefore  two choice: a) This is a new project b) the project exists already.
If the project is new, the xml file is created and general information is written in this file. In addition,
the text file which are necessary to log the action of HABBY are created now. This part of the reason why it
is not possible to run other part of HABBY (such as loading hydrological data) before a project is saved.
In addition, it would create a lot of problems on where to store the data created. Hence, a project is needed
before using HABBY. If the project exists already (i.e. the name and the path of the project have not been
modified), the xml file is just updated to change its attributes as needed.</p>
<p>Interesting path are a) the biologie path (named &#8220;biologie&#8221; by default) which contains the biological information
such as the preference curve and b) the path_im which is the path where all figures and most outputs of HABBY
is saved. If path_im is not given, HABBY automatically create a folder called figure_habby when the
user creates a new project. The user can however change this path if he wants. The next step is to communicate
to all the children widget than the name and path of the project have changed.</p>
<p>Finally the log is written (see “log and HABBY in the command line).</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.save_project_estimhab">
<code class="descname">save_project_estimhab</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.save_project_estimhab" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to save the information linked with Estimhab in an hdf5 file.</p>
<p><strong>Technical comments</strong></p>
<p>This function save the data and result from the estimhab calculation. It would look more logic if it was in
the esimhab.py script, but it was easier to call it from here instead of in the child class.</p>
<p>This function get all estimhab input, create an hdf5 file using h5py and save the data in the hdf5. One
specialty of hdf5 is that is cannot use Unicode. Hence all string have to be passed to ascii using the encode
function. The size of each data should also be known.</p>
<p>Finally, we save the name and path of the estimhab file in the xml project file.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.setlangue">
<code class="descname">setlangue</code><span class="sig-paren">(</span><em>nb_lang</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.setlangue" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which change the language of the programme. It change the menu and the central widget.
It uses the self.lang attribute which should be set to the new language before calling this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nb_lang</strong> &#8211; the number representing the language (int)</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>0 is for English</li>
<li>1 for French</li>
<li>n for any additionnal language</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.test_entry_float">
<code class="descname">test_entry_float</code><span class="sig-paren">(</span><em>var_in</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.test_entry_float" title="Permalink to this definition">¶</a></dt>
<dd><p>An utility function to test if var_in are float or not
the boolean self.does_it_work is used to know if the functions run until the end.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>var_in</strong> &#8211; the QlineEdit which contains the data (so var_in.text is a string)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the tested variable var_in</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.Main_windows_1.ShowImageW">
<em class="property">class </em><code class="descclassname">src_GUI.Main_windows_1.</code><code class="descname">ShowImageW</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.ShowImageW" title="Permalink to this definition">¶</a></dt>
<dd><p>The widget which shows the saved images. Used only to show all the saved figure together iwhtout zoom or other
options.</p>
<p><strong>Technical comments</strong></p>
<p>The ShowImageW() class is used to show all the figures created by HABBY. It is a class which can only be
called from the menu (In Option/Option Image). This is not the usual way of opening a figure which is usually done
by plt.show from matplotlib. This is the way to look at all figures  together, which can be useful, even if zooming
is not possible anymore.</p>
<p>To show all image, HABBY open a separate window and show the saved image in .png format.  Currently, the figures
shown are in .png, but other formats could be used. For this, one can change the variable self.imtype.</p>
<p>An important point for the ShowImageW  class  is where the images were saved by the functions which created them.
In HABBY, all figures are saved in the same folder called “path_im”. One “path_im” is chosen at the start of each
project. By default, it is the folder “Figure_Habby”, but the user can modify this folder in the window created by
ShowImageW(). The function for this is called “change_folder”, also in ShowImageW(). The path_im is written in
the xml project file. The different functions which create image read this path and send the figure created
to this folder. ShowImageW() reads all  figure of “.png” type in the” path_im” folder and show the most recent
figure. The user can use the drop-down menu to choose to see another figure. The names of the figure are added to
the drop-down menu in the function update_namefig. The function &#8220;selectionchange&#8221; changes the figure shown based
on the user action.</p>
<dl class="method">
<dt id="src_GUI.Main_windows_1.ShowImageW.change_folder">
<code class="descname">change_folder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.ShowImageW.change_folder" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to change the folder where are stored the image (i.e., the path_im)</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.ShowImageW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.ShowImageW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initialization.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.ShowImageW.selectionchange">
<code class="descname">selectionchange</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.ShowImageW.selectionchange" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to change the figure shown by ShowImageW()
:return:</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.Main_windows_1.ShowImageW.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.Main_windows_1.ShowImageW.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQt signal used to write the log</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.ShowImageW.update_namefig">
<code class="descname">update_namefig</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.ShowImageW.update_namefig" title="Permalink to this definition">¶</a></dt>
<dd><p>This function add the different figure name to the drop-down list.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.Main_windows_1.WelcomeW">
<em class="property">class </em><code class="descclassname">src_GUI.Main_windows_1.</code><code class="descname">WelcomeW</code><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW" title="Permalink to this definition">¶</a></dt>
<dd><p>The class WeLcomeW()  creates the first tab of HABBY (the tab called “General”). This tab is there to create
a new project or to change the name, path, etc. of a project.</p>
<dl class="method">
<dt id="src_GUI.Main_windows_1.WelcomeW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initialization of a new instance of the class WelcomeW()</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.Main_windows_1.WelcomeW.save_signal">
<code class="descname">save_signal</code><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW.save_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQt signal used to save the figure</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.Main_windows_1.WelcomeW.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQt signal used to write the log</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.WelcomeW.setfolder">
<code class="descname">setfolder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW.setfolder" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used by the user to select the folder where the xml project file will be located.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="src_GUI.Main_windows_1.new_project">
<code class="descclassname">src_GUI.Main_windows_1.</code><code class="descname">new_project</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.new_project" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="src_GUI.Main_windows_1.open_project">
<code class="descclassname">src_GUI.Main_windows_1.</code><code class="descname">open_project</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.open_project" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="hydrological-information-gui">
<h2>Hydrological information - GUI<a class="headerlink" href="#hydrological-information-gui" title="Permalink to this headline">¶</a></h2>
<p>in src_GUI/hydro_GUI_2.py</p>
<p>This python module contains the class which forms the hydrological tab in HABBY.
It contains the information for the graphical interface and make the link with the scripts
used for the hydrological calculations.</p>
<span class="target" id="module-src_GUI.hydro_GUI_2"></span><dl class="class">
<dt id="src_GUI.hydro_GUI_2.FreeSpace">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">FreeSpace</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.FreeSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">PyQt5.QtWidgets.QWidget</span></code></p>
<p>Simple class with empty space, just to have only Qwidget in the stack.</p>
<p><strong>Technical comment</strong></p>
<p>The idea of this class is that the user see a free space when it opens the “Hydro” Tab instead
of directly seeing one of the hydraulic model. The goal is to avoid the case where a user tries to load data before
selecting the real model. For example, if a user wants to load mascaret data and that an item is selected by
default in the stack of classes related to hydrology (such as HEC-RAS1D), it might be logical for the user to try
to load masacret data using the HEC-RAS class. Because of the FreeSpace class, he actually has to select
the model he wants to load.</p>
</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS1D">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">HEC_RAS1D</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class Hec_ras 1D is there to manage the link between the graphical interface and the functions in
src/hec_ras06.py which loads the hec-ras data in 1D. The class HEC_RAS1D inherits from SubHydroW() so it have all
the methods and the variables from the class ubHydroW(). The class hec-ras 1D is added to the self.stack of Hydro2W(). So the class Hec-Ras 1D is called when
the user is on the hydrological tab and click on hec-ras1D as hydrological model.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS1D.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS1D.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is called by __init__() durring the initialization.</p>
<p><strong>Technical comment</strong></p>
<p>The self.attributexml variable is the name of the attribute in the xml file. To load a hec-ras file, one needs
to give to HABBY one file containing the geometry data and one file containing the simulation result. The name
and path to  these two file are saved in the xml project file under the attribute given in
the self.attributexml variable.</p>
<p>The variable self.extension is a list of list of the accepted file type. The first list is for the file
with geometry data. The second list is the extension of the files containing the simulation results.</p>
<p>Using the function self.was_model_loaded_before, HABBY write the name of the hec-ras files which were loaded
in HABBY in the same project before.</p>
<p>Hec-Ras is a 1.5D model and so HABBY create a 2D grid based on the 1.5D input. The user can choose the interpolation
type and the number of extra profile. If the interpolation type is “interpolation by block”, the number of extra
profile will always be one. See manage_grid.py for more information on how to create a grid.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS1D.load_hec_ras_gui">
<code class="descname">load_hec_ras_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS1D.load_hec_ras_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to execute the loading and saving of the HEC-ras file using Hec_ras.py</p>
<p><strong>Technical comments</strong></p>
<p>This function is called when the user press on the button self.load_b. It is the function which really
calls the load function for hec_ras. First, it updates the xml project file. It adds the name of the new file
to xml project file under the attribute indicated by self.attributexml. It also gets the path_im by reading the
path_im in the xml project file. Then it check if the user want to create the figure or not
(if self.cb.isChecked(), figures should be created). It also manages the log as explained in the section
about the log. Notably, it redirects the  outstream to the mystdout stream. Hence, the “print” statement is
now sent to the log windows at the bottom of HABBY window. Next, it loads the hec-ras data as explained in
the section on hec_ras06.py. It then creates the grid as explained in the manage_grid.py based on the
interpolation type wished by the user (linear, nearest neighbor or by block). It creates the hdf5
with the loaded data. Finally, if necessary, it shows the figure by emitting a signal.
This signal is collected in the MainWindow() class.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS1D.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS1D.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>PyQtsignal to show the figure.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS2D">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">HEC_RAS2D</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class hec_RAS2D is there to manage the link between the graphical interface and the functions in src/hec_ras2D.py
which loads the hec_ras2D data in 2D. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW(). It is very similar to RUBAR2D class and it has the same problem about node/cell
which will need to be corrected.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS2D.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS2D.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is used to by __init__() during the initialization.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS2D.load_hec_2d_gui">
<code class="descname">load_hec_2d_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS2D.load_hec_2d_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls the function which load hecras 2d and save the names of file in the project file.
It is similar to the function to load_rubar2D.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS2D.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS2D.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>PyQtsignal to show the figures.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.Hydro2W">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">Hydro2W</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Hydro2W" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">PyQt5.QtWidgets.QWidget</span></code></p>
<p>The class Hydro2W is the second tab of HABBY. It is the class containing all the classes/Widgets which are used
to load the hydrological data.</p>
<p>List of model supported by Hydro2W:
files separetly. However, sometime the file was not found
*   Telemac (2D)
*   Hec-Ras (1.5D et 2D)
*   Rubar BE et 2(1D et 2D)
*   Mascaret (1D)
*   River2D (2D)</p>
<p><strong>Technical comments</strong></p>
<p>To call the different classes used to load the hydrological data, the user selects the name of the hydrological
model from a QComboBox call self.mod. The method ‘selection_change” calls the class that the user chooses in
self.mod. All the classes used to load the
hydrological data are created when HABBY starts and are kept in a stack called self.stack. The function
selection_change() just changes the selected item of the stack based on the user choice on self.mod.</p>
<p>Any new hydrological model should also be added to the stack and to the list of models contained in self.mod
(name of the list: self.name_model).</p>
<p>In addition to the stack containing the hydrological information, hydro2W has two buttons. One button open
a QMessageBox() which give information about the models, using the method “give_info_model”.  It is useful if a
special type of file is needed to load the data from a model or to give extra information about one hydrological
model. The text which is shown on the QMessageBox is given in one text file for each model.
These text file are contained in the folder ‘model_hydro” which is in the HABBY folder. For the moment,
there are models for which no text files have been prepared. The text file should have the following format:</p>
<ul class="simple">
<li>A short sentence with general info</li>
<li>The keyword:  MORE INFO</li>
<li>All other infomation which are needed.</li>
</ul>
<p>The second button allows the user to load an hdf5 file containing hydrological data from another project.
As long as the hdf5 is in the right format, it does not matter from which hydrological model it was loaded from
or even if this hydrological model is supported by HABBY.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Hydro2W.get_new_hydro_hdf5">
<code class="descname">get_new_hydro_hdf5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Hydro2W.get_new_hydro_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function which allows the user to select an hdf5 file containing the hydrological
data from a previous project and add it to the current project. It modifies the xml project file and test
that the data is in correct form by loading it. The hdf5 should have the same form than the hydrological data
created by HABBY in the method save_hdf5 of the class SubHydroW.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Hydro2W.give_info_model">
<code class="descname">give_info_model</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Hydro2W.give_info_model" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to show extra information about each hydrological model.
The information should be in a text file with the same name as the model in the model_hydo folder.
General info goes as the start of the text file. If the text is too long, add the keyword &#8220;MORE INFO&#8221;
and add the longer text afterwards. The message box will show the supplementary information only if the user
asks for detailed information.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Hydro2W.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Hydro2W.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initialization by __init__()</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Hydro2W.selectionchange">
<code class="descname">selectionchange</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Hydro2W.selectionchange" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the shown widget which represents each hydrological model (all widget are in a stack)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>i</strong> &#8211; the number of the model (0=no model, 1=hecras1d, 2= hecras2D,...)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.Hydro2W.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.Hydro2W.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQt signal to send the log.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.Mascaret">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">Mascaret</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Mascaret" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class Mascaret is there to manage the link between the graphical interface and the functions in src/mascaret.py
which loads the Masacret data in 1D. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW(). It is similar to the HEC-Ras1D class (see this class for more information). However, mascaret is 1D model, so the loading
of mascaret has one additional step compared to the hec-ras load: The velocity must be distributed along the
profile. For this, the load_masacret_gui call the self.distrbute _velocity function. In addition, it prepares
the manning value which is necessary to distribute the velocity. The user has two choices to input the manning
value. The easiest one is just to give a value constant for the whole river. In the second choice, the user loads
a text file with a serie of lines with the following info: p, dist, n where p is the profile number
(starting at zero), dist is the distance in meter along the profile and n in the manning value (see the method
load_manning_text of the class SubHydroW for more information)</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Mascaret.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Mascaret.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initialization by __init__()</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Mascaret.load_mascaret_gui">
<code class="descname">load_mascaret_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Mascaret.load_mascaret_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>The function is used to load the mascaret data, calling the function contained in the script mascaret.py</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.Mascaret.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.Mascaret.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal to show the figure.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.River2D">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">River2D</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class River2D t is there to manage the link between the graphical interface and the functions in src/river2D.py
which loads the River2D data in 2D.</p>
<p><strong>Technical comments</strong></p>
<blockquote>
<div><p>The class River2D inherits from SubHydroW() so it have all the methods and the variables from the class SubHydroW().
It is similar generally to the hec-ras2D class. However, the hydrological model River2D create one file per time step.
Hence, it is necessary to have a way to load all the files automatically. Loading one file after one file would be
annoying. There are four functions to manage the large number of file:</p>
<ul class="simple">
<li>add_all_file: find all files in a folder selected by the user.</li>
<li>add_file_river2D: add just one selected file</li>
<li>Remove_all_file: remove all selected files</li>
<li>Remove_file: remove one selected file</li>
</ul>
<p>None of this four functions load the data, it just add the name and path of the files to be loaded to
self.namefile and self.pathfile. Generally, in HABBY, we load hydrological data in two steps: a) select the files,
b) load the data. For river2D, the step b) is done by the function load_river2d_gui().
This function is similar to the one used by Rubar2D. It has the same problem about the grid which
is identical for all time steps and which contains all reaches together. So a temporary correction was applied.
Data in River2D is given on the nodes as in HABBY.</p>
</div></blockquote>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.add_all_file">
<code class="descname">add_all_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.add_all_file" title="Permalink to this definition">¶</a></dt>
<dd><p>The function finds all .cdg file in one directory to add there names to the list of files to be loaded</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.add_file_river2d">
<code class="descname">add_file_river2d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.add_file_river2d" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to add one file to the list of file to be loaded.
It calls show_dialog, prepare some data for it and update the QWidgetList with
the name of the file containted in the variable self.namefile.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.add_file_to_list">
<code class="descname">add_file_to_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.add_file_to_list" title="Permalink to this definition">¶</a></dt>
<dd><p>This function to add all file contained in self.namefile to the QWidgetlist. Called by add_file_river2D and
add_all_file.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>used by __init__ in the initialization</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.load_river2d_gui">
<code class="descname">load_river2d_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.load_river2d_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to load the river 2d data.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.remove_all_file">
<code class="descname">remove_all_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.remove_all_file" title="Permalink to this definition">¶</a></dt>
<dd><p>This function removes all files from the list of files to be loaded and from the QlistWidget.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.remove_file">
<code class="descname">remove_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.remove_file" title="Permalink to this definition">¶</a></dt>
<dd><p>This is small function to remove a .cdg file from the list of files to be loaded and from the QlistWidget.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.River2D.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal to show the figure.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.Rubar1D">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">Rubar1D</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class Rubar1D is there to manage the link between the graphical interface and the functions in src/rubar.py
which loads the Rubar1D data in 1D. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW(). It is very similar to Mascaret class.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Rubar1D.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar1D.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initalizatin by __init__()</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Rubar1D.load_rubar1d">
<code class="descname">load_rubar1d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar1D.load_rubar1d" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to execute the loading and saving the the rubar file using rubar.py. After loading the data,
it distribute the velocity along the profiles by calling self.distribute_velocity() and it created the 2D grid
by calling the method self.grid_and_interpo.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.Rubar1D.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar1D.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal to show the figures.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.Rubar2D">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">Rubar2D</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class Rubar2D is there to manage the link between the graphical interface and the functions in src/rubar.py
which loads the RUBAR data in 2D. It inherits from SubHydroW() so it have all the methods and the variables from
the class SubHydroW(). The form of the function is similar to hec-ras, but it does not have the part about the grid
creation as we look here as the data created in 2D by RUBAR.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Rubar2D.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar2D.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>used by ___init__() in the initialization.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Rubar2D.load_rubar">
<code class="descname">load_rubar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar2D.load_rubar" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to execture the loading and saving the the rubar file using rubar.py. It is similar to the
load_hec_ras_gui() function. Obviously, it calls rubar and not hec_ras this time. A small difference is that
the rubar2D outputs are only given in one grid for all time steps and all reaches. Moreover, it will be
necessary to cut the grid for each time step as a function of the wetted area and maybe to separate the
grid by reaches. This have not be done yet.</p>
<p>Another problem is that the data of Rubar2D is given on the cells of the grid and not the nodes.
This will need to be corrected as data in HABBY is centered on the node.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Rubar2D.propose_next_file">
<code class="descname">propose_next_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar2D.propose_next_file" title="Permalink to this definition">¶</a></dt>
<dd><p>This function proposes the second RUBAR file when the first is selected.  Indeed, to load rubar, we need
one file with the geometry data and one file with the simulation results. If the user selects a file, this
function looks if a file with the same name but with the extension of the other file type exists in the
selected folder. This could be done for all hydrological models, but the function is harder
to write when more than one extension is possible, so it has not been done yet.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.Rubar2D.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar2D.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal to show the figure.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.SubHydroW">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">SubHydroW</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">PyQt5.QtWidgets.QWidget</span></code></p>
<p>SubHydroW is class which is the parent of the classes which can be used to open the hydrological models. This class
is a bit special. It is not called directly by HABBY but by the classes which load the hydrological data and which
inherits from this class. The advantage of this architecture is that all the children classes can use the methods
written in SubHydroW(). Indeed, all the children classes load hydrological data and therefore they are similar and can use
similar functions.</p>
<p>In other word, there are MainWindows() which provides the windows around the widget and Hydro2W which provide the widget for the
hydrological Tab and one class by hydrological model to really load the model. The latter classes have various
methods in common, so they inherit from SubHydroW, this class.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.distribute_velocity">
<code class="descname">distribute_velocity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.distribute_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>This function make the link between the GUI and the functions of dist_vitesse2. It is used by 1D model,
notably rubar and masacret.</p>
<p>Dist vitess needs a manning parameters. It can be given by the user in two forms: a constant (float) or an array
created by the function load_manning_text.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.drop_hydro">
<code class="descname">drop_hydro</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.drop_hydro" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal signal for the substrate tab so it can account for the new hydrological info.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.find_path_im">
<code class="descname">find_path_im</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.find_path_im" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to find the path where to save the figues, careful a simialr one is in estimhab_GUI.py. By default,
path_im is in a folder calls &#8220;Figure_Habby&#8221;.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.grid_and_interpo">
<code class="descname">grid_and_interpo</code><span class="sig-paren">(</span><em>cb_im</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.grid_and_interpo" title="Permalink to this definition">¶</a></dt>
<dd><p>This function forms the link between GUI and the various grid and interpolation functions. Is called by
the &#8220;loading&#8217; function of hec-ras 1D, Mascaret and Rubar BE.
:param cb_im: A boolean if true, the figures are created and shown.</p>
<p><em>Technical comment to be added</em></p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.load_manning_text">
<code class="descname">load_manning_text</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.load_manning_text" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the manning data in case where manning number is not simply a constant. In this case, the manning
parameter is given in a .txt file.
The manning parameter used by 1D model such as mascaret or Rubar BE to distribute velocity along the profiles.
The format of the txt file is &#8220;p, dist, n&#8221; where  p is the profile number (start at zero), dist is the distance
along the profile in meter and n is the manning value (in SI unit). One point per line so something like:</p>
<p>0, 150, 0.035</p>
<p>0, 200, 0.025</p>
<p>1, 120, 0.035, etc.</p>
<p>White space is neglected and a line starting with the character # is also neglected.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.read_attribute_xml">
<code class="descname">read_attribute_xml</code><span class="sig-paren">(</span><em>att_here</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.read_attribute_xml" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to read the text of an attribute in the xml project file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>att_here</strong> &#8211; the attribute name (string).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.save_hdf5">
<code class="descname">save_hdf5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.save_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>This function save the hydrological data in the hdf5 format.</p>
<p><strong>Techincal comments</strong></p>
<p>This function cannot be used outside of the class, so it needs to be re-written if used from the command line.</p>
<p>This function creates an hdf5 file which contains the hydrological data. First it creates an empty hdf5.
Then it fill the hdf5 with data. For 1D model, it fill the data in 1D (the original data), then the 1.5D data
created by dist_vitess2.py and finally the 2D data. For model in 2D it only saved 2D data. Hence, the 2D data
is the data which is common to all model and which can always be loaded from a hydrological hdf5 created by
HABBY. The 1D and 1.5D data is only present if the model is 1D or 1.5D. Here is some general info about the
created hdf5:</p>
<ul class="simple">
<li>Name of the file: name_projet  +  ’_’ +  name model + date/time.h5.  For example, test4_HEC-RAS_25_10_2016_12_23_23.h5.</li>
<li>Position of the file: in the folder  figure_habby currently (probably in a project folder in the final software)</li>
<li>Format of the hdf5 file:<ul>
<li>Dats_gen:  number of time step and number of reach</li>
<li>Data_1D:  xhzv_data_all (given profile by profile)</li>
<li>Data_15D :  vh_pro, coord_pro (given profile by profile in a dict) and nb_pro_reach.</li>
<li>Data_2D : For each time step, for each reach: ikle, point, point_c, inter_h, inter_vel</li>
</ul>
</li>
</ul>
<p>If a list has elements with a changing number of variables, it is necessary to create a dictionary to save
this list in hdf5. For example, a dictionary will be needed to save the following list: [[1,2,3,4], [1,2,3]].
This is used for example, to save data by profile as we can have profile with more or less points. We also note
in the hdf5 attribute some important info such as the project name, path to the project, hdf5 version.
This can be useful if an hdf5 is lost and is not linked with any project. We also add the name of the created
hdf5 to the xml project file. Now we can load the hydrological data using this hdf5 file and the xml project file.</p>
<p>Hdf5 file do not support unicode. It is necessary to encode string to write them in ascii.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.save_xml">
<code class="descname">save_xml</code><span class="sig-paren">(</span><em>i=0</em>, <em>append_name=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.save_xml" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to save the loaded data in the xml file.</p>
<p>This function adds the name and the path of the newly chosen hydrological data to the xml project file. First,
it open the xml project file (and send an error if the project is not saved, or if it cannot find the project
file). Then, it opens the xml file and add the path and name of the file to this xml file. If the model data was
already loaded, it adds the new name without erasing the old name IF the switch append_name is True. Otherwise,
it erase the old name and replace it by a new name. The variable “i” has the same role than in show_dialog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i</strong> &#8211; a int for the case where there is more than one file to load</li>
<li><strong>append_name</strong> &#8211; A boolean. If True, the name found will be append to the existing name in the xml file,
instead of remplacing the old name by the new name.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.send_err_log">
<code class="descname">send_err_log</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.send_err_log" title="Permalink to this definition">¶</a></dt>
<dd><p>This function sends the errors and the warnings to the logs.
The stdout was redirected to self.mystdout.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A Pyqtsignal to write the log.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.show_dialog">
<code class="descname">show_dialog</code><span class="sig-paren">(</span><em>i=0</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.show_dialog" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to obtain the name of the file chosen by the user. This method open a dialog so that the user select
a file. This file is NOT loaded here. The name and path to this file is saved in an attribute. This attribute
is then used to loaded the file in other function, which are different for each children class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>i</strong> &#8211; a int for the case where there is more than one file to load</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.was_model_loaded_before">
<code class="descname">was_model_loaded_before</code><span class="sig-paren">(</span><em>i=0</em>, <em>many_file=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.was_model_loaded_before" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to test if the model loaded before. If yes, it updates the attibutes anf the widgets of the
hydrological model on consideration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i</strong> &#8211; an int used in cases where there is more than one file to load (geometry and output for example)</li>
<li><strong>many_file</strong> &#8211; A bollean. If true this function will load more than one file, separated by &#8216;,&#8217;. If False,
it will only loads the file of one model (see the comment below).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comment</strong></p>
<p>This method opens the xml project file and look in the attribute of the xml file to see if data from the
hydrological model have been loaded before. If yes, the name of the data is written on the GUI of HABBY in the
Widget related to the hydrological model. Now, there are often more than one data loaded. This method allows
choosing what should be written. There are two different case to be separated: a) We have loaded two different
models (like two rivers modeled by HEC-RAS) b) One model type needs two data file (like HEC-RAS would need a
geometry and output data). For the case a), the default is to write only the first model loaded. If we wish to
write all data, the switch “many_file” should be True. This switch is also useful for the river2D model, because
this model create one output file per time step. For the case b), the argument “i”(which is an int) allows us to
choose which data type should be shown. “i” is in the order of the self.attributexml variable. The definition of
this order is given in the definition of the class of each hydrological model.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.SubstrateW">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">SubstrateW</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>This is the widget used to load the substrate. It is practical to re-use some of the method from SubHydroW.
So this class inherit from SubHydroW.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.get_att_name">
<code class="descname">get_att_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.get_att_name" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to get the attribute name of the shapefile which contains the substrate data. it is given by the user
in the GUI.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initialization by __init__().</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.load_sub_gui">
<code class="descname">load_sub_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.load_sub_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to load the substrate data. The substrate data can be in two forms: a) in the form of a shp
file form ArGIS (or another GIS-program). b) in the form of a text file (x,y, substrate data line by line).
Generally this function has some similarities to the functions used to load the hydrological data and it re-uses
some of the methods developed for them.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.log_txt">
<code class="descname">log_txt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.log_txt" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gives the log for the substrate in text form. this is in a function because it is used twice in
the function load_sub_gui()</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.save_hdf5_sub">
<code class="descname">save_hdf5_sub</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.save_hdf5_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>This function save the substrate data in its own hdf5 file and write the name of this hdf5 file in the
xml project file. The format of the hdf5 file is not finalzed yet so it is not documented.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.send_merge_grid">
<code class="descname">send_merge_grid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.send_merge_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls the function merge grid in substrate.py. The goal is to have the substrate and hydrological
data on the same grid. Hence, the hydrological grid will need to be cut to the form of the substrate grid.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal to show the figures.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.update_hydro_hdf5_name">
<code class="descname">update_hydro_hdf5_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.update_hydro_hdf5_name" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a short function used to read all the hydrological data contained in an hdf5 files and available in
one project. When these files are read, they are added to the drop-down menu;
This should be a function because an update to this list can be triggered by the loading of a new hydrological
data. The class SubstrateW() noticed this through the signal drop_hydro send by the hydrological class.
The signal drop_hydro is connected to this function in the class CentralW in MainWindows.py. Indeed, it is not
possible to do it in SubstrateW().</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.TELEMAC">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">TELEMAC</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.TELEMAC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class Telemac is there to manage the link between the graphical interface and the functions in src/selafin_habby1.py
which loads the Telemac data in 2D. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW(). It is very similar to RUBAR2D class, but data from Telemac is on the node as in HABBY.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.TELEMAC.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.TELEMAC.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used by __init__() during the initialization.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.TELEMAC.load_telemac_gui">
<code class="descname">load_telemac_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.TELEMAC.load_telemac_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>The function which call the function which load telemac and save the name of files in the project file</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.TELEMAC.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.TELEMAC.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal to show the figure.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="figure-option-gui">
<h2>Figure Option - GUI<a class="headerlink" href="#figure-option-gui" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>in src_GUI/output_fig_GUI.py</p>
<p>This part is not finished. The idea is to let the user select various options to create
the figures, notably the colour or the size of the text.</p>
</div></blockquote>
<span class="target" id="module-src_GUI.output_fig_GUI"></span><dl class="function">
<dt id="src_GUI.output_fig_GUI.create_default_figoption">
<code class="descclassname">src_GUI.output_fig_GUI.</code><code class="descname">create_default_figoption</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.output_fig_GUI.create_default_figoption" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates the default dictionnary of option for the figure.</p>
</dd></dl>

<dl class="function">
<dt id="src_GUI.output_fig_GUI.load_fig_option">
<code class="descclassname">src_GUI.output_fig_GUI.</code><code class="descname">load_fig_option</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.output_fig_GUI.load_fig_option" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the figure option saved in the xml file and create a dictionnary will be given to the functions
which create the figures to know the different options chosen by the user. If the options are not written, this
function uses data by default which are in the fonction create_default_fig_options().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path_prj</strong> &#8211; the path to the xml project file</li>
<li><strong>name_prj</strong> &#8211; the name to this file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the dictionary containing the figure options</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="src_GUI.output_fig_GUI.outputW">
<em class="property">class </em><code class="descclassname">src_GUI.output_fig_GUI.</code><code class="descname">outputW</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.output_fig_GUI.outputW" title="Permalink to this definition">¶</a></dt>
<dd><p>The class which support the creation and management of the output. It is notably used to select the otions to
create the figures.</p>
<dl class="method">
<dt id="src_GUI.output_fig_GUI.outputW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.output_fig_GUI.outputW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="src_GUI.output_fig_GUI.outputW.save_option_fig">
<code class="descname">save_option_fig</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.output_fig_GUI.outputW.save_option_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which save the options for the figures in the xlm project file. The options for the figures are
contained in a dictionnary. The idea is to give this dictinnory in argument to all the fonction which create
figures. In the xml project file, the options for the figures are saved under the attribute &#8220;Figure_Option&#8221;.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.output_fig_GUI.outputW.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.output_fig_GUI.outputW.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal used to write the log.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-src_GUI.stathab_GUI">
<span id="the-stathab-model-gui"></span><h2>The Stathab model - GUI<a class="headerlink" href="#module-src_GUI.stathab_GUI" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="src_GUI.stathab_GUI.StathabW">
<em class="property">class </em><code class="descclassname">src_GUI.stathab_GUI.</code><code class="descname">StathabW</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW" title="Permalink to this definition">¶</a></dt>
<dd><p>The class to load and manage the widget controlling the Stathab model.</p>
<p><strong>Technical comments</strong></p>
<p>The class StathabW makes the link between the data prepared by the user for Stathab and  the Stathab model
which is in the src folder (stathab_c.py) using the graphical interface.  Most of the Stathab input are given in
form of text file. For more info on the preparation of text files for stathab, read the document called
&#8216;stathabinfo.pdf&#8221;.  To use Stathab in HABBY, all Stathab input should be in the same directory. The user select
this directory (using the button “loadb”) and HABBY tries to find the file it needs. All found files are added to
the list called “file found”. If file are missing, they are added to the “file still needed” list.  The user can then
select the fishes on which it wants to run stathab, then it run it by pressing on the “runb” button.</p>
<p>If file where loaded before by the user in the same project, StathabW looks for them and load them again. Here we
can have two cases: a) the data was saved in hdf5 format (as it is done when a stathab run was done) and the path
to this file noted in the xml project file. b) Only the name of the directory was written in the xml project file,
indicated that data was loaded but not saved in hdf5 yet. HABBY manages both cases.</p>
<p>Next, we check in the xml project file where the folder to save the figure (path_im) is. In case, there are
no path_im saved, Stathab create one folder to save the figure outputs. This should not be the usual case. Generally,
path_im is created with the xml project file, but you cannot be sure.</p>
<p>There is a list of error message which are there for the case where the data which was loaded before do not exist
anymore. For example, somebody erased the directory with the Stathab data in the meantime.  In this case,
a pop-up message open and warn the user.</p>
<p>An important attribute of StathabW() is self.mystathab. This is an object fo the stahab class. The stathab model,
which is in the form of a class and not a function, will be run on this object.</p>
<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.add_all_fish">
<code class="descname">add_all_fish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.add_all_fish" title="Permalink to this definition">¶</a></dt>
<dd><p>This function add the name of all known fish (the ones in Pref.txt) to the QListWidget.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.add_fish">
<code class="descname">add_fish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.add_fish" title="Permalink to this definition">¶</a></dt>
<dd><p>This function add the name of one fish species to the selected list of fish species.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.load_from_hdf5_gui">
<code class="descname">load_from_hdf5_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.load_from_hdf5_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls from the GUI the load_stathab_from_hdf5 function. In addition to call the function to load
the hdf5, it also updates the GUI according to the info contained in the hdf5.</p>
<p><strong>Technical comments</strong></p>
<p>This functino updates the Qlabel similarly to the function “load_from_txt_gui()”.
It also loads the data calling the load_stathab_from_hdf5 function from the Stathab class in src. The info
contains in the hdf5 file are now in the memory in various variables called self.mystathab.”something”.
HABBY used them to update the GUI. First, it updates the list which contains the name of the reaches
(self.list_re.). Next, it checks that each of the variable needed exists and that they contain some data.
Afterwards, HABBY looks which preference file to use. Either, it will use the default preference file
(contained in HABBY/biologie) or a custom preference prepared by the user. This custom preference
file should be in the same folder than the hdf5 file. When the preference file was found, HABBY reads all
the fish type which are described and add their name to the self.list_f list which show the available fish
to the user in the GUI. Finally it checks if all the variables were found or if some were missing</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.load_from_txt_gui">
<code class="descname">load_from_txt_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.load_from_txt_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>The main roles of load_from_text_gui() are to call the load_function of the stathab class (which is in
stathab_c.py in the folder src) and to call the function which create an hdf5 file. However, it does some
modifications to the GUI before.</p>
<p><strong>Technical comments</strong></p>
<p>Here is the list of the modifications done to the graphical user interface before calling the load_function of
Stathab.</p>
<p>First, it updates the label. Because a new directory was selected, we need to update the label containing the
directory’s name. We only show the 30 last character of the directory name. In addition, we also need to update
the other label. Indeed, it is possible that the data used by Stathab would be loaded from an hdf5 file.
In this case, the labels on the top of the list of file are slightly modified. Here, we insure that we are in
the “text” version since we will load the data from text file.</p>
<p>Next, it gets the name of all the reach and adds them to the list of reach name. For this, it calls a function
from the stathab class (in src). Then, it looks which files are present and add them to the list which contains
the reach name called self.list_re.</p>
<p>Afterwards, it checks if the files needed by Stathab are here. The list of file is given in the
self.end_file_reach list. The form of the file is always the name of the reach + one item of
self.end_file_reach. If it does not find all files, it add the name of the files not found to self.list_needed,
so that the user can be aware of which file he needs. The exception is Pref.txt. If HABBY do not find it in the
directory, it uses the default “Pref.txt”. All files (apart from Pref.txt) should be in the same directory.</p>
<p>Then, it calls a method of the Stathab class (in src) which reads the “pref.txt” file and adds the name
of the fish to the GUI. Next, if all files are present, it loads the data using the method written in Stathab
(in the src folder). When the data is loaded, it creates an hdf5 file from this data and save the name of this
new hdf5 file in the xml project file (also using a method in the stathab class).</p>
<p>Finally, it sends the log info as explained in the log section of the documentation</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.reach_selected">
<code class="descname">reach_selected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.reach_selected" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which indcates which files are linked with which reach.</p>
<p><strong>Technical comment</strong></p>
<p>This is a small function which only impacts the GUI. When a Stathab model has more than one reach,
the user can click on the name of the reach. When he does this, HABBY selects the first file linked
with this reach and shows it in self.list_f. This first file is highlighted and the list is scrolled
down so that the files linked with the selected reach are shown. This function manages this. It is connected
with the list self.list_re, which is the list with the name of the reaches.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.remove_fish">
<code class="descname">remove_fish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.remove_fish" title="Permalink to this definition">¶</a></dt>
<dd><p>This function remove the name of one fish species to the selected list of fish species.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.run_stathab_gui">
<code class="descname">run_stathab_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.run_stathab_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the function which calls the function to run the Stathab model.  First it read the list called
self.list_s. This is the list with the fishes selected by the user. Then, it calls the function to run
stathab and the one to create the figure if the figures were asked by the user. Finally, it writes the log.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.select_dir">
<code class="descname">select_dir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.select_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to select the directory and find the files to laod stathab from txt files. It calls
load_from_txt_gui() when done.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.select_hdf5">
<code class="descname">select_hdf5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.select_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>This function allows the user to choose an hsdf5 file as input from Stathab.</p>
<p><strong>Technical comment</strong></p>
<p>This function is for example useful if the user would have created an hdf5 file for a Stathab model in another
project and he would like to send the same model on other fish species.</p>
<p>This function writes the name of the new hdf5 file in the xml project file. It also notes that the last data
loaded was of hdf5 type. This is useful when HABBY is restarting because it is possible to have a
directory name and the address of an hdf5 file in the part of the xml project file concerning Stathab.
HABBY should know if the last file loaded was this hdf5 or the files in the directory.
Finally, it calls the function to load the hdf5 called load_from_hdf5_gui.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.send_err_log">
<code class="descname">send_err_log</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.send_err_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Send the errors and warnings to the logs. It is useful to note that the stdout was redirected to self.mystdout.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.stathab_GUI.StathabW.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal used to write the log.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.stathab_GUI.StathabW.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal used to show the figures.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="estimhab-gui">
<h2>Estimhab - GUI<a class="headerlink" href="#estimhab-gui" title="Permalink to this headline">¶</a></h2>
<p>in src_GUI/estimhab_GUI.py</p>
<span class="target" id="module-src_GUI.estimhab_GUI"></span><dl class="class">
<dt id="src_GUI.estimhab_GUI.EstimhabW">
<em class="property">class </em><code class="descclassname">src_GUI.estimhab_GUI.</code><code class="descname">EstimhabW</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW" title="Permalink to this definition">¶</a></dt>
<dd><p>The Estimhab class provides the graphical interface for the version of the Estimhab model written in HABBY.
The Estimhab model is described elsewhere. EstimhabW() just loads the data for Estimhab given by the user.</p>
<dl class="method">
<dt id="src_GUI.estimhab_GUI.EstimhabW.add_fish">
<code class="descname">add_fish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.add_fish" title="Permalink to this definition">¶</a></dt>
<dd><p>The function is used to select a new fish species</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.EstimhabW.change_folder">
<code class="descname">change_folder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.change_folder" title="Permalink to this definition">¶</a></dt>
<dd><p>A small method to change the folder which indicates where is the biological data</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.EstimhabW.find_path_im_est">
<code class="descname">find_path_im_est</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.find_path_im_est" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to find the path where to save the figues. Careful there is similar function in hydro_GUI_2.py.
Do not mix it up</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">path_im a string which indicates the path to the folder where are save the images.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.EstimhabW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to initialized an instance of the EstimhabW() class. It is called be __init__().</p>
<blockquote>
<div><p><strong>Technical comments and walk-through</strong></p>
<p>First we looked if some data for Estimhab was saved before by an user. If yes, we will fill the GUI with
the information saved before. Estimhab information is saved in hdf5 file format and the path/name of the
hdf5 file is saved in the xml project file. So we open the xml project file and look if the name of an hdf5
file was saved for Estimhab. If yes, the hdf5 file is read.</p>
<p>The format of hdf5 file is relatively simple. Each input data for Estimhab has its own dataset (qmes, hmes,
wmes, q50, qrange, and substrate).  Then, we a list of string which are a code for the fish species which
were analyzed.  All the data contained in hdf5 file is loaded into variable.</p>
<p>The different label are written on the graphical interface. Then, two QListWidget are modified. The first
list contains all the fish species on which HABBY has info (see XML Estimhab format for more info).
The second list is the fish selected by the user on which Estimhab will be run. Here, we link these lists
with two functions so that the user can select/deselect fish using the mouse. The function name are add_fish()
and remove_fish().</p>
<p>Then, we fill the first list. HABBY look up all file of xml type in the “Path_bio” folder (the one indicated in
the xml project file under the attribute “Path_bio”).  The name are them modified so that the only the name of
species appears (and not the full path). We set the layout with all the different QLineEdit where the user
can write the needed data.</p>
<p>Estimhab model is saved using a function situated in MainWindows_1.py  (frankly, I am not so sure why I did put
the save function there, but anyway). So the save button just send a signal to MainWindows
here, which save the data.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.EstimhabW.remove_fish">
<code class="descname">remove_fish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.remove_fish" title="Permalink to this definition">¶</a></dt>
<dd><p>The function is used to remove fish species</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.EstimhabW.run_estmihab">
<code class="descname">run_estmihab</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.run_estmihab" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to execute Estimhab by calling the estimhab function.</p>
<p><strong>Technical comment</strong></p>
<p>This is the function making the link between the GUI and the source code proper. The source code for Estimhab
is in src/Estimhab.py.</p>
<p>This function loads in memory the data given in the graphical interface and call sthe Estimhab model.
The data could be written by the user now or it could be data which was saved in the hdf5 file before and
loaded when HABBY was open (and the init function called).  We check that all necessary data is present and
that the data given makes sense (e.g.,the minimum discharge should not be bigger than the maximal discharge,
the data should be a float, etc.). We then remove the duplicate fish species (in case the user select one
specie twice) and the Estimhab model is called. The log is then written (see the paragraph on the log for more
information). Next, the figures created by Estimmhab are shown. As there is only a short number of outputs
for Estimhab, we create a figure in all cases (it could be changed by adding a checkbox on the GUI like
in the Telemac or other hydrological class).</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.estimhab_GUI.EstimhabW.save_signal_estimhab">
<code class="descname">save_signal_estimhab</code><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.save_signal_estimhab" title="Permalink to this definition">¶</a></dt>
<dd><p>PyQtsignal to save the Estimhab data.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.estimhab_GUI.EstimhabW.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>PyQtsignal to write the log.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.estimhab_GUI.EstimhabW.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>PyQtsignal to show the figures.</p>
</dd></dl>

</dd></dl>

<div class="section" id="biological-data-estimhab">
<h3>Biological data - Estimhab<a class="headerlink" href="#biological-data-estimhab" title="Permalink to this headline">¶</a></h3>
<p>The biological data, i.e., the preference curves of Estimhab, are saved in xml files
situated in the folder given by the path written in the xml project file under the
attribute Path_bio. By default, it is HABBY/biology. It is possible to change this folder
using the GUI.</p>
<p>Estimhab is a statistical model, which functions using mathematical regressions.
The different regressions (or preference curve) of each fish are described in an xml file
whose format is given here.</p>
<p>Conceptually, the regressions R are of two types:</p>
<ul class="simple">
<li>Type 0          R = C * Q^{m1} * exp(m2*Q)</li>
<li>Type 1          R = C * (1+m1*exp(m2*Q))</li>
</ul>
<p>Where Q is the discharge, m1 and m2 are coefficients which depend on the fish type, and C is a
constant which depends on the stream characteristic and the fish type.</p>
<p>The constant C is of the form C = a + ∑ ai * ln(Si) where a and ai are coefficients which depend on
the fish type. Si are particular stream characteristics. Which characteristics should be used is a
function of the fish type and is so given in the xml file. The value of S i is a function of the stream
and is calculated by the program.</p>
<p>In the xml file,</p>
<ul class="simple">
<li>Attribute coeff_q: Give the main coefficients of the regression (m1 and m2)</li>
<li>Attribute func_q : Give the type of regression R used.  Type 0 and type 1, as described above, are known by HABBY.</li>
<li>Attribute coeff_const: Give the coefficient used to construct the constant C (a, a1, a2, a3,…). The number of coefficient differs for each fish, but should be at least one.</li>
<li>Attribute var_const: Give which type of stream characteristics is used. This is not the value of the particular characteristic, but only which type is used. The following list of type is accepted:<ul>
<li>0 for Q50, natural median discharge</li>
<li>1 for H50, the height of the stream at q50</li>
<li>2 for L50, the width of the stream at q50</li>
<li>3 for V50, the velocity of the stream at q50</li>
<li>4 for Re50, the discharge divided by 10 times the width at Q50</li>
<li>5 for Fr50, the Froude number at Q50</li>
<li>6 for Dh50, the mean substrate height divided by h50</li>
<li>7 for Exp(Dh50). Erase the log() of this particular term of the constant</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="section" id="calculation-of-fish-s-habitat">
<h1>Calculation of fish&#8217;s habitat<a class="headerlink" href="#calculation-of-fish-s-habitat" title="Permalink to this headline">¶</a></h1>
<p>The src folder contains the python module which are not linked with the graphical user interface.</p>
<span class="target" id="module-src"></span><div class="section" id="hec-ras-model-1d">
<h2>Hec-ras model 1D<a class="headerlink" href="#hec-ras-model-1d" title="Permalink to this headline">¶</a></h2>
<p>in src/Hec_ras06.py</p>
<p>This module contains the functions used to load the outputs from the hec-ras model in 1.5D.</p>
<span class="target" id="module-src.Hec_ras06"></span><dl class="function">
<dt id="src.Hec_ras06.coord_profile_non_georeferenced">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">coord_profile_non_georeferenced</code><span class="sig-paren">(</span><em>data_bank_all</em>, <em>data_dist_all</em>, <em>data_river_all</em>, <em>data_profile_all</em>, <em>nb_pro_reach</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.coord_profile_non_georeferenced" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to create the coordinates of the profile in the non-georeferenced case.
This function is called by open geo_file(). Hypothesis: The profile are straight and perpendicular to the river.
The last profile is at the end of the river.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_bank_all</strong> &#8211; distance along the profile of bank station</li>
<li><strong>data_dist_all</strong> &#8211; the distance between the profile (left, center channel, right)</li>
<li><strong>data_river_all</strong> &#8211; the coordinate of the river</li>
<li><strong>data_profile_all</strong> &#8211; the (d,z) data of the profile</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the coordinates of the profile</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>For each profile, we create an array composed of five points: Start of profile, left bank, intersection between
river and profile, right bank and end of profile. The intersection with the river is directly given as input to
the function. Then we find the vector perpendicular to this river and we get the four other points on the same line.</p>
<p>To get the distance for these four other point, we must be careful to pass from the distance given in meter and the
distance in the model coordinates (scaled between [0, 1] usually). The way to go from one coordinate system to
another is to use the “alpha” variable.  We only need to correct distance, no problem with a system of coordinate
which would not be in the same direction (as the data is given along a profile). The river passes in the middle of
the right and left bank, so we can find where is left and right bank is. Because we know the total length of the
profile, we can also find the beginning and end of the profile.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.figure_xml">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">figure_xml</code><span class="sig-paren">(</span><em>data_profile</em>, <em>coord_pro_old</em>, <em>coord_r</em>, <em>xy_h_all</em>, <em>zone_v_all</em>, <em>pro</em>, <em>path_im</em>, <em>nb_sim=0</em>, <em>name_profile='no_name'</em>, <em>coord_p2=-99</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.figure_xml" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to plot the results of the loading of hec-ras data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data_profile</strong> &#8211; (list with np.array)</li>
<li><strong>coord_pro_old</strong> &#8211; (x,y) data of the profile (list with np.array)</li>
<li><strong>coord_r</strong> &#8211; (x,y) data of the river (list with np.array)</li>
<li><strong>xy_h_all</strong> &#8211; (x,y, h) for the height data for each simulation (list with np.array)</li>
<li><strong>zone_v_all</strong> &#8211; (x,y, v) for the velocity data. velocity is by zone of profile. for each simulation.
the (x,y) indicates the start of the zone which end with the next velocity</li>
<li><strong>pro</strong> &#8211; a list of int with the profile whcih should be ploted [2,3,4]</li>
<li><strong>nb_sim</strong> &#8211; which simulation should be plotted. In fact, it often relates to the time step.</li>
<li><strong>name_profile</strong> &#8211; a list of string with the name of the profiles</li>
<li><strong>coord_p2</strong> &#8211; the data of the profile when non geo-referenced, optional</li>
<li><strong>path_im</strong> &#8211; the path where the figure should be saved (string)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>We first choose the size of the font to be written. At term, it should be given by the options.</p>
<p>Two main groups of figure will be done: One list of figure with the form of the profil, the water height, and the
velocity for the chosen profiles and one (x,y) view of the position of each profile.</p>
<p>We chose the time step to be written (the variable nb_sim here). The variable pro is a list which says which
profiles are to be plotted. Hence, we get the velocity and water height for the time step and profile of interest.</p>
<p>To plot the velocity, we first get the distance along the profile where the water level cut the profile elevation.
This is the variable xint1 and xint2. We then get the velocity data for the region under the water. We add three
points for velocity at 0, xint1 and xint2. We then used the step function to plot the vecloity. Because of the added
point, we will have a zero velocity from 0 to xint1, then the velocity data, then again zeros from xint2 to the end.</p>
<p>To plot the elevation of the profile, we plot the variable xz and we use the function fill_between to fill
in blue the region under water. This function creates a line at the water elevation and fills in blue between this
line and the profile elevation. We add some titles and save the figures.</p>
<p>For the second type of figure (view in x,y coordinates), We first plot the river position which is saved in the
coord_r variable. Then we plot the coordinate of each profile and their names. If the name of the profile is not
known, we plot the profile number.  We also plot the position of each velocity data and height data (as it could be
useful). If the figure gets too complicated, this can be taken away by changing the two lines which finish
with height or velocity as comment.  We add some titles and save the figures.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.find_coord_height_velocity">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">find_coord_height_velocity</code><span class="sig-paren">(</span><em>coord_pro</em>, <em>data_profile</em>, <em>vel</em>, <em>wse</em>, <em>nb_sim</em>, <em>max_vel_dist=0</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.find_coord_height_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>This function finds the coordinates of the height/velocity. In hec-ras outputs the data are often written in the
form (profile, distance along the profile, data). This function passes this type of information in the usual
coordinate form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coord_pro</strong> &#8211; the coordinate (x,y) of the profile. List of np.array.</li>
<li><strong>data_profile</strong> &#8211; data concening the geometry of the profile, notably its elevation (x,z). List of np.array.</li>
<li><strong>vel</strong> &#8211; the velocity data. List of np.array.</li>
<li><strong>wse</strong> &#8211; the water surface elevation. List of np.array.</li>
<li><strong>nb_sim</strong> &#8211; the number of simulation in case there is more than one</li>
<li><strong>max_vel_dist</strong> &#8211; the minimum number of velocity point by ten meter before a warnings appears</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">for each simulation, a list of np.array representing (x,y,v) and (x,y,h,)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>This is a function called after having loaded the data. Hec-Ras present the data in (profil, distance along
profile, data) form for the height. For the velocity, it is similar but the distance is given by a number between
0 and 1 (0 is the start of the profile, 1 is the end of the profile). This function transforms this data in the form
(x,y, dist, data) using the (x,y) coordinates given in the coord_pro variable. In other word,  we have the
coordinate of the profile, not of the coordinates of the height and velocity data.</p>
<p>First, we get the distance between all points in (x,y) system. Then, we get the length of the profile in
meter or feet. It is possible to have a (x,y) coordinate system in a different unit. Hence, the length of the profil
is valid for the (profile, distance along profile, data) view. We multiply the velocity distance data by this
length. Hence, the distance information is now in meter or feet along the profile for water height and velocity.</p>
<p>There are some lines added to account for the last and first points of the profile (annoying in hec-ras). We then
calculate the new coordinates. For each velocity and water height point, we find the last known point in the (x,y)
coordinates. We do a vectorial addition from this point plus the vector between this point and the next multiplied
by the distance from this point to the point that we tried to calculate.  The variable alpha is used to pass from
one coordinate system to the next one.</p>
<p>Careful the height is on the node and the velocity is by zone.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.get_rid_of_white_space">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">get_rid_of_white_space</code><span class="sig-paren">(</span><em>stream_str</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.get_rid_of_white_space" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a small fonction to get rid of white space at the end of name which could contain white space. Not used
anymore as str.strip() functions well. But, as it was done already, we let it here.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>stream_str</strong> &#8211; the name of the string</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the same name without white space.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.load_xml">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">load_xml</code><span class="sig-paren">(</span><em>xml_file</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.load_xml" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function used by openxml_file and opengml_file to load an xml file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xml_file</strong> &#8211; the name of an xml file (string)</li>
<li><strong>path</strong> &#8211; the path where the xml file is (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the loaded data from the XML file in the form of the root of the xml file.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.main">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.main" title="Permalink to this definition">¶</a></dt>
<dd><p>This is not the main() of HABBY. This function is used to test this module independently of the rest of HABBY.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.open_geofile">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">open_geofile</code><span class="sig-paren">(</span><em>geo_file</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.open_geofile" title="Permalink to this definition">¶</a></dt>
<dd><p>This function opens the geometry file (.g0X) from Hecr-rad. It extracts the (x,z) from each profile
and the (x,y) if georeferenced,</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geo_file</strong> &#8211; the name of the Hec-Ras geometry file (string)</li>
<li><strong>path</strong> &#8211; the path to the geo file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list with each river profile (each profile is represented by a numpy array with the x and the altitude
of each point in the profile), the coordinate of the profile (list of np.array),
the coordinate of the river and the name of the reaches/ river in the file order (list of string)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>The geofile is a text file with contains the geographical information. Because it is written to be read by human,
it is complicated to load and regular expression are needed. It is written profile by profile.</p>
<p>Generally, to give a position, hec-ras indicates the profile number and the distance along this profile. In addition,
data can be georeferenced or not. If it is geo-referenced we have some data in an (x,y) form. Otherwise, we only
have geometrical data in the form (profile, dist).</p>
<p>First, for each profile, we get the elevation of the points forming each profile in the form (dist, elevation).
The list of elevation for each profile starts with the keyword “Sta/Elev”. The data found in the text file is in a
string format. We use the function pass_in_float_from_geo to pass it in float. It is usually done using the function
float. However, there are cases where there are no space between two number. However, in this case, the number of
character per number is constant. In this case, we separate the number first.</p>
<p>Then, we get the coordinate of the river. If no coordinate are available the river is assumed to be straight. Next,
we get the bank limit (even if we do not really used afterwards), and the name of the reach. It is also important
to save the order in which the names of the reach are given. Indeed, we want this order to be the same in all
functions, but they can be different between the geo file and the data output.</p>
<p>Next, we want to get the position (x,y) of each profile. If it is georeferenced, we will be able to get this
position directly from the file and put it in the data_dist_str variable. We will then pass it to float. If not,
we will use the function coord_profil_non_georeferenced to estimate the position of the profile (see below).</p>
<p>If the profile is not georeferenced, it is important to have the distance between two profile, so we extract the
information from the geo file in all cases (georeferenced or not). The last profile of a reach does not have a
distance to the next (not existing) profile. However, if a profile does not have a distance to the next profile
and is not the last profile, we ignore this profile. It is usually not a problem because this profile is usually
not a “real” profile, but the representation of a bridge or a culvert.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.open_hecras">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">open_hecras</code><span class="sig-paren">(</span><em>geo_file</em>, <em>res_file</em>, <em>path_geo</em>, <em>path_res</em>, <em>path_im</em>, <em>save_fig=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.open_hecras" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will open HEC-RAS outputs, i.e. the .geo file and the outputs (either .XML, .sdf or .rep) from HEC-RAS.
All arguments from this function are string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geo_file</strong> &#8211; the name of .goX (example .go3) file which is an output from hec-ras containg the profile data</li>
<li><strong>res_file</strong> &#8211; the name of O0X.xml file for the name of the .sdf file  or the name of the .rep file (output data)</li>
<li><strong>path_res</strong> &#8211; path to the result file</li>
<li><strong>path_geo</strong> &#8211; path to the geo file</li>
<li><strong>path_im</strong> &#8211; the path to the folder where the images should be saved</li>
<li><strong>save_fig</strong> &#8211; if True image is saved</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coord_pro (for each profile, x,y,elev, dist along the profile), vh_pro
(for each profile, dist along the profile, water height, velocity). Both variable are a list of numpy array.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>How to obtain the input files</strong></p>
<p>To obtain the xml file in HEC-RAS version 4:</p>
<ul class="simple">
<li>open the project in HEC-RAS.</li>
<li>click on File , then export geometry and result (RAS Mapper), then OK</li>
</ul>
<p>To obtain the sdf file in HEC-RAS version 5 which should be used if the model is georeferenced:</p>
<ul class="simple">
<li>click on File, then Export GIS data</li>
<li>Export all reaches (select Reaches to export -. Full List -&gt; Ok)</li>
<li>Export all needed profile (select Profile to export -&gt; Select all -&gt; ok)</li>
</ul>
<p>To obtain the report file .rep in HEC-RAS version which should be used if the model is NOT geo-referenced</p>
<ul class="simple">
<li>click on File, generate report</li>
<li>Select Flow data and Geometry data in input data and, in Specific Table, select Flow distribution and
Cross section Table</li>
</ul>
<p><strong>Technical comments</strong></p>
<p>This is function which loads the hec_ras inputs in 1D for the version 4 and 5 of HEC-RAS. It accepts different type
of hec-ras output as input and calls the appropriate sub-function for each input file.  The geometrical data is
always given in the geo file (with the extension g01, G01, g02, G02, g03, etc.). The output data can be in an xml
file for the hec-ras in the version 4, an sdf file for hec-ras in version 5 or a .rep file in the version 5 if the
model is not georeferenced. The xml file is the format which has been tested the most.</p>
<p>First, it loads the geometrical data. Then it select the function to load the output data and loads it. Then, it
transforms the loaded data in a (x,y) coordinates system. Indeed, most of the data in hec-ras is given by indicating
a profile (which crossed the modelled river) and the distance along this profile. For HABBY, it is better to get
(x,y) coordinates. Then it create figure if asked by the switch “save_fig”. Finally, it updates the forms of the
output to be coherent with the dist_velocity_hecras function.  This way, in HABBY, the output from mascaret and
rubar after the velocity distribution have the same form than the output from hec-ras, which is useful afterwards
to save all these data in the hdf5 file.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.open_repfile">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">open_repfile</code><span class="sig-paren">(</span><em>report_file</em>, <em>reach_name</em>, <em>path</em>, <em>data_profile</em>, <em>data_bank</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.open_repfile" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to open the report file (.rep) from HEC-RAS. To obtain the report file, see the doc of the function
open_hecras.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>report_file</strong> &#8211; a string with the name of the report file (.rep)</li>
<li><strong>reach_name</strong> &#8211; a list of string containing the name of the reaches/rivers in the order of the geo file,
which might not be the order of the sdf file.</li>
<li><strong>path</strong> &#8211; the path where the report file is stored (string)</li>
<li><strong>data_profile</strong> &#8211; the data from each profile from the geofile (output from the open_geofile function)</li>
<li><strong>data_bank</strong> &#8211; the position of the bank limit (output from the open_geofile function)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">velocity and the water surface elevation for each river profiles in a list of np.array,
the number of simulation (int) and the name of the river profile (list of string)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments and walk-through</strong></p>
<p>This function is used to open output from models which were not geo-referenced in hec-ras v5. It cannot be used if
the model was georeferenced (or at least one should make some tests before).</p>
<p>First, we obtain the water height. Then, we obtain the number of time step (which is called the number of
simulation by hec-ras). To get the number of time step, we count each outputs given (one by profiles) and we
divided it by the number of profile in the river. It is a bit indirect, but I did not find a simpler solution.</p>
<p>We get the name of each profile and reach. Then, we get the velocity data. We have in a case which is not
geo-referenced. By consequence, there are only three velocities: one the left bank, one in the main river channel
and one the right bank.  Next we get the distance along the profile for these three velocities. Finally, we use
the function reoder_reach for the same reason than in open_sdffile and open_xml.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.open_sdffile">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">open_sdffile</code><span class="sig-paren">(</span><em>sdf_file</em>, <em>reach_name</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.open_sdffile" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to load .sdf file from HEC-RAS v5 used if the model is georeferenced. To find how to obtain the
sdf file, read the doc of open_hecras.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sdf_file</strong> &#8211; the name of the sdf file (string)</li>
<li><strong>reach_name</strong> &#8211; a list of string containing the name of the reaches/rivers in the order of the geo file
which might not be the one of the sdf file. Output from open_geofile.</li>
<li><strong>path</strong> &#8211; the path where the file is stored (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">velocity, water height, river_name, number of  time step (nb_sim)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>To strat loading the sdf file, we open the sdf file. It is mostly a text file. Then we find velocity data and we
pass this velocity data from string to float. The process is a bit similar to the one used in the function
open_geofile with a healthy dose of regular expressions. We do this again for height data.</p>
<p>We also extract the name of the river, reaches and profile. The number of simulation (nb_sim) is a bit confusing
for a variable name. In fact, it is the number of time step. Hec-Ras considers that one simulation is the simulation
for one time step. Hence, nb_sim is more or less nb_timestep.</p>
<p>As in the xml file, we finally re-order the data as in the geo file. Indeed, it is possible to have different order
between the reaches in the geo file and in the sdf file. Here, we use the function reorder_reach for this.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.open_xmlfile">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">open_xmlfile</code><span class="sig-paren">(</span><em>xml_file</em>, <em>reach_name</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.open_xmlfile" title="Permalink to this definition">¶</a></dt>
<dd><p>This function open the xml file from HEC-RAS v4 to get the velocity and water surface elevation. To know how to
obtain this xml file, read the doc of open_hecras.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xml_file</strong> &#8211; the name of O0X.xml file from HEC-RAS. (string)</li>
<li><strong>reach_name</strong> &#8211; a list of string containing the name of the reaches/rivers in the order of the geo file
which might not be the one of the xml file.</li>
<li><strong>path</strong> &#8211; path to the xml file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">velocity and the water surface elevation for each river profiles (list of np.array),
the number of simulation(int) and the name of the river profile (list of string)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>To load the xml file, we first call the load_xml function. It is a function which check that the xml file is well
formed and which return the “root” part fo the xml. With this “root”, it is possible to load other part of the xml
file using the Etree module.</p>
<p>Then, we load the velocity and water height data from the xml file. We also load the name of the profiles and of
the reach names.  Next, we pass the data into float. For each velocity of height point, we get its position along
the profile (see below for format) and the value at this point.</p>
<p>Finally, we re-order the data as in the geo file. Indeed, it is possible to have different order between the reaches
in the geo file and in the xml file. The last part of this function is there to order all the data as in the geo
file. There is a function reorder_reach which does something similar, but could not be used by the output from the
xml file (it is slighty different). However the reorder_reach function and this part of the open_xml function is
very similar.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.pass_in_float_from_geo">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">pass_in_float_from_geo</code><span class="sig-paren">(</span><em>data_str</em>, <em>len_number</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.pass_in_float_from_geo" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to pass the string data into float for open_geofile() and open_sdffile(). It is in a function
because it is possible that two number are not separated by a space in the input data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_str</strong> &#8211; the data in a string form</li>
<li><strong>len_number</strong> &#8211; the number of digit for one number (int)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a np.array of float with 2 columns  (x,y) or (x,z)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.reorder_reach">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">reorder_reach</code><span class="sig-paren">(</span><em>wse</em>, <em>vel</em>, <em>riv_name</em>, <em>reach_name</em>, <em>reach_str</em>, <em>stream_str</em>, <em>nb_sim</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.reorder_reach" title="Permalink to this definition">¶</a></dt>
<dd><p>The order of the reach in HABBY is in the order given in the geo file. However, it can be given in any order
in the other file. (xml, sdf, rep,...). This function re-order the reaches based on their name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>wse</strong> &#8211; water height data (list of np.array for each profile)</li>
<li><strong>vel</strong> &#8211; velocity data (list of np.array for each profile)</li>
<li><strong>riv_name</strong> &#8211; the name of the profile (yeah I know it is not really logical as a name)</li>
<li><strong>reach_name</strong> &#8211; the name of the reach and stream (stream,reach) in the geo file order</li>
<li><strong>reach_str</strong> &#8211; the name of the reach in the anaylsed file order</li>
<li><strong>stream_str</strong> &#8211; the name of the stream in the anaylsed file order</li>
<li><strong>nb_sim</strong> &#8211; the number of simulation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">wse, vel, riv_name all re-ordered</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>The reach name should not have white space at the end/start but can have white space into them.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.update_output">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">update_output</code><span class="sig-paren">(</span><em>zone_v</em>, <em>coord_pro_old</em>, <em>data_profile</em>, <em>xy_h</em>, <em>nb_pro_reach_old</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.update_output" title="Permalink to this definition">¶</a></dt>
<dd><p>This function updates the form of the output so it is coherent with mascaret and rubar after the lateral
distribution of velocity for these two models. There are three important changes. First, coord_pro contains dist along
the profile (x) and height in addition to the coordinates. Secondly, vh_pro contains only height if height is above
or equal to zero. Thirdly, a point is created at the water limits and v and height are given at the same points.
nb_pro_reach is also modified as in mascaret. We want to modify it so it start by zero and is additive, i.e., that
it gives total number of profile before, not the number of profile by reach.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>zone_v</strong> &#8211; (x,y, dist along profile, v) for each time step. However, the zone are the one from the models.
They are different than the one from xy_h, which is unpractical for the rest of HABBY.</li>
<li><strong>coord_pro_old</strong> &#8211; the (x,y) coordinate for the profile</li>
<li><strong>data_profile</strong> &#8211; the distance along the porfile and height of each profile</li>
<li><strong>xy_h</strong> &#8211; the water height</li>
<li><strong>nb_pro_reach_old</strong> &#8211; the number of the profile by reach in the old form.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coord_pro, vh_pro, nb_pro_reach</p>
</td>
</tr>
</tbody>
</table>
<p>[doc to be finished]</p>
</dd></dl>

<div class="section" id="notes-on-hec-ras-outputs">
<h3>Notes on hec-ras outputs<a class="headerlink" href="#notes-on-hec-ras-outputs" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Data in HEC-RAS can be geo-referenced or not georeferenced. It is advised to geo-reference
all model in HEC-RAS. If the model is not geo-referenced, the function makes some assumptions to
load the data: 1) the river profile are straight and perpendicular to the river.
2) the last profile is at the end of the river.</li>
<li>To geo-reference a model in hec_ras: In the “geometric data” window, GIS tool, GIS Cut Line, Accept Display location, choose all profile</li>
<li>Numerical data are sometime not separated (0.4556 0.3453233.454 05.343). In this case, the number of digit is assumed to be 8 for the profile and 16 for the river coordinates.</li>
<li>Part of the profile can be vertical: The function also functions in this case.</li>
<li>There is sometimes more than one reach in the modelled river and these reaches sometimes form loops: The function load each reach one after the other.</li>
<li>The river reaches are sometimes not in the same order in the xml file and in the .goX file. The order of the .goX is used by the function. Reach are automatically re-ordered.</li>
<li>If the river is straight, the coordinates of the river are given differently. The function try to load the river in the “straight” style if the usual style fail.</li>
<li>The .goX file includes data on bridges and culvert. Currently, the function neglects this information.</li>
<li>Sometimes distances between profiles are not given in the .goX file. The function neglects the distance data of this profile as long as it is not the last profile.</li>
<li>The velocity data for the end and the beginning of the river profile is indicated by a large number (example 1.23e35 or -1.234e36). The function considers that velocity info is situated at the start of the profile if x&gt;-1e30 and at the end of the profile if x&gt; 1e30.</li>
<li>There are two concepts called “profile” in HEC-RAS: The river profiles and the simulation profiles. The river profiles are the geometry perpendicular to the river and the simulation profile are the different simulations.</li>
<li>Data in many of the example cases of HEC-RAS are in foot and miles. 1 miles = 5280 foot, and not 1000 foot.</li>
</ul>
</div>
</div>
<div class="section" id="hec-ras-model-2d">
<h2>Hec-ras model 2D<a class="headerlink" href="#hec-ras-model-2d" title="Permalink to this headline">¶</a></h2>
<p>in src/Hec_ras2D.py</p>
<p>This module contains the functions used to load the outputs from the hec-ras model in 2D.</p>
<span class="target" id="module-src.hec_ras2D"></span><dl class="function">
<dt id="src.hec_ras2D.figure_hec_ras2d">
<code class="descclassname">src.hec_ras2D.</code><code class="descname">figure_hec_ras2d</code><span class="sig-paren">(</span><em>v_all, h_all, elev_all, coord_p_all, coord_c_all, ikle_all, path_im, time_step=[0], flow_area=[0], max_point=-99</em><span class="sig-paren">)</span><a class="headerlink" href="#src.hec_ras2D.figure_hec_ras2d" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to plot figure of the output from hec-ras 2D.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>v_all</strong> &#8211; a list of np array representing the velocity at the center of the cells</li>
<li><strong>h_all</strong> &#8211; a list of np array representing the water depth at the center of the cells</li>
<li><strong>elev_all</strong> &#8211; a list of np array representing the mimium elevation of each cells</li>
<li><strong>coord_p_all</strong> &#8211; a list of np array representing the coordinates of the points of the grid</li>
<li><strong>coord_c_all</strong> &#8211; a list of np array representing the coordinates of the centers of the grid</li>
<li><strong>ikle_all</strong> &#8211; a list of np array representing the connectivity table
one array by flow area</li>
<li><strong>time_step</strong> &#8211; which time_step should be plotted (default, the first one)</li>
<li><strong>flow_area</strong> &#8211; which flow_area should be plotted (default, the first one)</li>
<li><strong>max_point</strong> &#8211; the number of cell to be drawn when reconstructing the grid (it might long)</li>
<li><strong>path_im</strong> &#8211; the path where the figure should be saved</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comment</strong></p>
<p>This function creates three figures which represent: a) the grid of the loaded models b) the water height and
c) the velocity.</p>
<p>The two last figures will be modified when the data will be loaded by node and not by cells. So we will not explai
n them here as they should be re-written.</p>
<p>The first figure is used to plot the gird. If we would plot the grid by drawing one side of each triangle
separately, it would be very long to draw. To optimize the process, we use the prepare_grid function.</p>
</dd></dl>

<dl class="function">
<dt id="src.hec_ras2D.load_hec_ras2d">
<code class="descclassname">src.hec_ras2D.</code><code class="descname">load_hec_ras2d</code><span class="sig-paren">(</span><em>filename</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.hec_ras2D.load_hec_ras2d" title="Permalink to this definition">¶</a></dt>
<dd><p>The goal of this function is to load 2D data from Hec-RAS in the version 5.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> &#8211; the name of the file containg the results of HEC-RAS in 2D. (string)</li>
<li><strong>path</strong> &#8211; the path where the file is (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">velocity and height at the center of the cells, the coordinate of the point of the cells,
the coordinates of the center of the cells and the connectivity table. Each output is a list of numpy array
(one array by 2D flow area)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>How to obtain the input file</strong></p>
<p>The file neede as input is an hdf5 file (.hdf) created automatically by Hec-Ras. There are many .hdf created by
Hec-Ras. The one to choose is the one with the extension p0X.hdf (not g0x.hdf). It is usually the largest file in
the results folder.</p>
<p><strong>Technical comments</strong></p>
<p>Outputs from HEC-RAS in 2D are in the hdf5 format. However, it is not possible to directly use the output of HEC-RAS
as an hdf5 input for HABBY. Indeed, even if they are both in hdf5, the formats of the hdf5 files are different
(and would miss some important info for HABBY).  So we still need to load the HEC-RAS data in HABBY even if in 2D.</p>
<p>This function should be modified because currently it gets the data by cells. However, we should get the
data by node. So this function should be changed.</p>
<p><strong>Walk-through</strong></p>
<p>The name and path of the file is given as input to the load_hec_ras_2D function. Usually this is done by the class
HEC_RAS() in the GUI.  We load the file using the h5py module. This module opens and reads hdf5 file.</p>
<p>Then we can read different part of the hdf5 file when we know the address of it (this is a bit like a file system).
In hdf5 file of Hec-RAS, this first thing is to get the names of the flow area in “Geometry/2D Flow Area”. In
general, this is the name of each reach, but it could be lake or pond also.</p>
<p>Then, we go to “Geometry/2D Flow Area/&lt;name&gt;/FacePoint Coordinates” to get the points forming the grid.
We can also get the connectivity table (or ikle) to the path “Geometry/2D Flow Area/&lt;name&gt;/Cells Face Point Indexes”
We also get the elevations of the cells. Currently, this is just the minimum elevation of the cells, but it should
be modified to get the elevation by node (in the vocabulary of HEC-RAS by “FacePoints”). We then get the water depth
by cell. Somethings should be done to get it by node. I think that we did have the elevation by node somewhere in
the hdf5 file. For there, water height can be found.
The velocity is given by face of the cells. It should be averaged differently to get it on the point and
not on the side.</p>
</dd></dl>

<dl class="function">
<dt id="src.hec_ras2D.main">
<code class="descclassname">src.hec_ras2D.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.hec_ras2D.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module independantly of HABBY.</p>
</dd></dl>

<dl class="function">
<dt id="src.hec_ras2D.prepare_grid">
<code class="descclassname">src.hec_ras2D.</code><code class="descname">prepare_grid</code><span class="sig-paren">(</span><em>ikle</em>, <em>coord_p</em>, <em>max_point=-99</em><span class="sig-paren">)</span><a class="headerlink" href="#src.hec_ras2D.prepare_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to put in the new form the data forming the grid to accelerate the plotting of the grid. This function creates
a list of points of the grid which are re-ordered compared to the usual list of grid point (the variable coord_p
here). These points are reordered so that it is possible to draw only one line to form the grid (one point can
appears more than once). The grid is drawn as one long line and not as a succession of small lines, which is
quicker. When this new list is created by prepare_function(), it is send back to figure-hec_ras_2D and plotted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ikle</strong> &#8211; the connectivity table</li>
<li><strong>coord_p</strong> &#8211; the coordinates of the point</li>
<li><strong>max_point</strong> &#8211; if the grid is very big, it is possible to only plot the first points, up to max_points (int)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list of x and y coordinates ordered.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.hec_ras2D.scatter_plot">
<code class="descclassname">src.hec_ras2D.</code><code class="descname">scatter_plot</code><span class="sig-paren">(</span><em>coord</em>, <em>data</em>, <em>data_name</em>, <em>my_cmap</em>, <em>s1</em>, <em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#src.hec_ras2D.scatter_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to plot the scatter of the data. Will not be used in the final version, but can be useful to
plot data by cells.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coord</strong> &#8211; the coordinates of the point</li>
<li><strong>data</strong> &#8211; the data to be plotted (np.array)</li>
<li><strong>data_name</strong> &#8211; the name of the data (string)</li>
<li><strong>my_cmap</strong> &#8211; the color map (string with matplotlib colormap name)</li>
<li><strong>s1</strong> &#8211; the size of the dot for the scatter</li>
<li><strong>t</strong> &#8211; the time step being plotted</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="mascaret">
<h2>Mascaret<a class="headerlink" href="#mascaret" title="Permalink to this headline">¶</a></h2>
<p>This module contains the functions used to load the outputs from the mascaret model.</p>
<span class="target" id="module-src.mascaret"></span><dl class="function">
<dt id="src.mascaret.correct_duplicate">
<code class="descclassname">src.mascaret.</code><code class="descname">correct_duplicate</code><span class="sig-paren">(</span><em>seq</em>, <em>send_warn</em>, <em>idfun=None</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.correct_duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>It is possible to have a vertical line on a profile (different h, identical x). This is not possible for HABBY and
the 2D grid. So this function correct duplicates along the profile.</p>
<p>A similiar function exists in rubar, for the case where input is (x,y) coordinates and not distance along the profile.
This function is inspired by <a class="reference external" href="https://www.peterbe.com/plog/uniqifiers-benchmark">https://www.peterbe.com/plog/uniqifiers-benchmark</a></p>
<p>It should be tested more as manage_grid sometime still send warning about duplicate data in profile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>seq</strong> &#8211; the list to be corrected (list)</li>
<li><strong>send_warn</strong> &#8211; a bool to avoid printing certains warning too many time</li>
<li><strong>idfun</strong> &#8211; support an optional transform function (not used)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the profile data without duplicate and the bollean which manages the warning.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.define_stream_network">
<code class="descclassname">src.mascaret.</code><code class="descname">define_stream_network</code><span class="sig-paren">(</span><em>node_number</em>, <em>start_node</em>, <em>end_node</em>, <em>angles</em>, <em>nb_pro_reach</em>, <em>nb_reach</em>, <em>abcisse</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.define_stream_network" title="Permalink to this definition">¶</a></dt>
<dd><p>This function extracts the stream network from the node and angle data. This is used if we have more than one
reach to define the geometry of the junction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>node_number</strong> &#8211; the start/end number of the reaches for each nodes (list of list)</li>
<li><strong>start_node</strong> &#8211; the numbers indicating the start of each reach (list)</li>
<li><strong>end_node</strong> &#8211; the numbers indicating the end of each reach</li>
<li><strong>angles</strong> &#8211; for each node the angle between the reach</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach</li>
<li><strong>nb_reach</strong> &#8211; the number of reach</li>
<li><strong>abcisse</strong> &#8211; the distance along the river of each reach</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the river coordinates and the unit vector indicating the river direction</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.figure_mascaret">
<code class="descclassname">src.mascaret.</code><code class="descname">figure_mascaret</code><span class="sig-paren">(</span><em>coord_pro, coord_r, xhzv_data, on_profile, nb_pro_reach, name_pro, name_reach, path_im, pro, plot_timestep=[-1], reach_plot=[0]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.figure_mascaret" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to plot the figures related to mascaret.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coord_pro</strong> &#8211; the cordinates (x,y,h, dist along the river) of the profiles</li>
<li><strong>coord_r</strong> &#8211; the coordinate (x,y) of the river</li>
<li><strong>name_pro</strong> &#8211; the name of the profile</li>
<li><strong>name_reach</strong> &#8211; the name of the reach</li>
<li><strong>on_profile</strong> &#8211; which result are on the profile. Some output are not the profiles.</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach (careful this is the number of profile, not the number of output)</li>
<li><strong>xhzv_data</strong> &#8211; the height and velcoity (x,h,v) list by time step</li>
<li><strong>profile</strong> (<em>pro</em>) &#8211; which profile to be plotted (list of int)</li>
<li><strong>plot_timestep</strong> &#8211; which timestep to be plotted</li>
<li><strong>reach_plot</strong> &#8211; the reach to be plotted for the river view</li>
<li><strong>path_im</strong> &#8211; the path where to save the figure</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.find_node">
<code class="descclassname">src.mascaret.</code><code class="descname">find_node</code><span class="sig-paren">(</span><em>node_number</em>, <em>reach_to_find</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.find_node" title="Permalink to this definition">¶</a></dt>
<dd><p>This function finds which node is a stream end or a stream start. It is associated by the function
define_stream_network()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>node_number</strong> &#8211; the list of list of the reaches linked with one node</li>
<li><strong>reach_to_find</strong> &#8211; the number indicating the start or end of the reach</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the node number, ordered as in the xcas file</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.flat_coord_pro">
<code class="descclassname">src.mascaret.</code><code class="descname">flat_coord_pro</code><span class="sig-paren">(</span><em>coord_pro</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.flat_coord_pro" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is not used anymroe.</p>
<p>The variable coord_pro was a list of profile by reach. Finally, it was useful to have each profile one after the
other with accounting for the reach. So we stop to use this function whose goal was to pass from one form of
coord_pro to the other form 9with or wihtout reach information).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coord_pro</strong> &#8211; the list of profile (x,y,h, dist along the river) by reach</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">coord_pro_f: a list of profile without the reach information. The list is flatten</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.get_geo_name_from_xcas">
<code class="descclassname">src.mascaret.</code><code class="descname">get_geo_name_from_xcas</code><span class="sig-paren">(</span><em>file_gen</em>, <em>path_gen</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.get_geo_name_from_xcas" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets the name of the .geo file from the .xcas xml file. It is not used yet, but it could be useful
in the GUI to simplify the loading of mascaret. The user would not need to give the name of the geo and the xcas
files separetly. However, it is not written in yet.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_gen</strong> &#8211; the xcas file</li>
<li><strong>path_gen</strong> &#8211; the path to the xcas file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the name of the .geo file (no path indicated)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.get_name_from_cas">
<code class="descclassname">src.mascaret.</code><code class="descname">get_name_from_cas</code><span class="sig-paren">(</span><em>file_gen</em>, <em>path_gen</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.get_name_from_cas" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets the name of the .geo file from the .cas text file. It is not used yet, but it could be useful
in the GUI to simplify the loading of mascaret. The user would not need to give the name of the geo and the cas
files separetly. However, it is not written in yet.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_gen</strong> &#8211; the name of .cas file (string)</li>
<li><strong>path_gen</strong> &#8211; the path to the cas file (string</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the name of the .geo file (no path indicated)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.is_this_res_on_the_profile">
<code class="descclassname">src.mascaret.</code><code class="descname">is_this_res_on_the_profile</code><span class="sig-paren">(</span><em>abscisse</em>, <em>xhzv_data_all</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.is_this_res_on_the_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>The output of mascaret can be given at points of the river where there is no profile.
The function here says which results are on the profiles. All profiles are linked with an output, but some output
are not linked with a profile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>abscisse</strong> &#8211; the distance between each profile (list of float)</li>
<li><strong>xhzv_data_all</strong> &#8211; the outputs from mascaret by time step</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list of bool of the length of xhzv_data, True on profile, False not on profile</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comment</strong></p>
<p>In the mascaret outputs, some rounding are suprising. For example, 0.49 can be transformed to 0.50 in an otehr file
(not 0.5). To avoid this type of problem, we says that outputs with a distance smaller than 3cm of the profile are
on the profile. If there are more than one output by profile, we takes the output which is the closest to the
profile.</p>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.load_mascaret">
<code class="descclassname">src.mascaret.</code><code class="descname">load_mascaret</code><span class="sig-paren">(</span><em>file_gen</em>, <em>file_geo</em>, <em>file_res</em>, <em>path_gen</em>, <em>path_geo</em>, <em>path_res</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.load_mascaret" title="Permalink to this definition">¶</a></dt>
<dd><p>The function is used to load the mascaret data. It load the geofile and the general file. Then, it re-forms the
geometrical data. Next, it loads the output data from mascaret. Fianally, it looks which outputs is close to
a profile and which outputs is not linked with a profile as there are some outputs given between profiles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_gen</strong> &#8211; the xcas .xml file giving general info about the model (string)</li>
<li><strong>file_geo</strong> &#8211; the file containting the profile data (.geo) (string)</li>
<li><strong>file_res</strong> &#8211; the files containting the mascaret output in the Optyca format (.opt) (string)</li>
<li><strong>path_gen</strong> &#8211; the path to the xcas file or .cas file (string). By default, choose the xcas file.</li>
<li><strong>path_geo</strong> &#8211; the path to the geo file (string)</li>
<li><strong>path_res</strong> &#8211; the path to the res file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the coordinates of the profile (x,y,z, dist along the profile), the coordinate of the river (x,y), name of
reach and profile, data height and velocity (list by time step), list of bollean indicating which data is
on the profile and the number of profile by reach.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.main">
<code class="descclassname">src.mascaret.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module separately.</p>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.open_geo_mascaret">
<code class="descclassname">src.mascaret.</code><code class="descname">open_geo_mascaret</code><span class="sig-paren">(</span><em>file_geo</em>, <em>path_geo</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.open_geo_mascaret" title="Permalink to this definition">¶</a></dt>
<dd><p>This function load the mascaret geo file. Generally, the profile are not geo-referenced when using this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_geo</strong> &#8211; the name of the geo file (string)</li>
<li><strong>path_geo</strong> &#8211; the path to the geo file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the profile data (x,y), profile name (list of string),
brief name (list of string), the number of profile in each reach and distance along the river/abcisse (list)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.open_res_file">
<code class="descclassname">src.mascaret.</code><code class="descname">open_res_file</code><span class="sig-paren">(</span><em>file_res</em>, <em>path_res</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.open_res_file" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to load the output from mascaret (.opt file). The format is Optyca.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_res</strong> &#8211; the name of the .opt file (string)</li>
<li><strong>path_res</strong> &#8211; the path to this file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.open_rub_file">
<code class="descclassname">src.mascaret.</code><code class="descname">open_rub_file</code><span class="sig-paren">(</span><em>file_res</em>, <em>path_res</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.open_rub_file" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to open the binary output file from mascaret (.rub format).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_res</strong> &#8211; the name of the rub binary file (string)</li>
<li><strong>path_res</strong> &#8211; the path to this file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">xhzv_data, timestep</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comment</strong></p>
<p>The binary output file was done using a program written in FORTRAN. So there are often suprising
octet which are added to the binary file. Be careful before changing anything.</p>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.profil_coord_non_georef">
<code class="descclassname">src.mascaret.</code><code class="descname">profil_coord_non_georef</code><span class="sig-paren">(</span><em>coord_pro</em>, <em>coord_r</em>, <em>nr</em>, <em>nb_pro_reach</em>, <em>bt=None</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.profil_coord_non_georef" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets the coordinates (x,y) of the profile as masacret outputs are not georeferenced.</p>
<p>Hypothesis: The river and the profile are straight. The profile is perpendicular to the river.
The river pass at the minimum elevation of the river bed. If there is a distinction between the main bed the
secondary bed is given, we take the minimum elevation of the main bed</p>
<p>The origin of the coordinate system is the start of the river.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coord_pro</strong> &#8211; the coordinate of the profile. This variable is not in the general coordinate system,
just distance along the profile and bed elevation (p, dist, h)</li>
<li><strong>coord_r</strong> &#8211; the river coordinates</li>
<li><strong>n</strong> &#8211; the vector indicating the river direction</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach (additive)</li>
<li><strong>bt</strong> &#8211; optional, it indicates which points in the profiles are in the minor/major bed</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the velocity and height data, the timestep</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.river_coord_non_georef_from_cas">
<code class="descclassname">src.mascaret.</code><code class="descname">river_coord_non_georef_from_cas</code><span class="sig-paren">(</span><em>file_gen</em>, <em>path_gen</em>, <em>abcisse</em>, <em>nb_pro_reach</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.river_coord_non_georef_from_cas" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the coordinates of the river based on the cas text file. If there are only one river, this is an easy task as
the river is straight. If there are more than one reach, the junctions and the angles between the reach sould be
managed using the define_stream_network function and the information in the .cas file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_gen</strong> &#8211; the .cas file whcih contains general info (string)</li>
<li><strong>path_gen</strong> &#8211; the path to this file (string)</li>
<li><strong>abcisse</strong> &#8211; ditance along the profiles</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of reach by profile</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the river coordinate and the unit vector indicating the river direction</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.river_coord_non_georef_from_xcas">
<code class="descclassname">src.mascaret.</code><code class="descname">river_coord_non_georef_from_xcas</code><span class="sig-paren">(</span><em>file_gen</em>, <em>path_gen</em>, <em>abcisse</em>, <em>nb_pro_reach</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.river_coord_non_georef_from_xcas" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the coordinates of the river based on the xcas xml file. If there are only one river, this is an easy task as
the river is straight. If there are more than one reach, the junctions and the angles between the reach sould be
managed using the define_stream_network function and the information in the .xcas file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_gen</strong> &#8211; the .xcas file with the information concerning the reach (string)</li>
<li><strong>path_gen</strong> &#8211; the path to the xcas file (string)</li>
<li><strong>abcisse</strong> &#8211; the distance along the river</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coord_r the coordinate of the river</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="river-2d">
<h2>River 2D<a class="headerlink" href="#river-2d" title="Permalink to this headline">¶</a></h2>
<p>This module contains the functions used to load the outputs from the River2D model.</p>
<span class="target" id="module-src.river2d"></span><dl class="function">
<dt id="src.river2d.figure_river2d">
<code class="descclassname">src.river2d.</code><code class="descname">figure_river2d</code><span class="sig-paren">(</span><em>xyzhv</em>, <em>ikle</em>, <em>path_im</em>, <em>t=0</em><span class="sig-paren">)</span><a class="headerlink" href="#src.river2d.figure_river2d" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to plot the output from river 2d. Need hec-ras2d as import because it re-used most of the plot from this
script.</p>
<p>Plot only one time step because river 2d output have one file by time step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xyzhv</strong> &#8211; the x,y, coordinates of the node (h,v are nodal output in river 2d), the river bed, the water height
and the velocity (one data by column, row are node)</li>
<li><strong>ikle</strong> &#8211; connectivity table</li>
<li><strong>path_im</strong> &#8211; the path where to save the figure</li>
<li><strong>t</strong> &#8211; the time step which is being plotted</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.river2d.get_rid_of_lines">
<code class="descclassname">src.river2d.</code><code class="descname">get_rid_of_lines</code><span class="sig-paren">(</span><em>datahere</em>, <em>nb_data</em><span class="sig-paren">)</span><a class="headerlink" href="#src.river2d.get_rid_of_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>There are lines which are useless in the cdg file. This function is used to correct ikle and data_node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>datahere</strong> &#8211; the data with the empty lines</li>
<li><strong>nb_data</strong> &#8211; nb_node or nb_el</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">datahere wihtout the useless lines</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.river2d.load_river2d_cdg">
<code class="descclassname">src.river2d.</code><code class="descname">load_river2d_cdg</code><span class="sig-paren">(</span><em>file_cdg</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.river2d.load_river2d_cdg" title="Permalink to this definition">¶</a></dt>
<dd><p>The file to load the output data from River2D. Careful the input data of River2D has the same ending and nearly
the same format as the output. However, it is nessary to have the output here. River2D gives one cdg. file by timestep.
Hence, this function read only one timeste. HABBY read all time step by calling this function once for each time step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_cdg</strong> &#8211; the name of the cdg file (string)</li>
<li><strong>path</strong> &#8211; the path to this file (string).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the velcoity and height data, the coordinate and the connectivity table.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.river2d.main">
<code class="descclassname">src.river2d.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.river2d.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module.</p>
</dd></dl>

</div>
<div class="section" id="rubar">
<h2>Rubar<a class="headerlink" href="#rubar" title="Permalink to this headline">¶</a></h2>
<p>This module contains the functions used to load the Rubar data in 2D and 1D.</p>
<span class="target" id="module-src.rubar"></span><dl class="function">
<dt id="src.rubar.correct_duplicate_xy">
<code class="descclassname">src.rubar.</code><code class="descname">correct_duplicate_xy</code><span class="sig-paren">(</span><em>seq3D</em>, <em>send_warn</em>, <em>idfun=None</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.correct_duplicate_xy" title="Permalink to this definition">¶</a></dt>
<dd><p>it is possible to have a vertical line on a profile (different h, identical x). This is not good for the 2D grid.
So this function correct this case for rubar. A similiar function exists in mascaret.py, for the case where input
is the distance along the profile and not (x,y) coordinates.
inspired by <a class="reference external" href="https://www.peterbe.com/plog/uniqifiers-benchmark">https://www.peterbe.com/plog/uniqifiers-benchmark</a>
:param seq3D: the list to be corrected in this case (x,y,z,dist along the profile)
:param send_warn a bool to avoid printing the warning too many time
:param idfun: support an optional transform function (not tested)
:return:</p>
</dd></dl>

<dl class="function">
<dt id="src.rubar.figure_rubar1d">
<code class="descclassname">src.rubar.</code><code class="descname">figure_rubar1d</code><span class="sig-paren">(</span><em>coord_pro, lim_riv, data_xhzv, name_profile, path_im, pro, plot_timestep, nb_pro_reach=[0, 10000000000]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.figure_rubar1d" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to plot the loaded RUBAR 1D data
:param coord_pro: the cooedinate of the profile (x, y, z, dist along the river)
:param lim_riv: the right bank, river center, left bank
:param data_xhzv the data by time step with x the distance along the river, h the water height and v the vlocity
:param cote: the altitude of the river center
:param name_profile the name of the profile
:param path_im: the path where to save the image
:param pro: the profile number which should be plotted
:param plot_timestep: which timestep should be plotted
:param nb_pro_reach: the number of profile by reach
:return: none</p>
</dd></dl>

<dl class="function">
<dt id="src.rubar.figure_rubar2d">
<code class="descclassname">src.rubar.</code><code class="descname">figure_rubar2d</code><span class="sig-paren">(</span><em>xy, coord_c, ikle, v, h, path_im, time_step=[-1]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.figure_rubar2d" title="Permalink to this definition">¶</a></dt>
<dd><p>the function to plot the rubar 2d data
:param xy: coordinates of the points
:param coord_c: the center of the point
:param ikle: connectivity table
:param v: speed
:param h: height
:param path_im where to save the figure
;param time_step which will be plotted
:return:</p>
</dd></dl>

<dl class="function">
<dt id="src.rubar.get_triangular_grid">
<code class="descclassname">src.rubar.</code><code class="descname">get_triangular_grid</code><span class="sig-paren">(</span><em>ikle</em>, <em>coord_c</em>, <em>xy</em>, <em>h</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.get_triangular_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>In Rubar it is possible to have non-triangular cells. You can have a grid composed a mixed of pentagonal, 4-sided
and triangluar cells. This function transform the grid to a triangular grid
:param ikle: the connectivity table
:param coord_c: the coordinate of the centroid of the cell
:param xy the points of the grid
:param h data on water height
:param v data on velocity
:return: the updated ikle, point_c and xy</p>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_coord_1d">
<code class="descclassname">src.rubar.</code><code class="descname">load_coord_1d</code><span class="sig-paren">(</span><em>name_rbe</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_coord_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>the function to load the rbe file, which is an xml file.
:param name_rbe: The name fo the rbe files
:param path: the path to this file
:return: the coordinates of the profiles and the coordinates of the right bank, center of the river, left bank
(list of np.array with x,y,z coordinate), name of the profile (list of string), dist along the river (list of float)
number of cells (int)</p>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_dat_2d">
<code class="descclassname">src.rubar.</code><code class="descname">load_dat_2d</code><span class="sig-paren">(</span><em>geofile</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_dat_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>the function to load the geomtery info for the 2D case, using the .dat file
it is close to the .mai file but with more information (number of side and more complicated connectivity table)
:param geofile: the .mai file which contain the connectivity table and the (x,y)
:param path: the path to this file
:return: connectivity table, point coordinates, coodinantes of the cell centers</p>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_data_1d">
<code class="descclassname">src.rubar.</code><code class="descname">load_data_1d</code><span class="sig-paren">(</span><em>name_data_vh</em>, <em>path</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_data_1d" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name_data_vh</strong> &#8211; the name of the profile.ETUDE file</li>
<li><strong>path</strong> &#8211; the path to this file</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param x the distance along the river
:return: data x, velocity height, cote for each time step (list of np.array), time step</p>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_mai_1d">
<code class="descclassname">src.rubar.</code><code class="descname">load_mai_1d</code><span class="sig-paren">(</span><em>mailfile</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_mai_1d" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mailfile</strong> &#8211; the name of the file which contain the (x,z) data</li>
<li><strong>path</strong> &#8211; the path to this file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">x of the river, np.array and the number of mail</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_mai_2d">
<code class="descclassname">src.rubar.</code><code class="descname">load_mai_2d</code><span class="sig-paren">(</span><em>geofile</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_mai_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>the function to load the geomtery info for the 2D case
:param geofile: the .mai file which contain the connectivity table and the (x,y)
:param path: the path to this file
:return: connectivity table, point coordinates, coodinantes of the cell centers</p>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_rubar1d">
<code class="descclassname">src.rubar.</code><code class="descname">load_rubar1d</code><span class="sig-paren">(</span><em>geofile</em>, <em>data_vh</em>, <em>pathgeo</em>, <em>pathdata</em>, <em>path_im</em>, <em>savefig</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_rubar1d" title="Permalink to this definition">¶</a></dt>
<dd><p>the function to load the RUBAR data in 1D
:param geofile: the name of .rbe file which gives the coordinates of each profile - string
#(:param mail: the name of the file which given the position of the data point )
:param data_vh: the profile.ETUDE file which contains the height and velocity data
:param pathgeo the path to the geofile - string
:param pathdata the path to the data_vh file
:param path_im the file where to save the image
:param savefig: a boolean. If True create and save the figure.
:return: coordinates of the profile (x,y,z dist along the profile) coordinates (x,y) of the river and the bed,
data xhzv by time step where x is the distance along the river, h the water height, z the elevation of the bed
and v the velocity</p>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_rubar2d">
<code class="descclassname">src.rubar.</code><code class="descname">load_rubar2d</code><span class="sig-paren">(</span><em>geofile</em>, <em>tpsfile</em>, <em>pathgeo</em>, <em>pathtps</em>, <em>path_im</em>, <em>save_fig</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_rubar2d" title="Permalink to this definition">¶</a></dt>
<dd><p>the function to load the RUBAR data in 2D
:param geofile: the name of the .mai or .dat file which contains the connectivity table and the (x,y)
:param tpsfile: the name of the .tps file
:param pathgeo : path to the geo file
:param pathtps : path to the tps file
:param path_im: the path where to save the figure
:param save_fig: boolean indicated if the figures should be created or not
all strings input
:return: (x,y), ikle velocity and height at the center of the cells, the coordinate of the point of the cells,
the coordinates of the center of the cells and the connectivity table.</p>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_tps_2d">
<code class="descclassname">src.rubar.</code><code class="descname">load_tps_2d</code><span class="sig-paren">(</span><em>tpsfile</em>, <em>path</em>, <em>nb_cell</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_tps_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>the function to load the data in the 2D rubar case
:param tpsfile: the name of the file with the data for the 2d case
:param path:
:param nb_cell the number of cell extracted from the .mai file
:return: v, h, timestep (all in list of np.array)</p>
</dd></dl>

<dl class="function">
<dt id="src.rubar.m_file_load_coord_1d">
<code class="descclassname">src.rubar.</code><code class="descname">m_file_load_coord_1d</code><span class="sig-paren">(</span><em>geofile_name</em>, <em>pathgeo</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.m_file_load_coord_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>the function to load the m.ETUDE file which is based on .st format from cemagref. When we use the M.ETUDE file
instead of the rbe file, more than one reach can be studied but the center and side of the river is not
indicated anymore
:param geofile_name: The name to the file
:param pathgeo: the path to this file
:return: the coordinates of the profiles
(list of np.array with x,y,z coordinate), name of the profile (list of string), dist along the river (list of float)
number of profile by reach</p>
</dd></dl>

<dl class="function">
<dt id="src.rubar.main">
<code class="descclassname">src.rubar.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.main" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="telemac">
<h2>Telemac<a class="headerlink" href="#telemac" title="Permalink to this headline">¶</a></h2>
<p>This module contains the function used to load the Telemac data.</p>
<span class="target" id="module-src.selafin_habby1"></span><p>Selafin file format reader for Telemac 2D
Adapted from the original script &#8216;parserSELAFIN.py&#8217;</p>
<blockquote>
<div>from the open Telemac distribution</div></blockquote>
<dl class="class">
<dt id="src.selafin_habby1.Selafin">
<em class="property">class </em><code class="descclassname">src.selafin_habby1.</code><code class="descname">Selafin</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin" title="Permalink to this definition">¶</a></dt>
<dd><p>Selafin reader
Create an object for reading data from a slf file
:param &#8216;filename&#8217;: the name of the binary Selafin file</p>
<dl class="method">
<dt id="src.selafin_habby1.Selafin.addcontent">
<code class="descname">addcontent</code><span class="sig-paren">(</span><em>fileName</em>, <em>times</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.addcontent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.appendcoretimeslf">
<code class="descname">appendcoretimeslf</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.appendcoretimeslf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.appendcorevarsslf">
<code class="descname">appendcorevarsslf</code><span class="sig-paren">(</span><em>varsor</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.appendcorevarsslf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.appendheaderslf">
<code class="descname">appendheaderslf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.appendheaderslf" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the header file</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.getheaderfloatsslf">
<code class="descname">getheaderfloatsslf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.getheaderfloatsslf" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the mesh coordinates</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.getheaderintegersslf">
<code class="descname">getheaderintegersslf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.getheaderintegersslf" title="Permalink to this definition">¶</a></dt>
<dd><p>Get dimensions and descritions (mesh)</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.getheadermetadataslf">
<code class="descname">getheadermetadataslf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.getheadermetadataslf" title="Permalink to this definition">¶</a></dt>
<dd><p>Get header information</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.gettimehistoryslf">
<code class="descname">gettimehistoryslf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.gettimehistoryslf" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the timesteps</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.getvalues">
<code class="descname">getvalues</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.getvalues" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the values for the variables at time t</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.getvariablesat">
<code class="descname">getvariablesat</code><span class="sig-paren">(</span><em>frame</em>, <em>varindexes</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.getvariablesat" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the values for the variables at a particular time step</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.putcontent">
<code class="descname">putcontent</code><span class="sig-paren">(</span><em>fileName</em>, <em>times</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.putcontent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="src.selafin_habby1.getendianfromchar">
<code class="descclassname">src.selafin_habby1.</code><code class="descname">getendianfromchar</code><span class="sig-paren">(</span><em>fileslf</em>, <em>nchar</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.getendianfromchar" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Get the endian encoding</dt>
<dd>&#8220;&lt;&#8221; means little-endian
&#8220;&gt;&#8221; means big-endian</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="src.selafin_habby1.getfloattypefromfloat">
<code class="descclassname">src.selafin_habby1.</code><code class="descname">getfloattypefromfloat</code><span class="sig-paren">(</span><em>fileslf</em>, <em>endian</em>, <em>nfloat</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.getfloattypefromfloat" title="Permalink to this definition">¶</a></dt>
<dd><p>Get float precision</p>
</dd></dl>

<dl class="function">
<dt id="src.selafin_habby1.load_telemac">
<code class="descclassname">src.selafin_habby1.</code><code class="descname">load_telemac</code><span class="sig-paren">(</span><em>namefilet</em>, <em>pathfilet</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.load_telemac" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which load the telemac data using the Selafin class
:param namefilet: the name of the selafin file
:param pathfilet: the path to this file
:return: velocity, height, coord_p, ikle</p>
</dd></dl>

<dl class="function">
<dt id="src.selafin_habby1.plot_vel_h">
<code class="descclassname">src.selafin_habby1.</code><code class="descname">plot_vel_h</code><span class="sig-paren">(</span><em>coord_p2, h, v, path_im, timestep=[-1]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.plot_vel_h" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>a function to plot the velocity and height which are the output from TELEMAC</dt>
<dd>:param coord_p2 the coordinates of the point froming the grid
:param h the  water heigh
:param v the velocity
:param path_im the path where the image should be saved
:param timestep, which time step should be plotted</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="load-habby-hdf5-file">
<h2>Load HABBY hdf5 file<a class="headerlink" href="#load-habby-hdf5-file" title="Permalink to this headline">¶</a></h2>
<p>This module contains some functions to load and manage hdf5 input/outputs. This is still in progress.</p>
<span class="target" id="module-src.load_hdf5"></span><dl class="function">
<dt id="src.load_hdf5.get_all_filename">
<code class="descclassname">src.load_hdf5.</code><code class="descname">get_all_filename</code><span class="sig-paren">(</span><em>dirname</em>, <em>ext</em><span class="sig-paren">)</span><a class="headerlink" href="#src.load_hdf5.get_all_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets the name of all file with a particular extension in a folder. Useful to get all the output
from one hydraulic model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dirname</strong> &#8211; the path to the directory (string)</li>
<li><strong>ext</strong> &#8211; the extension (.txt for example). It is a string, the point needs to be the first character.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list with the filename (filename+dir) for each extension</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.load_hdf5.load_hdf5_hyd">
<code class="descclassname">src.load_hdf5.</code><code class="descname">load_hdf5_hyd</code><span class="sig-paren">(</span><em>hdf5_name_hyd</em><span class="sig-paren">)</span><a class="headerlink" href="#src.load_hdf5.load_hdf5_hyd" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to load the 2D hydrological data contains in the hdf5 file in the form required by HABBY.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hdf5_name_hyd</strong> &#8211; path and filename of the hdf5 file (string)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the connectivity table, the coordinates of the point, the height data, the velocity data on the coordinates.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.load_hdf5.load_hdf5_sub">
<code class="descclassname">src.load_hdf5.</code><code class="descname">load_hdf5_sub</code><span class="sig-paren">(</span><em>hdf5_name_sub</em><span class="sig-paren">)</span><a class="headerlink" href="#src.load_hdf5.load_hdf5_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to load the substrate data contained in the hdf5 file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hdf5_name_sub</strong> &#8211; path and file name to the hdf5 file (string)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.load_hdf5.open_hdf5">
<code class="descclassname">src.load_hdf5.</code><code class="descname">open_hdf5</code><span class="sig-paren">(</span><em>hdf5_name</em><span class="sig-paren">)</span><a class="headerlink" href="#src.load_hdf5.open_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function which open an hdf5 file and check that it exists. it does not load the data. It only opens the
files.
:param hdf5_name: the path and name of the hdf5 file (string)</p>
</dd></dl>

<div class="section" id="form-of-the-hdf5-files">
<h3>Form of the hdf5 files<a class="headerlink" href="#form-of-the-hdf5-files" title="Permalink to this headline">¶</a></h3>
<p>Here is the actual form of the hdf5 containing the 2D hydrological data.</p>
<ul class="simple">
<li>Number of timestep: Data_gen/Nb_timestep</li>
<li>Number of reach: Data_gen/Nb_reach</li>
<li>Connectivity table for the whole profile: Data_2D/Whole_Profile/Reach_&lt;r&gt;/ikle</li>
<li>Connectivity table for the wetted area (by time step): Data_2D/Timestep&lt;t&gt;/Reach_&lt;r&gt;/ikle</li>
<li>Coordinates for the whole profile: Data_2D/Whole_Profile/Reach_&lt;r&gt;/point_all</li>
<li>Coordinates for the wetted area (by time steps): Data_2D/Timestep&lt;t&gt;/Reach_&lt;r&gt;/point_all</li>
<li>Data for the velocity: Data_2D/Timestep&lt;t&gt;/Reach_&lt;r&gt;/inter_vel_all</li>
<li>Data for the height:  Data_2D/Timestep&lt;t&gt;/Reach_&lt;r&gt;/inter_h_all</li>
</ul>
<p>Here is the actual form of the hdf5 containing the substrate data.</p>
<ul class="simple">
<li>the coordinate of the point forming the substrate &#8220;grid&#8221;: coord_p_sub/</li>
<li>the connectivity table of the substrate &#8220;grid&#8221;: ikle_sub/</li>
<li>Substrate data; not done yet</li>
</ul>
</div>
</div>
<div class="section" id="module-src.dist_vistess2">
<span id="velocity-distribution"></span><h2>Velocity distribution<a class="headerlink" href="#module-src.dist_vistess2" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="src.dist_vistess2.dist_velocity_hecras">
<code class="descclassname">src.dist_vistess2.</code><code class="descname">dist_velocity_hecras</code><span class="sig-paren">(</span><em>coord_pro</em>, <em>xhzv_data_all</em>, <em>manning_pro</em>, <em>nb_point=-99</em>, <em>eng=1.0</em>, <em>on_profile=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.dist_vistess2.dist_velocity_hecras" title="Permalink to this definition">¶</a></dt>
<dd><p>This function distribute the velocity along the profile using the method from hec-ras
described in the hydraulic reference manual p 4-20 (Flow distribtion calculation)
:param coord_pro: the coordinates and elevation of the river bed for each profile (x,y, h, dist along the profile)
this list is flatten No reach info.
:param xhzv_data_all: water height and velocity at each profile, 1D
:param manning_pro the manning coefficient for zone between point of each profile
for a particular profile, the length of manning_pro is the length of coord_pro[0]
:param nb_point: number of velocity points (-99 takes the profil form as the velocity points)
:param on_profile: Mascaret also gives outputs in poitns between profile. on_profile is true if the results are</p>
<blockquote>
<div>close or on the profile (les than 3cm of difference), not important for rubar or other</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>eng</strong> &#8211; in case the output from hec-ras are in US unit (eng=1 for SI unit and 1.486 for US unit)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the velocity for each profile by time step (x,v)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.dist_vistess2.get_manning">
<code class="descclassname">src.dist_vistess2.</code><code class="descname">get_manning</code><span class="sig-paren">(</span><em>manning1</em>, <em>nb_point</em>, <em>nb_profil</em>, <em>coord_pro</em><span class="sig-paren">)</span><a class="headerlink" href="#src.dist_vistess2.get_manning" title="Permalink to this definition">¶</a></dt>
<dd><p>A fucntion to create an array with the manning value when a single float is given as info.
:param manning1: the manning value (can be a value or an array)
:param nb_point: the number of velocity point by profile
:param nb_profil: the number of profile
:param coord_pro: necessary if the number is -99 as we needs to know the length of each profile
:return:</p>
</dd></dl>

<dl class="function">
<dt id="src.dist_vistess2.get_manning_arr">
<code class="descclassname">src.dist_vistess2.</code><code class="descname">get_manning_arr</code><span class="sig-paren">(</span><em>manning_arr</em>, <em>nb_point</em>, <em>coord_pro</em><span class="sig-paren">)</span><a class="headerlink" href="#src.dist_vistess2.get_manning_arr" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to create the manning array when manning data is loaded using a text file, the form of the array is
p, dist, n where p is the profile, dist is the distance along the profile and n is manning
:param manning_arr: the data for manning
:param nb_point: the number of velocity point by profile
:param coord_pro: x,y,dist
:return:</p>
</dd></dl>

<dl class="function">
<dt id="src.dist_vistess2.main">
<code class="descclassname">src.dist_vistess2.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.dist_vistess2.main" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="src.dist_vistess2.plot_dist_vit">
<code class="descclassname">src.dist_vistess2.</code><code class="descname">plot_dist_vit</code><span class="sig-paren">(</span><em>v_pro</em>, <em>coord_pro</em>, <em>xhzv_data</em>, <em>plot_timestep</em>, <em>pro</em>, <em>name_pro=[]</em>, <em>on_profile=[]</em>, <em>zone_v_all=[]</em>, <em>data_profile=[]</em>, <em>xy_h_all=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.dist_vistess2.plot_dist_vit" title="Permalink to this definition">¶</a></dt>
<dd><p>this function plot the calculated velocity distribution
:param v_pro: the calculated velcocity distribution by time step
:param coord_pro: the coordinate of the profiles
:param xhzv_data: the output data from the model, before the velocity distrbution
:param plot_timestep: which time step to be plottied
:param name_pro: the name of the profile (optionnal just for the title)
:param pro: which porfile to be plotted
:param on_profile, select the data which is on the profile
:param zone_v: output from hec-ras used to test dist_vitesse
:param data_profile: output from hec-ras used to test dist_vitesse
:param xy_h: output from hec-ras used to test dist_vitesse
:return: figures</p>
</dd></dl>

<dl class="function">
<dt id="src.dist_vistess2.preparetest_velocity">
<code class="descclassname">src.dist_vistess2.</code><code class="descname">preparetest_velocity</code><span class="sig-paren">(</span><em>coord_pro</em>, <em>vh_pro_orr</em>, <em>v_in</em><span class="sig-paren">)</span><a class="headerlink" href="#src.dist_vistess2.preparetest_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes the output from hec-ras, with the velocity distrbution already present, and
transform these output into input for dist_vel.
:param coord_pro: the coordinate of the profile (x,y,h,dist along profile)
:param vh_pro_orr: the velocity distribution which is the output from hec ras (produced by hec-ras06.py)
:param v_in the uni-dimensional velocity
:return:</p>
</dd></dl>

<span class="target" id="module-src.estimhab"></span><dl class="function">
<dt id="src.estimhab.estimhab">
<code class="descclassname">src.estimhab.</code><code class="descname">estimhab</code><span class="sig-paren">(</span><em>qmes</em>, <em>width</em>, <em>height</em>, <em>q50</em>, <em>qrange</em>, <em>substrat</em>, <em>path_bio</em>, <em>fish_name</em>, <em>path_im</em>, <em>pict=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.estimhab.estimhab" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to run the estimhab model. Unit in meter amd m^3/sec
:param qmes the two measured discharge
:param width the two measured width
:param height the two measured height
:param q50 the natural median discharge
:param qrange the range of discharge
:param substrat mean height of substrat
:param pict if true the figure is shown. If false, the figure is not shown
:param path_im, the path where the image should be saved
:param path_bio the path to the xml file with the information on the fishes
:param fish_name the name of the fish which have to be analyzed
:return Habitat value and useful surface (VH and SPU) as a function of discharge</p>
</dd></dl>

<dl class="function">
<dt id="src.estimhab.main">
<code class="descclassname">src.estimhab.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.estimhab.main" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="src.estimhab.pass_to_float_estimhab">
<code class="descclassname">src.estimhab.</code><code class="descname">pass_to_float_estimhab</code><span class="sig-paren">(</span><em>var_name</em>, <em>root</em><span class="sig-paren">)</span><a class="headerlink" href="#src.estimhab.pass_to_float_estimhab" title="Permalink to this definition">¶</a></dt>
<dd><p>a small function to pass from xml element to float
:param root: the root of the open xml file
:param var_name: the name of the attribute in the xml file
:return: the float data</p>
</dd></dl>

<span class="target" id="module-src.stathab_c"></span><dl class="class">
<dt id="src.stathab_c.Stathab">
<em class="property">class </em><code class="descclassname">src.stathab_c.</code><code class="descname">Stathab</code><span class="sig-paren">(</span><em>name_prj</em>, <em>path_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab" title="Permalink to this definition">¶</a></dt>
<dd><p>The class for the Stathab model</p>
<dl class="method">
<dt id="src.stathab_c.Stathab.create_hdf5">
<code class="descname">create_hdf5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.create_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to create an hdf5 file from the loaded txt
:return: the &#8220;name_prj&#8221;_STATHAB.h5 an hdf5 file with the info from stathab</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.dengauss">
<code class="descname">dengauss</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.dengauss" title="Permalink to this definition">¶</a></dt>
<dd><p>gaussian density, used only for debugging purposes.
NOT USED IN Habby, but can be useful if scipy is not available
(remplace all stat.norm.cdf with dengauss -&gt; no need for scipy)
:param x: the parameter of the gaussian
:return:</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.dist_h">
<code class="descname">dist_h</code><span class="sig-paren">(</span><em>sh0</em>, <em>h0</em>, <em>bornh</em>, <em>h</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.dist_h" title="Permalink to this definition">¶</a></dt>
<dd><p>The calculation of height distribution  acrros the river
The distribution is a mix of an exponential and guassian.
:param sh0: the sh of the original data
sh is the parameter of the distribution, gives the relative importance of ganussian and exp distrbution
:param h the mean height data
:param h0 the mean height
:param bornh the limits of each class of height
:return: disth the distribution of heights across the river for the mean height h.</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.dist_v">
<code class="descname">dist_v</code><span class="sig-paren">(</span><em>h</em>, <em>d</em>, <em>bornv</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.dist_v" title="Permalink to this definition">¶</a></dt>
<dd><p>The calculation of velocity distribution  acrros the river
The distribution is a mix of an exponential and guassian.
:param h: the height which is related to the mean velocity v
:param d granulo moyenne
:param bornv: the born of the velocity
:param v: the mean velocity
:return: the distribution of velocity across the river</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.find_sh0">
<code class="descname">find_sh0</code><span class="sig-paren">(</span><em>disthmesr</em>, <em>h0</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.find_sh0" title="Permalink to this definition">¶</a></dt>
<dd><p>the function to find sh0, using a minimzation technique (NOT USE!!)
!!!!!! possibly an error on the bornes?!!!!!!
:param disthmesr: the measured distribution of height
:param h0 the measured mean height
:return: the optimized sh0</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.find_sh0_maxvrais">
<code class="descname">find_sh0_maxvrais</code><span class="sig-paren">(</span><em>disthmesr</em>, <em>h0</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.find_sh0_maxvrais" title="Permalink to this definition">¶</a></dt>
<dd><p>the function to find sh0, using the maximum of vraisemblance.
This function aims at reproducing the results from the c++ code. hence, no use of scipy
:param disthmesr: the measured distribution of height
:param h0 the measured mean height
:return: the optimized sh0</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.load_stathab_from_hdf5">
<code class="descname">load_stathab_from_hdf5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.load_stathab_from_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to load the file from an hdf5 whose name is given  in the xml project file
:return:</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.load_stathab_from_txt">
<code class="descname">load_stathab_from_txt</code><span class="sig-paren">(</span><em>reachname_file</em>, <em>end_file_reach</em>, <em>name_file_allreach</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.load_stathab_from_txt" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to read and check the input from stathab based on the text files.
All files should be in the same folder.
The file Pref.txt is read in run_stathab.
If self.fish_chosen is not present, all fish in the preference file are read.
:param reachname_file the file with the name of the reaches to study (usually listirv.txt)
:param end_file_reach the ending of the files whose names depends on the reach
:param name_file_allreach the name of the file common to all reaches
:param path the path to the file
:return: the inputs needed for run_stathab</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.power_law">
<code class="descname">power_law</code><span class="sig-paren">(</span><em>qwh_r</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.power_law" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to calculate power law for discharge and width
ln(h0 = a1 + a2 ln(Q)
:param qwh_r, an array where each line in one observatino of Q, width and height
:return: the coeff of the regression</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.savefig_stahab">
<code class="descname">savefig_stahab</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.savefig_stahab" title="Permalink to this definition">¶</a></dt>
<dd><p>A fucntion to save the results in ascii and the figure
:return: 2 figures</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.savetxt_stathab">
<code class="descname">savetxt_stathab</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.savetxt_stathab" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to save the stathab result in .txt form
:return: .txt files</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.stathab_calc">
<code class="descname">stathab_calc</code><span class="sig-paren">(</span><em>path_pref='.'</em>, <em>name_pref='Pref.txt'</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.stathab_calc" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to calculate stathab output
:param path_pref: the path to the preference file
:param name_pref: the name of the preference file
:return: the biological preferrence index (np.array of [reach, specices, nbclaq] size)
, surface or volume by class, etc.</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.test_stathab">
<code class="descname">test_stathab</code><span class="sig-paren">(</span><em>path_ori</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.test_stathab" title="Permalink to this definition">¶</a></dt>
<dd><p>A short function to test part of the outputs against the C++ code,
NOT USED in Habby but practical anyways to debug
:param path_ori: the path to the files from stathab based on the c++ code
:return:</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="src.stathab_c.load_float_stathab">
<code class="descclassname">src.stathab_c.</code><code class="descname">load_float_stathab</code><span class="sig-paren">(</span><em>filename</em>, <em>check_neg</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.load_float_stathab" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to load float with extra checks
:param filename: the file to load with the path
:param check_neg, if true negative value are not allowed in the data
:return: data if ok, -99 if failed</p>
</dd></dl>

<dl class="function">
<dt id="src.stathab_c.load_namereach">
<code class="descclassname">src.stathab_c.</code><code class="descname">load_namereach</code><span class="sig-paren">(</span><em>path</em>, <em>name_file_reach='listriv.txt'</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.load_namereach" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to only load the reach names (useful for the GUI)
:param path : the path th the listriv.txt
:param name_file_reach: In case the file name is not listriv.txt
:return: the list of reach name</p>
</dd></dl>

<dl class="function">
<dt id="src.stathab_c.load_pref">
<code class="descclassname">src.stathab_c.</code><code class="descname">load_pref</code><span class="sig-paren">(</span><em>filepref</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.load_pref" title="Permalink to this definition">¶</a></dt>
<dd><p>The function loads the different pref coeffficient contained in filepref
:param filepref: the name of the file (usually Pref.txt)
:param path: the path to this file
:return: the name of the fish, a np.array with the differen coeff</p>
</dd></dl>

<dl class="function">
<dt id="src.stathab_c.main">
<code class="descclassname">src.stathab_c.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.main" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<span class="target" id="module-src.substrate"></span><dl class="function">
<dt id="src.substrate.fig_merge_grid">
<code class="descclassname">src.substrate.</code><code class="descname">fig_merge_grid</code><span class="sig-paren">(</span><em>point_all_both_t</em>, <em>ikle_both_t</em>, <em>path_im</em>, <em>ikle_orr=[]</em>, <em>point_all_orr=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.fig_merge_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to plot the grid after it was merged with the substrate data
plot one time step at the time
:param point_all_both: the coordinate of the points of the updated grid
:param ikle_both: the connectivity table
:param path_im: the path where the image should be saved
:param ikle_orr the orginial ikle
:param point_all_orr the orginal point_all
:return:</p>
</dd></dl>

<dl class="function">
<dt id="src.substrate.fig_substrate">
<code class="descclassname">src.substrate.</code><code class="descname">fig_substrate</code><span class="sig-paren">(</span><em>coord_p, ikle, sub_info, path_im, xtxt=[-99], ytxt=[-99], subtxt=[-99]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.fig_substrate" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to plot the raw substrate data, which was loaded before
:param coord_p: the coordinate of the point
:param ikle: the connectivity table
:param sub_info: the information on subtrate by element
:param xtxt if the data was given in txt form, the orignal x data
:param ytxt if the data was given in txt form, the orignal y data
:param subtxt if the data was given in txt form, the orignal sub data
:param path_im the path where to save the figure
:return: figure</p>
</dd></dl>

<dl class="function">
<dt id="src.substrate.grid_update_sub2">
<code class="descclassname">src.substrate.</code><code class="descname">grid_update_sub2</code><span class="sig-paren">(</span><em>ikle</em>, <em>coord_p</em>, <em>point_crossing</em>, <em>coord_sub</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.grid_update_sub2" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to find the updated grid with the substrate. More complicated than grid_update3 because it tries to makes
new cell based on the lines linkes the centroid and the side of the trianlge. Looks more elegant at first but
quite complicated and do not work for all cases
:param ikle:  the hydrological grid to be merge with the substrate grid
:param coord_p: the coordinate of the point of the hydrological grid
:param point_crossing: the crossing point, with the elemtn of the hydrological grid linked with it and the
direction (nx,ny) of the substrate line at this point
:param coord_sub the coordinate of the substrate, only useful to if the the substrate cut two time the samie of a
cell of the hydrological grid
:return: the new grid</p>
</dd></dl>

<dl class="function">
<dt id="src.substrate.grid_update_sub3">
<code class="descclassname">src.substrate.</code><code class="descname">grid_update_sub3</code><span class="sig-paren">(</span><em>ikle</em>, <em>coord_p</em>, <em>point_crossing</em>, <em>coord_sub</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.grid_update_sub3" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to update the grid after finding the crossing points
:param ikle:  the hydrological grid to be merge with the substrate grid
:param coord_p: the coordinate of the point of the hydrological grid
:param point_crossing: the crossing point, with the elemtn of the hydrological grid linked with it and the
direction (nx,ny) of the substrate line at this point
:param coord_sub the coordinate of the substrate, only useful to if the the substrate cut two time the samie of a
cell of the hydrological grid
:return: the new grid</p>
</dd></dl>

<dl class="function">
<dt id="src.substrate.intersec_cross">
<code class="descclassname">src.substrate.</code><code class="descname">intersec_cross</code><span class="sig-paren">(</span><em>hyd1</em>, <em>hyd2</em>, <em>sub1</em>, <em>sub2</em>, <em>e=-99</em>, <em>nx=[]</em>, <em>ny=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.intersec_cross" title="Permalink to this definition">¶</a></dt>
<dd><p>small function to calculate the intersection, segment are not parrallel,
in case where we know that the intersection exists
Also save various info with the intersection (element, direction, etc.)
:param hyd1: the first hydrological point
:param hyd2: the second
:param sub1: the first substrate point
:param sub2: the second
:param e: the element of the hydrological grid (optional)
:param nx the direction of the cutting part of the substrate grid (x dir)
:param ny the direction of the cutting part of the substrate grid (y dir)
:return:</p>
</dd></dl>

<dl class="function">
<dt id="src.substrate.load_sub_shp">
<code class="descclassname">src.substrate.</code><code class="descname">load_sub_shp</code><span class="sig-paren">(</span><em>filename</em>, <em>path</em>, <em>name_att='SUBSTRATE'</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.load_sub_shp" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to load the substrate in form of shapefile.
:param filename the name of the shapefile
:param path the path where the shapefile is
:param name_att the name of the substrate column in the attribute table
:return grid in form of list of coordinate and connectivity table (two list)
and an array with substrate type</p>
</dd></dl>

<dl class="function">
<dt id="src.substrate.load_sub_txt">
<code class="descclassname">src.substrate.</code><code class="descname">load_sub_txt</code><span class="sig-paren">(</span><em>filename</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.load_sub_txt" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to load the substrate in form of a text file
the text file must have 3 column x,y corrdinate and substrate info, no header or title
:param filename the name of the shapefile
:param path the path where the shapefile is
:return grid in form of list of coordinate and connectivity table (two list)
and an array with substrate type and (x,y,sub) of the orginal data</p>
</dd></dl>

<dl class="function">
<dt id="src.substrate.main">
<code class="descclassname">src.substrate.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.main" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="src.substrate.merge_grid_hydro_sub">
<code class="descclassname">src.substrate.</code><code class="descname">merge_grid_hydro_sub</code><span class="sig-paren">(</span><em>hdf5_name_hyd</em>, <em>hdf5_name_sub</em>, <em>default_data</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.merge_grid_hydro_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>After the data for the substrate and the hydrological data are loaded, they are still in different grids.
This functions will merge both grid together. This is done for all time step and all reaches
:param hdf5_name_hyd: the path and name of the hdf5 file with the hydrological data
:param hdf5_name_sub: the path and the name of the hdf5 with the substrate data
:param default_data: The substrate data given in the region of the hydrological grid where no substrate is given
:return:</p>
</dd></dl>

<dl class="function">
<dt id="src.substrate.point_cross2">
<code class="descclassname">src.substrate.</code><code class="descname">point_cross2</code><span class="sig-paren">(</span><em>ikle</em>, <em>coord_p</em>, <em>ikle_sub</em>, <em>coord_p_sub</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.point_cross2" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which find where the crossing points are. Crossing pitn are the points on the triangular side of the
hydrological grid which cross with a side of the substrate grid
the algo based on finding if points of one elements are in the same polygon using a ray casting method
:param ikle: the connectivity table for the hydrological data
:param coord_p: the coordinates of the points of the hydrological grid
:param ikle_sub: the connecity vity table of the substrate
:param coord_p_sub: the coordinates of the points of the substrate grid
:return:</p>
</dd></dl>

<dl class="function">
<dt id="src.substrate.point_cross_bis">
<code class="descclassname">src.substrate.</code><code class="descname">point_cross_bis</code><span class="sig-paren">(</span><em>ikle</em>, <em>coord_p</em>, <em>ikle_sub</em>, <em>coord_p_sub</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.point_cross_bis" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which find where the crossing points are. Crossing pitn are the points on the triangular side of the
hydrological grid which cross with a side of the substrate grid. Easier than point_cross 2 but slow.
:param ikle: the connectivity table for the hydrological data
:param coord_p: the coordinates of the points of the hydrological grid
:param ikle_sub: the connecity vity table of the substrate
:param coord_p_sub: the coordinates of the points of the substrate grid
:return:</p>
</dd></dl>

</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Welcome to HABBY&#8217;s documentation!</a></li>
<li><a class="reference internal" href="#how-to-execute-habby">How to execute HABBY</a></li>
<li><a class="reference internal" href="#main-and-source-code">Main(   ) and source code</a></li>
<li><a class="reference internal" href="#graphical-interface">Graphical interface</a><ul>
<li><a class="reference internal" href="#main-windows-of-habby">Main_windows of HABBY</a></li>
<li><a class="reference internal" href="#hydrological-information-gui">Hydrological information - GUI</a></li>
<li><a class="reference internal" href="#figure-option-gui">Figure Option - GUI</a></li>
<li><a class="reference internal" href="#module-src_GUI.stathab_GUI">The Stathab model - GUI</a></li>
<li><a class="reference internal" href="#estimhab-gui">Estimhab - GUI</a><ul>
<li><a class="reference internal" href="#biological-data-estimhab">Biological data - Estimhab</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#calculation-of-fish-s-habitat">Calculation of fish&#8217;s habitat</a><ul>
<li><a class="reference internal" href="#hec-ras-model-1d">Hec-ras model 1D</a><ul>
<li><a class="reference internal" href="#notes-on-hec-ras-outputs">Notes on hec-ras outputs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hec-ras-model-2d">Hec-ras model 2D</a></li>
<li><a class="reference internal" href="#mascaret">Mascaret</a></li>
<li><a class="reference internal" href="#river-2d">River 2D</a></li>
<li><a class="reference internal" href="#rubar">Rubar</a></li>
<li><a class="reference internal" href="#telemac">Telemac</a></li>
<li><a class="reference internal" href="#load-habby-hdf5-file">Load HABBY hdf5 file</a><ul>
<li><a class="reference internal" href="#form-of-the-hdf5-files">Form of the hdf5 files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-src.dist_vistess2">Velocity distribution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">HABBY 1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Diane von Gunten, Yann Le Coarer and Fabrice Zaoui.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1.
    </div>
  </body>
</html>