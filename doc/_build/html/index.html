<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Welcome to HABBY’s documentation! &#8212; HABBY 1 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">HABBY 1 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="welcome-to-habby-s-documentation">
<h1>Welcome to HABBY&#8217;s documentation!<a class="headerlink" href="#welcome-to-habby-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<p>HABBY is a program to estimate the habitat of fish using various hydrological models and preference curve as input.</p>
</div>
<div class="section" id="how-to-execute-habby">
<h1>How to execute HABBY<a class="headerlink" href="#how-to-execute-habby" title="Permalink to this headline">¶</a></h1>
<dl class="docutils">
<dt>To execute HABBY:</dt>
<dd><ul class="first last simple">
<li>Go to folder which contains habby.py using the command line.</li>
<li>Open the command line and type python habby.py.</li>
</ul>
</dd>
</dl>
<p>The python version should be 3.4. HABBY should also function with most of the python 3 distributions.</p>
<p>If a module is missing, it is possible to install it using pip (&#8220;pip install -m <em>module_name</em>&#8221;). Obviously, pip needs to installed, which should be done by default in python 3.4. If you want to be sure to have the same version of the module than originally, go to the folder zen_file/wheele with the command line and install the missing module from there (something similar to &#8220;pip install -m <em>.whl</em>&#8221;). Not all modules are in this folder, only the ones which were difficult to install.</p>
</div>
<div class="section" id="main-and-source-code">
<h1>Main(   ) and source code<a class="headerlink" href="#main-and-source-code" title="Permalink to this headline">¶</a></h1>
<p>The source code is separated in two folders: one folder which contain the code source for the graphical user interface (GUI) and one folder for the rest of the code source.</p>
<p>The dependency between the different part of the source code can be visualized in the mindmap real_GUI.xmind (xmind should be installed).</p>
<p>The main of HABBY is habby.py. It has the usual form for an application using PyQt5.  The main() creates an application of QWidget and call the Main_Windows class, which we will discuss shortly. The last line closes the application.</p>
<p>It is also possible to call habby from the command line without the GUI. For this, the script called habby_cmd.py is used.</p>
</div>
<div class="section" id="graphical-interface">
<h1>Graphical interface<a class="headerlink" href="#graphical-interface" title="Permalink to this headline">¶</a></h1>
<p>Here is the list of all modules contains in the src_GUI folder.</p>
<div class="section" id="main-windows-of-habby">
<h2>Main_windows of HABBY<a class="headerlink" href="#main-windows-of-habby" title="Permalink to this headline">¶</a></h2>
<p>in src_GUI/Main_Windows_1.py</p>
<span class="target" id="module-src_GUI"></span><span class="target" id="module-src_GUI.Main_windows_1"></span><dl class="class">
<dt id="src_GUI.Main_windows_1.CentralW">
<em class="property">class </em><code class="descclassname">src_GUI.Main_windows_1.</code><code class="descname">CentralW</code><span class="sig-paren">(</span><em>rech</em>, <em>path_prj</em>, <em>name_prj</em>, <em>lang_bio</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW" title="Permalink to this definition">¶</a></dt>
<dd><p>This class create the different tabs of the programm, which are then used as the central widget by the class
MainWindows.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rech</strong> &#8211; A bollean which is True if the tabs for the &#8220;research option&#8221; are shown. False otherwise.</li>
<li><strong>path_prj</strong> &#8211; A string with the path to the project xml file</li>
<li><strong>name_prj</strong> &#8211; A string with the name of the project</li>
<li><strong>lang_bio</strong> &#8211; A string with the word &#8216;English&#8217;, &#8216;French&#8217; (or an other language). It is used to find the langugage
in which the biological info should be shown. So lang_bio should have the same form than the attribute
&#8220;langugage&#8221; in xml preference file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>In the attribute list, there are a series of name which finish by “tab” such as stathab_tab or output_tab. Each of
these names corresponds to one tab and a new name should be added to the attributes to add a new tab.</p>
<p>During the creation of the class, each tab is created. Then, the signals to show the figures are connected between this
class and all the children classes which need it (often this are the classes used to load the hydrological data). When a
class emits the signal “show_fig”, CentralW collect this signal and show the figure, using the showfig function.</p>
<p>Show_fig is mostly a “plt.show()”. To avoid problem between matplotlib and PyQt, it is however important that
matplotlib use the backend “Qt5Agg” in the .py where the “plt.plot” is called. Practically, this means modifying
the matplotlib import.</p>
<p>Showfig shows only one figure. To show all existing figures, one can call the function show_fig2 from the menu.
Show_fig2 call the instance child_win of the class ShowImageW to open a new Windows with all figure. However,
this would only show the figure without any option for the zoom.</p>
<p>Then we call a function which connects all the signals from each class which need to write into the log. It is a good
policy to create a “send_log” signal for each new important class. As there are a lot of signal to connect, these
connections are written in the function “connect_signal_log”, where the signal for a new class can be added.</p>
<p>When this is done, the info for the general tab (created before) is filled. If the user has opened a project in HABBY
before, the name of the project and the other info related to it will be shown on the general tab. If the general
tab is modified in the class WelcomeW(), this part of the code which fill the general tab will probably needs to
be modified.</p>
<p>Finally, each tab is filled. The tabs have been created before, but there were empty. Now we fill each one with the
adequate widget. This is the link with many of the other classes that we describe below. Indeed, many of the widget
are based on more complicated classes created for example in hydro_GUI_2.py.</p>
<p>Then, we create an area under it for the log. Here HABBY will write various infos for the user. Two things to note
here: a) we should show the end of the scroll area. b) The size of the area should be controlled and not be
changing even if a lot of text appears. Hence, the setSizePolicy should be fixed.</p>
<p>The write_log() and write_log_file() method are explained in the section about the log.</p>
<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.add_all_tab">
<code class="descname">add_all_tab</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.add_all_tab" title="Permalink to this definition">¶</a></dt>
<dd><p>This function add the different tab to habby (used by init and by save_project)</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.closefig">
<code class="descname">closefig</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.closefig" title="Permalink to this definition">¶</a></dt>
<dd><p>A small function to close the images open in HABBY and managed by matplotlib</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.connect_signal_fig_and_drop">
<code class="descname">connect_signal_fig_and_drop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.connect_signal_fig_and_drop" title="Permalink to this definition">¶</a></dt>
<dd><p>This function connect the PyQtsignal to show figure and to connect the log. It is a function to
improve lisibility.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.connect_signal_log">
<code class="descname">connect_signal_log</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.connect_signal_log" title="Permalink to this definition">¶</a></dt>
<dd><p>connect all the signal linked to the log. This is in a function only to improve lisibility.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to initilize an instance of CentralW. Called by __init___().</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.optfig">
<code class="descname">optfig</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.optfig" title="Permalink to this definition">¶</a></dt>
<dd><p>A small function which open the output tab. It contains the different options for the figures.
Output should be the 5th tab, otherwise it will not work.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.save_info_projet">
<code class="descname">save_info_projet</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.save_info_projet" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to save the description of the project and the username in the xml project file</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.save_on_change_tab">
<code class="descname">save_on_change_tab</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.save_on_change_tab" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to save the data when the tab are changed. In most tab this is not needed as data
is alredy saved by another functions. However, it is useful for the Welcome Tab and the Option Tab.
This function can be modified if needed for new tabs.</p>
<p>Careful, the order of the tab is important here.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.scrolldown">
<code class="descname">scrolldown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.scrolldown" title="Permalink to this definition">¶</a></dt>
<dd><p>Move the scroll bar to the bottow if the ScollArea is getting bigger</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.showfig">
<code class="descname">showfig</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.showfig" title="Permalink to this definition">¶</a></dt>
<dd><p>A small function to show the last figure</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.showfig2">
<code class="descname">showfig2</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.showfig2" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to see all saved figures without possibility to zoom</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.update_hydro_hdf5_name">
<code class="descname">update_hydro_hdf5_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.update_hydro_hdf5_name" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a short function used to read all the hydrological data (contained in an hdf5 files) available in
one project.</p>
<p>When these files are read, they are added to the drop-down menu on the hydrological tab an on the substrate tab.
On the substrate Tab, if we have more than one hdf5 file, the first item is blank to insure that the user
actively choose the hdf5 to reduce the risk of error (Otherwise the user might merge the substrate and
an hydrological hdf5 without seeing that he needs to select the right hydrological hdf5).</p>
<p>This tasks should be in a function because an update to this list can be triggered by the loading of a new
hydrological data. The class Hydro2W() and substrateW() noticed this through the signal drop_hydro
send by the hydrological class. The signal drop_hydro is connected to this function is in the class
CentralW in MainWindows.py.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.write_log">
<code class="descname">write_log</code><span class="sig-paren">(</span><em>text_log</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.write_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to write the different log. Please read the section of the doc on the log.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>text_log</strong> &#8211; the text which should be added to the log (a string)</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>if text_log start with # -&gt; added it to self.l2 (QLabel) and the .log file (comments)</li>
<li>if text_log start with restart -&gt; added it restart_nameproject.txt</li>
<li>if text_log start with WARNING -&gt; added it to self.l2 (QLabel) and the .log file</li>
<li>if text_log start with ERROR -&gt; added it to self.l2 (QLabel) and the .log file</li>
<li>if text_log start with py -&gt; added to the .log file (python command)</li>
<li>if text_log starts with Process -&gt; Text added to the StatusBar only</li>
<li>if text_log == &#8220;clear status bar&#8221; -&gt; the status bar is cleared</li>
<li>if text_log start with nothing -&gt; just print to the Qlabel</li>
<li>if text_log out from stdout -&gt; added it to self.l2 (QLabel) and the .log file (comments)</li>
</ul>
<p>if logon = false, do not write in log.txt</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CentralW.write_log_file">
<code class="descname">write_log_file</code><span class="sig-paren">(</span><em>text_log</em>, <em>pathname_logfile</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CentralW.write_log_file" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to write to the .log text. Called by write_log.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>text_log</strong> &#8211; the text to be written (string)</li>
<li><strong>pathname_logfile</strong> &#8211; the path+name where the log is</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.Main_windows_1.CreateNewProject">
<em class="property">class </em><code class="descclassname">src_GUI.Main_windows_1.</code><code class="descname">CreateNewProject</code><span class="sig-paren">(</span><em>lang</em>, <em>path_trans</em>, <em>file_langue</em>, <em>oldpath_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CreateNewProject" title="Permalink to this definition">¶</a></dt>
<dd><p>A class which is used to help the user to create a new project</p>
<dl class="method">
<dt id="src_GUI.Main_windows_1.CreateNewProject.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CreateNewProject.init_iu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="src_GUI.Main_windows_1.CreateNewProject.save_project">
<code class="descname">save_project</code><a class="headerlink" href="#src_GUI.Main_windows_1.CreateNewProject.save_project" title="Permalink to this definition">¶</a></dt>
<dd><p>a signal to save the project</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.Main_windows_1.CreateNewProject.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.Main_windows_1.CreateNewProject.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQt signal used to write the log</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.CreateNewProject.setfolder">
<code class="descname">setfolder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.CreateNewProject.setfolder" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used by the user to select the folder where the xml project file will be located.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.Main_windows_1.EmptyTab">
<em class="property">class </em><code class="descclassname">src_GUI.Main_windows_1.</code><code class="descname">EmptyTab</code><a class="headerlink" href="#src_GUI.Main_windows_1.EmptyTab" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is  used to fill empty tabs with something during the developement.
It will not be use in the final version.</p>
<dl class="method">
<dt id="src_GUI.Main_windows_1.EmptyTab.addtext">
<code class="descname">addtext</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.EmptyTab.addtext" title="Permalink to this definition">¶</a></dt>
<dd><p>This function print a string on the command line. This is useful if you need to check if a button (or similar).
is connected.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.EmptyTab.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.EmptyTab.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initialization.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.Main_windows_1.MainWindows">
<em class="property">class </em><code class="descclassname">src_GUI.Main_windows_1.</code><code class="descname">MainWindows</code><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows" title="Permalink to this definition">¶</a></dt>
<dd><p>The class MainWindows contains the menu and the title of all the HABBY windows.
It also create all the widgets which can be called during execution</p>
<p><strong>Technical comments and walk-through</strong></p>
<p>First, we load the user setting using Qsettings: The settings by default of Qsettings are the name of the program (HABBY) and
the name of the organization which develops the program (irstea).  I have added three user settings (the name of the
last project loaded into HABBY, the path to this project and the language used). The Qsetting are stored in the
registry in Windows. Qsettings also function with Apple and Linux even if the information is stored differently</p>
<p>We set up the translation next. The translation of HABBY in different language is explained in more detail in
the section “Translation of HABBY”. We give here the path to the data related to the translation. More precisely, we indicate
here the path to the translation data and the name of the qm file containing the data related to the translation
in each language. If a new qm is added for a new language, it should be added here to the list.</p>
<p>Now, two important attributes are defined: self.name_prj and self.path_prj. These attribute will be communicated to
children classes. For each project, an xml file is created. This “project” file should be called name_prj.xml
and should be situated in the path indicated by self.path_prj.</p>
<p>We call the central_widget which contains the different tabs.</p>
<p>We create the menu of HABBY calling the function my menu_bar().</p>
<p>Two signal are connected, one to save the project (i.e to update the xml project file) and another to save an
ESTIMHAB calculation.</p>
<p>We show the created widget.</p>
<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.change_name_project">
<code class="descname">change_name_project</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.change_name_project" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to change the name of the current project. To do this, it copies the xml
project with a new name and copy the file for the log with a new name</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.check_concurrency">
<code class="descname">check_concurrency</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.check_concurrency" title="Permalink to this definition">¶</a></dt>
<dd><p>This function tests if the project which is opening by HABBY is not used by another instance of HABBY. It is
dangerous  to open two time the same project as we have problem with the writing of the xml files.</p>
<p>To check if a project is open, we have a text file in the project folder named &#8220;check_concurrency.txt&#8221;.
In this text file, there is either the word &#8220;open&#8221; or &#8220;close&#8221;. When HABBY open a new project, it checks
this file is set to close and change it to open. Hence, if a project is oen twice a warning is writtem/</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.clear_log">
<code class="descname">clear_log</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.clear_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the log in the GUI.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.closeEvent">
<code class="descname">closeEvent</code><span class="sig-paren">(</span><em>event</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.closeEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the program better than before (where it used to crash about 1 times in ten). It is not really clear why.
Also done because we might have more than one thread</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>event</strong> &#8211; managed by the operating system.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.close_project">
<code class="descname">close_project</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.close_project" title="Permalink to this definition">¶</a></dt>
<dd><p>This function close the current project wihout opening a new project</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.close_rech">
<code class="descname">close_rech</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.close_rech" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the additional research menu (see open_rech for more information). For the moment, ONLY works with
two research tabs. Modify this function if a different number of tab is needed.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.create_menu_right">
<code class="descname">create_menu_right</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.create_menu_right" title="Permalink to this definition">¶</a></dt>
<dd><p>This function create the menu for right click</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.do_log">
<code class="descname">do_log</code><span class="sig-paren">(</span><em>save_log</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.do_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Save or not save the log</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>save_log</strong> &#8211; an int which indicates if the log should be saved or not</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>0: do not save log</li>
<li>1: save the log in the .log file and restart file</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.empty_project">
<code class="descname">empty_project</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.empty_project" title="Permalink to this definition">¶</a></dt>
<dd><p>This function open a new empty project</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.end_concurrency">
<code class="descname">end_concurrency</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.end_concurrency" title="Permalink to this definition">¶</a></dt>
<dd><p>This functiion indicates to the project folder than this project is not used anymore. Hence, this project
can be used freely by an other instance of HABBY.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.erase_pict">
<code class="descname">erase_pict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.erase_pict" title="Permalink to this definition">¶</a></dt>
<dd><p>All files contained in the folder indicated by path_im will be deleted.</p>
<p>From the menu of HABBY, it is possible to ask to erase all files in the folder indicated by path_im
(usually figure_HABBY). Of course, this is a bit dangerous. So the function asks the user for confirmation.
However, it is practical because you do not have to go to the folder to erase all the images when there
are too many of them.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.init_ui">
<code class="descname">init_ui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.init_ui" title="Permalink to this definition">¶</a></dt>
<dd><p>Used by __init__() to create an instance of the class MainWindows</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.my_menu_bar">
<code class="descname">my_menu_bar</code><span class="sig-paren">(</span><em>right_menu=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.my_menu_bar" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates the menu bar of HABBY when call without argument or with the argument right_menu is False.
if right menu is True, it creates a very similar menu but we use a QMenu() instead of a QMenuBar() as it
is the menu open when the user right click</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>right_menu</strong> &#8211; If call with True, we create a menu for the right click and not for the menu part on the top
of the screen.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.my_toolbar">
<code class="descname">my_toolbar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.my_toolbar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.new_project">
<code class="descname">new_project</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.new_project" title="Permalink to this definition">¶</a></dt>
<dd><p>This function open an empty project and guide the user to create a new project, using a new Windows
of the class CreateNewProject</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.on_context_menu">
<code class="descname">on_context_menu</code><span class="sig-paren">(</span><em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.on_context_menu" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to show the menu on right click. If we are ont he Habitat Tab and that the focus is on
the QListWidget, it shows the informatin concerning the fish</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>point</strong> &#8211; Not understood, linke with the position of the menu.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.open_help">
<code class="descname">open_help</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.open_help" title="Permalink to this definition">¶</a></dt>
<dd><p>This function open the html which form the help from HABBY. For the moment, it is the full documentation
with all the coding detail, but we should create a new html or a new pdf file which would be more pratical
for the user.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.open_project">
<code class="descname">open_project</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.open_project" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to open an existing habby project by selecting an xml project file. Called by
my_menu_bar()</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.open_recent_project">
<code class="descname">open_recent_project</code><span class="sig-paren">(</span><em>j</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.open_recent_project" title="Permalink to this definition">¶</a></dt>
<dd><p>This function open a recent project of the user. The recent project are listed in the menu and can be
selected by the user. When the user select a recent project to open, this function is called. Then, the name of
the recent project is selected and the method save_project() is called.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>j</strong> &#8211; This indicates which project should be open, based on the order given in the menu</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.open_rech">
<code class="descname">open_rech</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.open_rech" title="Permalink to this definition">¶</a></dt>
<dd><p>Open the additional research tab, which can be used to create Tab with more experimental contents.</p>
<p>Indeed, it is possible to show extra tab in HABBY. These supplementary tab correspond to open for researcher.
The plan is that these options are less tested than other mainstream options. It is not clear yet what
will be added to these options, but the tabs are already there when it will be needed.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.save_project">
<code class="descname">save_project</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.save_project" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to save the xml file with the information on the project</p>
<p><strong>Technical comments</strong></p>
<p>This function saves or creates the xml file related to the projet. In this xml file, there are the path and
the name to all files related to the project, notably the hdf5 files containing the hydrological data.</p>
<p>To find or create the xml file, we use the attribute self.path_prj and self.name_proj. If the path to
the project directory is not found an error appears. The error is here sent though additional windows
(to be sure that the user notice this problem), using the Qmesssage module. The user should give the general
info about the project in the general tab of HABBY and they are collected here. User option (using Qsetting)
is next updated so that the user will find his project open the next time it opens HABBY.</p>
<p>When HABBY open, there are therefore  two choice: a) This is a new project b) the project exists already.
If the project is new, the xml file is created and general information is written in this file. In addition,
the text file which are necessary to log the action of HABBY are created now. This part of the reason why it
is not possible to run other part of HABBY (such as loading hydrological data) before a project is saved.
In addition, it would create a lot of problems on where to store the data created. Hence, a project is needed
before using HABBY. If the project exists already (i.e. the name and the path of the project have not been
modified), the xml file is just updated to change its attributes as needed.</p>
<p>Interesting path are a) the biology path (named &#8220;biology&#8221; by default) which contains the biological information
such as the preference curve and b) the path_im which is the path where all figures and most outputs of HABBY
is saved. If path_im is not given, HABBY automatically create a folder called figures when the
user creates a new project. The user can however change this path if he wants. It also create other similar
folders to sotre different type of outputs. The next step is to communicate
to all the children widget than the name and path of the project have changed.</p>
<p>This function also changes the title of the Windows to reflect the project name and it adds the saved
project to the list of recent project if it is not part of the list already. Because of this the menu must
updated.</p>
<p>Finally the log is written (see “log and HABBY in the command line).</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.save_project_estimhab">
<code class="descname">save_project_estimhab</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.save_project_estimhab" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to save the information linked with Estimhab in an hdf5 file.</p>
<p><strong>Technical comments</strong></p>
<p>This function save the data and result from the estimhab calculation. It would look more logic if it was in
the esimhab.py script, but it was easier to call it from here instead of in the child class.</p>
<p>This function get all estimhab input, create an hdf5 file using h5py and save the data in the hdf5. One
specialty of hdf5 is that is cannot use Unicode. Hence all string have to be passed to ascii using the encode
function. The size of each data should also be known.</p>
<p>Finally, we save the name and path of the estimhab file in the xml project file.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.save_project_if_new_project">
<code class="descname">save_project_if_new_project</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.save_project_if_new_project" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to save a project when the project is created from the other Windows CreateNewProject. It
can not be in the new_project function as the new_project function call CreateNewProject().</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.see_file">
<code class="descname">see_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.see_file" title="Permalink to this definition">¶</a></dt>
<dd><p>This function allows the user to see the files in the project folder and to open them.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.setlangue">
<code class="descname">setlangue</code><span class="sig-paren">(</span><em>nb_lang</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.setlangue" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which change the language of the programme. It change the menu and the central widget.
It uses the self.lang attribute which should be set to the new language before calling this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nb_lang</strong> &#8211; the number representing the language (int)</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>0 is for English</li>
<li>1 for French</li>
<li>n for any additionnal language</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.MainWindows.test_entry_float">
<code class="descname">test_entry_float</code><span class="sig-paren">(</span><em>var_in</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.MainWindows.test_entry_float" title="Permalink to this definition">¶</a></dt>
<dd><p>An utility function to test if var_in are float or not
the boolean self.does_it_work is used to know if the functions run until the end.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>var_in</strong> &#8211; the QlineEdit which contains the data (so var_in.text is a string)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the tested variable var_in</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.Main_windows_1.ShowImageW">
<em class="property">class </em><code class="descclassname">src_GUI.Main_windows_1.</code><code class="descname">ShowImageW</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.ShowImageW" title="Permalink to this definition">¶</a></dt>
<dd><p>The widget which shows the saved images. Used only to show all the saved figure together iwhtout zoom or other
options. Not really used anymore in HABBY but it still there as it can be useful in the future.</p>
<p><strong>Technical comments</strong></p>
<p>The ShowImageW() class is used to show all the figures created by HABBY. It is a class which can only be
called from the menu (In Option/Option Image). This is not the usual way of opening a figure which is usually done
by plt.show from matplotlib. This is the way to look at all figures  together, which can be useful, even if zooming
is not possible anymore.</p>
<p>To show all image, HABBY open a separate window and show the saved image in .png format.  Currently, the figures
shown are in .png, but other formats could be used. For this, one can change the variable self.imtype.</p>
<p>An important point for the ShowImageW  class  is where the images were saved by the functions which created them.
In HABBY, all figures are saved in the same folder called “path_im”. One “path_im” is chosen at the start of each
project. By default, it is the folder “Figure_Habby”, but the user can modify this folder in the window created by
ShowImageW(). The function for this is called “change_folder”, also in ShowImageW(). The path_im is written in
the xml project file. The different functions which create image read this path and send the figure created
to this folder. ShowImageW() reads all  figure of “.png” type in the” path_im” folder and show the most recent
figure. The user can use the drop-down menu to choose to see another figure. The names of the figure are added to
the drop-down menu in the function update_namefig. The function &#8220;selectionchange&#8221; changes the figure shown based
on the user action.</p>
<dl class="method">
<dt id="src_GUI.Main_windows_1.ShowImageW.change_folder">
<code class="descname">change_folder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.ShowImageW.change_folder" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to change the folder where are stored the image (i.e., the path_im)</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.ShowImageW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.ShowImageW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initialization.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.ShowImageW.selectionchange">
<code class="descname">selectionchange</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.ShowImageW.selectionchange" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to change the figure shown by ShowImageW()
:return:</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.Main_windows_1.ShowImageW.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.Main_windows_1.ShowImageW.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQt signal used to write the log</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.ShowImageW.update_namefig">
<code class="descname">update_namefig</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.ShowImageW.update_namefig" title="Permalink to this definition">¶</a></dt>
<dd><p>This function add the different figure name to the drop-down list.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.Main_windows_1.WelcomeW">
<em class="property">class </em><code class="descclassname">src_GUI.Main_windows_1.</code><code class="descname">WelcomeW</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW" title="Permalink to this definition">¶</a></dt>
<dd><p>The class WeLcomeW()  creates the first tab of HABBY (the tab called “General”). This tab is there to create
a new project or to change the name, path, etc. of a project.</p>
<dl class="attribute">
<dt id="src_GUI.Main_windows_1.WelcomeW.change_name">
<code class="descname">change_name</code><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW.change_name" title="Permalink to this definition">¶</a></dt>
<dd><p>A signal to change the name of the project for MainWindows</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.WelcomeW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initialization of a new instance of the class WelcomeW()</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.Main_windows_1.WelcomeW.new_proj_signal">
<code class="descname">new_proj_signal</code><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW.new_proj_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQt signal used to open a new project</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.WelcomeW.open_example">
<code class="descname">open_example</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW.open_example" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will be used to open a project example for HABBY, but the example is not prepared yet</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.Main_windows_1.WelcomeW.open_proj">
<code class="descname">open_proj</code><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW.open_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>A signal for MainWindows to open an exisiting project</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.Main_windows_1.WelcomeW.save_info_signal">
<code class="descname">save_info_signal</code><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW.save_info_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>A signal to change the user name and the description of the project</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.Main_windows_1.WelcomeW.save_signal">
<code class="descname">save_signal</code><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW.save_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQt signal used to save the project</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.Main_windows_1.WelcomeW.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQt signal used to write the log</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.Main_windows_1.WelcomeW.setfolder2">
<code class="descname">setfolder2</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.Main_windows_1.WelcomeW.setfolder2" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used by the user to select the folder where the xml project file will be located.
This is used in the case where the project exist already. A similar function is in the class CreateNewProject()
for the case where the project is new.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="hydrological-information-gui">
<h2>Hydrological information - GUI<a class="headerlink" href="#hydrological-information-gui" title="Permalink to this headline">¶</a></h2>
<p>in src_GUI/hydro_GUI_2.py</p>
<p>This python module contains the class which forms the hydrological tab in HABBY.
It contains the information for the graphical interface and make the link with the scripts
used for the hydrological calculations.</p>
<span class="target" id="module-src_GUI.hydro_GUI_2"></span><dl class="class">
<dt id="src_GUI.hydro_GUI_2.FreeSpace">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">FreeSpace</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.FreeSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">PyQt5.QtWidgets.QWidget</span></code></p>
<p>Simple class with empty space, just to have only Qwidget in the stack.</p>
<p><strong>Technical comment</strong></p>
<p>The idea of this class is that the user see a free space when it opens the “Hydro” Tab instead
of directly seeing one of the hydraulic model. The goal is to avoid the case where a user tries to load data before
selecting the real model. For example, if a user wants to load mascaret data and that an item is selected by
default in the stack of classes related to hydrology (such as HEC-RAS1D), it might be logical for the user to try
to load masacret data using the HEC-RAS class. Because of the FreeSpace class, he actually has to select
the model he wants to load.</p>
</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS1D">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">HEC_RAS1D</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class Hec_ras 1D is there to manage the link between the graphical interface and the functions in
src/hec_ras06.py which loads the hec-ras data in 1D. The class HEC_RAS1D inherits from SubHydroW() so it have all
the methods and the variables from the class ubHydroW(). The class hec-ras 1D is added to the self.stack of Hydro2W().
So the class Hec-Ras 1D is called when the user is on the hydrological tab and click on hec-ras1D as hydrological
model.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS1D.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS1D.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is called by __init__() durring the initialization.</p>
<p><strong>Technical comment</strong></p>
<p>The self.attributexml variable is the name of the attribute in the xml file. To load a hec-ras file, one needs
to give to HABBY one file containing the geometry data and one file containing the simulation result. The name
and path to  these two file are saved in the xml project file under the attribute given in
the self.attributexml variable.</p>
<p>The variable self.extension is a list of list of the accepted file type. The first list is for the file
with geometry data. The second list is the extension of the files containing the simulation results.</p>
<p>Using the function self.was_model_loaded_before, HABBY write the name of the hec-ras files which were loaded
in HABBY in the same project before.</p>
<p>Hec-Ras is a 1.5D model and so HABBY create a 2D grid based on the 1.5D input. The user can choose the interpolation
type and the number of extra profile. If the interpolation type is “interpolation by block”, the number of extra
profile will always be one. See manage_grid.py for more information on how to create a grid.</p>
<p>We add a QLineEdit with the proposed name for the created hdf5 file. The user can modified this name if wished so.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS1D.load_hec_ras_gui">
<code class="descname">load_hec_ras_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS1D.load_hec_ras_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to execute the loading and saving of the HEC-ras file using Hec_ras.py</p>
<p><strong>Technical comments</strong></p>
<p>This function is called when the user press on the button self.load_b. It is the function which really
calls the load function for hec_ras. First, it updates the xml project file. It adds the name of the new file
to xml project file under the attribute indicated by self.attributexml. It also gets the path_im by reading the
path_im in the xml project file. If we want to create the 1D figure, the option show_all_fig
should be selected in the figure option. It also manages the log as explained in the section about the log.
It loads the hec-ras data as explained in the section on hec_ras06.py and creates the grid as explained
in the manage_grid.py based on the interpolation type wished by the user (linear, nearest neighbor or by block).
The variable self.name_hdf5() is taken from the GUI.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS1D.propose_next_file">
<code class="descname">propose_next_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS1D.propose_next_file" title="Permalink to this definition">¶</a></dt>
<dd><p>This function proposes the second hec-ras file when the first is selected.  Indeed, to load hec-ras, we need
one file with the geometry data and one file with the simulation results. If the user selects a file, this
function looks if a file with the same name but with the extension of the other file type exists in the
selected folder. Careful, when using hec-ras more than one extension type is possible.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS2D">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">HEC_RAS2D</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class hec_RAS2D is there to manage the link between the graphical interface and the functions in src/hec_ras2D.py
which loads the hec_ras2D data in 2D. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW(). It is very similar to RUBAR2D class and it has the same problem about node/cell
which will need to be corrected.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS2D.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS2D.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is used to by __init__() during the initialization.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.HEC_RAS2D.load_hec_2d_gui">
<code class="descname">load_hec_2d_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HEC_RAS2D.load_hec_2d_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls the function which load hecras 2d and save the names of file in the project file.
It is similar to the function to load_rubar2D. It open a second thread to avoid freezing the GUI.</p>
<p>When this function starts, it also starts a timer. Every three seconds, the timer run the function send_data()
which is the class SubHydroW(). This function checks if the thread is finished and, it is finished, manage
figure and errors.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.HabbyHdf5">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">HabbyHdf5</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HabbyHdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>This class is used to load hdf5 hydrological file done by HABBY on another project. If the project was lost,
it is there possible to just add a along hdf5 file to the current project without having to pass to the original
hydrological files.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.HabbyHdf5.get_new_hydro_hdf5">
<code class="descname">get_new_hydro_hdf5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HabbyHdf5.get_new_hydro_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function which allows the user to select an hdf5 file containing the hydrological
data from a previous project and add it to the current project. It modifies the xml project file and test
that the data is in correct form by loading it. The hdf5 should have the same form than the hydrological data
created by HABBY in the method save_hdf5 of the class SubHydroW.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.HabbyHdf5.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.HabbyHdf5.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initialization by __init__()</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.Hydro2W">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">Hydro2W</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Hydro2W" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">PyQt5.QtWidgets.QWidget</span></code></p>
<p>The class Hydro2W is the second tab of HABBY. It is the class containing all the classes/Widgets which are used
to load the hydrological data.</p>
<p>List of model supported by Hydro2W:
files separetly. However, sometime the file was not found
*   Telemac (2D)
*   Hec-Ras (1.5D et 2D)
*   Rubar BE et 2(1D et 2D)
*   Mascaret (1D)
*   River2D (2D)</p>
<p><strong>Technical comments</strong></p>
<p>To call the different classes used to load the hydrological data, the user selects the name of the hydrological
model from a QComboBox call self.mod. The method ‘selection_change” calls the class that the user chooses in
self.mod. All the classes used to load the
hydrological data are created when HABBY starts and are kept in a stack called self.stack. The function
selection_change() just changes the selected item of the stack based on the user choice on self.mod.</p>
<p>Any new hydrological model should also be added to the stack and to the list of models contained in self.mod
(name of the list: self.name_model).</p>
<p>In addition to the stack containing the hydrological information, hydro2W has two buttons. One button open
a QMessageBox() which give information about the models, using the method “give_info_model”.  It is useful if a
special type of file is needed to load the data from a model or to give extra information about one hydrological
model. The text which is shown on the QMessageBox is given in one text file for each model.
These text file are contained in the folder ‘model_hydro” which is in the HABBY folder. For the moment,
there are models for which no text files have been prepared. The text file should have the following format:</p>
<ul class="simple">
<li>A short sentence with general info</li>
<li>The keyword:  MORE INFO</li>
<li>All other infomation which are needed.</li>
</ul>
<p>The second button allows the user to load an hdf5 file containing hydrological data from another project.
As long as the hdf5 is in the right format, it does not matter from which hydrological model it was loaded from
or even if this hydrological model is supported by HABBY.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Hydro2W.give_info_model">
<code class="descname">give_info_model</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Hydro2W.give_info_model" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to show extra information about each hydrological model.
The information should be in a text file with the same name as the model in the model_hydo folder.
General info goes as the start of the text file. If the text is too long, add the keyword &#8220;MORE INFO&#8221;
and add the longer text afterwards. The message box will show the supplementary information only if the user
asks for detailed information.</p>
<p>This functins is not used anymore as it was long to maintain it and not very useful to the user. But I let it
here is case, it becomes necessary again</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Hydro2W.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Hydro2W.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initialization by __init__()</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Hydro2W.selectionchange">
<code class="descname">selectionchange</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Hydro2W.selectionchange" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the shown widget which represents each hydrological model (all widget are in a stack)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>i</strong> &#8211; the number of the model (0=no model, 1=hecras1d, 2= hecras2D,...)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.Hydro2W.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.Hydro2W.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQt signal to send the log.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.LAMMI">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">LAMMI</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.LAMMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class LAMMI is there to manage the link between the graphical interface and the functions in src/lammi.py
which loads the lammi data. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW().</p>
<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.LAMMI.drop_merge">
<code class="descname">drop_merge</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.LAMMI.drop_merge" title="Permalink to this definition">¶</a></dt>
<dd><p>A pyqtsignal which signal that hydro data from lammi is ready. The signal is for the bioinfo_tab and is collected
by MainWindows1.py. Data from lammi contains substrate data.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.LAMMI.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.LAMMI.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used by __init__() during the initialization.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.LAMMI.load_lammi_gui">
<code class="descname">load_lammi_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.LAMMI.load_lammi_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the lammi data, save the text file to the xml project file and create the grid</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.LAMMI.show_dialog_lammi">
<code class="descname">show_dialog_lammi</code><span class="sig-paren">(</span><em>i=0</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.LAMMI.show_dialog_lammi" title="Permalink to this definition">¶</a></dt>
<dd><p>When using lammi data, the user selects a directory and not a file. Hence, we need to modify the ususal
show_dialog function. Hence, function the show_dilaog_lammi() obtain the directory chosen by the user.
This method open a dialog so that the user select a directory. The files are NOT loaded here. The name and path
to the files are saved in an attribute.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>i</strong> &#8211; If i ==0, we obtain the Entree dirctory, if i == 1, the Resu directory.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.Mascaret">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">Mascaret</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Mascaret" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class Mascaret is there to manage the link between the graphical interface and the functions in src/mascaret.py
which loads the Masacret data in 1D. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW(). It is similar to the HEC-Ras1D class (see this class for more information). However, mascaret is 1D model, so the loading
of mascaret has one additional step compared to the hec-ras load: The velocity must be distributed along the
profile. For this, the load_masacret_gui call the self.distrbute _velocity function. In addition, it prepares
the manning value which is necessary to distribute the velocity. The user has two choices to input the manning
value. The easiest one is just to give a value constant for the whole river. In the second choice, the user loads
a text file with a serie of lines with the following info: p, dist, n where p is the profile number
(starting at zero), dist is the distance in meter along the profile and n in the manning value (see the method
load_manning_text of the class SubHydroW for more information)</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Mascaret.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Mascaret.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initialization by __init__()</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Mascaret.load_mascaret_gui">
<code class="descname">load_mascaret_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Mascaret.load_mascaret_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>The function is used to load the mascaret data, calling the function contained in the script mascaret.py.
It also create a 2D grid from the 1D data and distribute the velocity.
All of theses tasks are done on a second thread to avoid freezing the GUI.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Mascaret.propose_next_file">
<code class="descname">propose_next_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Mascaret.propose_next_file" title="Permalink to this definition">¶</a></dt>
<dd><p>This function proposes the two other mascaret when the first is selected. If the user selects the first file,
this function looks if a file with the same name but with the extension of the other file types exists in the
selected folder.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.River2D">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">River2D</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class River2D t is there to manage the link between the graphical interface and the functions in src/river2D.py
which loads the River2D data in 2D.</p>
<p><strong>Technical comments</strong></p>
<blockquote>
<div><p>The class River2D inherits from SubHydroW() so it have all the methods and the variables from the class SubHydroW().
It is similar generally to the hec-ras2D class. However, the hydrological model River2D create one file per time step.
Hence, it is necessary to have a way to load all the files automatically. Loading one file after one file would be
annoying. There are four functions to manage the large number of file:</p>
<ul class="simple">
<li>add_all_file: find all files in a folder selected by the user.</li>
<li>add_file_river2D: add just one selected file</li>
<li>Remove_all_file: remove all selected files</li>
<li>Remove_file: remove one selected file</li>
</ul>
<p>None of this four functions load the data, it just add the name and path of the files to be loaded to
self.namefile and self.pathfile. Generally, in HABBY, we load hydrological data in two steps: a) select the files,
b) load the data. For river2D, the step b) is done by the function load_river2d_gui().
This function is similar to the one used by Rubar2D. It has the same problem about the grid which
is identical for all time steps and which contains all reaches together. So a temporary correction was applied.
Data in River2D is given on the nodes as in HABBY.</p>
</div></blockquote>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.add_all_file">
<code class="descname">add_all_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.add_all_file" title="Permalink to this definition">¶</a></dt>
<dd><p>The function finds all .cdg file in one directory to add there names to the list of files to be loaded</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.add_file_river2d">
<code class="descname">add_file_river2d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.add_file_river2d" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to add one file to the list of file to be loaded.
It let the user select one or more than one file, prepare some data for it and update the QWidgetList with
the name of the file containted in the variable self.namefile.</p>
<p>We can not call show_dialog() direclty here as the user can select more than one file</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.add_file_to_list">
<code class="descname">add_file_to_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.add_file_to_list" title="Permalink to this definition">¶</a></dt>
<dd><p>This function to add all file contained in self.namefile to the QWidgetlist. Called by add_file_river2D and
add_all_file.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>used by __init__ in the initialization</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.load_river2d_gui">
<code class="descname">load_river2d_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.load_river2d_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to load the river 2d data. It use a second thread to avoid freezing the GUI</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.remove_all_file">
<code class="descname">remove_all_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.remove_all_file" title="Permalink to this definition">¶</a></dt>
<dd><p>This function removes all files from the list of files to be loaded and from the QlistWidget.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.River2D.remove_file">
<code class="descname">remove_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.River2D.remove_file" title="Permalink to this definition">¶</a></dt>
<dd><p>This is small function to remove one or more .cdg file from the list of files to be loaded and from
the QlistWidget.</p>
<p><strong>Technical Comments</strong></p>
<p>The function selectedIndexes does not return an int but an object called QModelIndex. We should start removing
object from the end of the list to avoid problem. However, it is not possible to sort QModelIndex. Hence,
It is necessary to use the row() function to get the index as int.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.Rubar1D">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">Rubar1D</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class Rubar1D is there to manage the link between the graphical interface and the functions in src/rubar.py
which loads the Rubar1D data in 1D. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW(). It is very similar to Mascaret class.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Rubar1D.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar1D.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initalizatin by __init__()</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Rubar1D.load_rubar1d">
<code class="descname">load_rubar1d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar1D.load_rubar1d" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to execute the loading and saving the the rubar file using rubar.py. After loading the data,
it distribute the velocity along the profiles by calling self.distribute_velocity() and it created the 2D grid
by calling the method self.grid_and_interpo.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Rubar1D.propose_next_file">
<code class="descname">propose_next_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar1D.propose_next_file" title="Permalink to this definition">¶</a></dt>
<dd><p>This function proposes the other rubar file when the first is selected. If the user selects the first file,
this function looks if a file of the form profil.name exist</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.Rubar2D">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">Rubar2D</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class Rubar2D is there to manage the link between the graphical interface and the functions in src/rubar.py
which loads the RUBAR data in 2D. It inherits from SubHydroW() so it have all the methods and the variables from
the class SubHydroW(). The form of the function is similar to hec-ras, but it does not have the part about the grid
creation as we look here as the data created in 2D by RUBAR.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Rubar2D.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar2D.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>used by ___init__() in the initialization.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Rubar2D.load_rubar">
<code class="descname">load_rubar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar2D.load_rubar" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to execture the loading and saving the the rubar file using rubar.py. It is similar to the
load_hec_ras_gui() function. Obviously, it calls rubar and not hec_ras this time. A small difference is that
the rubar2D outputs are only given in one grid for all time steps and all reaches. Moreover, it is
necessary to cut the grid for each time step as a function of the wetted area and maybe to separate the
grid by reaches.  Another problem is that the data of Rubar2D is given on the cells of the grid and not the
nodes. So we use linear interpolation to correct for this.</p>
<p>A second thread is used to avoid &#8220;freezing&#8221; the GUI.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.Rubar2D.propose_next_file">
<code class="descname">propose_next_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.Rubar2D.propose_next_file" title="Permalink to this definition">¶</a></dt>
<dd><p>This function proposes the second RUBAR file when the first is selected.  Indeed, to load rubar, we need
one file with the geometry data and one file with the simulation results. If the user selects a file, this
function looks if a file with the same name but with the extension of the other file type exists in the
selected folder.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.SubHydroW">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">SubHydroW</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">PyQt5.QtWidgets.QWidget</span></code></p>
<p>SubHydroW is class which is the parent of the classes which can be used to open the hydrological models. This class
is a bit special. It is not called directly by HABBY but by the classes which load the hydrological data and which
inherits from this class. The advantage of this architecture is that all the children classes can use the methods
written in SubHydroW(). Indeed, all the children classes load hydrological data and therefore they are similar and
can use similar functions.</p>
<p>In other word, there are MainWindows() which provides the windows around the widget and Hydro2W which provide the
widget for the hydrological Tab and one class by hydrological model to really load the model. The latter classes
have various methods in common, so they inherit from SubHydroW, this class.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.create_image">
<code class="descname">create_image</code><span class="sig-paren">(</span><em>save_fig=True</em>, <em>show_info=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.create_image" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to create the images related to the grid and the hydrology. It is called by send_data
and recreate_image. This function exists because the two functions above have similar needs and that we do not
copy too much codes. It can also show basic information about the data in the log windows and in the log file
if the variable show_info is True.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>save_fig</strong> &#8211; a boolean to save the figure or not</li>
<li><strong>show_info</strong> &#8211; If True, basic information about the data will be displayed into the log window.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.dis_enable_nb_profile">
<code class="descname">dis_enable_nb_profile</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.dis_enable_nb_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>This function enable and disable the QLineEdit where the user gives the number of additional profile needed to
create the gird and the related QLabel. If the user choose the interpolation by bloc, the QLineEdit will be
disabled. If it chooses linear or nearest neighbour interpolation, it will be enabled. Careful, this function
only works with 1D and 1.5D model.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.drop_hydro">
<code class="descname">drop_hydro</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.drop_hydro" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal signal for the substrate tab so it can account for the new hydrological info.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.find_path_hdf5">
<code class="descname">find_path_hdf5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.find_path_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to find the path where to save the hdf5 file. Careful a simialar one is in estimhab_GUI.py. By default,
path_hdf5 is in the project folder in the folder &#8216;fichier_hdf5&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.find_path_im">
<code class="descname">find_path_im</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.find_path_im" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to find the path where to save the figues. Careful a simialar one is in estimhab_GUI.py. By default,
path_im is in the project folder in the folder &#8216;figure&#8217;.</p>
<p>This is practical to have in a function form as it should be called repeatably (in case the project have been
changed since the last start of HABBY).</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.find_path_input">
<code class="descname">find_path_input</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.find_path_input" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to find the path where to save the input file. Careful a simialar one is in estimhab_GUI.py. By default,
path_input indicates the folder &#8216;input&#8217; in the project folder.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.gethdf5_name_gui">
<code class="descname">gethdf5_name_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.gethdf5_name_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>This function get the name of the hdf5 file for the hydrological and write down in the QLineEdit on the GUI.
It is possible to have more than one hdf5 file for a model type. For example, we could have created two hdf5
based on hec-ras output. The default here is to write the last model loaded. It is the same default behaviour
than for the function was_model_loaded_before(). To keep the coherence between the filename and hdf5 name,
a change in this behaviour should be reflected in both function.</p>
<p>This function calls the function get_hdf5_name in the load_hdf5.py file</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.load_manning_text">
<code class="descname">load_manning_text</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.load_manning_text" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the manning data in case where manning number is not simply a constant. In this case, the manning
parameter is given in a .txt file.
The manning parameter used by 1D model such as mascaret or Rubar BE to distribute velocity along the profiles.
The format of the txt file is &#8220;p, dist, n&#8221; where  p is the profile number (start at zero), dist is the distance
along the profile in meter and n is the manning value (in SI unit). One point per line so something like:</p>
<p>0, 150, 0.035</p>
<p>0, 200, 0.025</p>
<p>1, 120, 0.035, etc.</p>
<p>White space is neglected and a line starting with the character # is also neglected.</p>
<p>A very similar function to this ones exists in func_for_cmd. It is used to so the same thing but called
from the cmd. Changes should be copied in both functions if necessary.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.read_attribute_xml">
<code class="descname">read_attribute_xml</code><span class="sig-paren">(</span><em>att_here</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.read_attribute_xml" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to read the text of an attribute in the xml project file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>att_here</strong> &#8211; the attribute name (string).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.recreate_image">
<code class="descname">recreate_image</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.recreate_image" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to recreate the images related to the grid and the hydrology. We do not call create_image
directly as we might add other command here.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.save_xml">
<code class="descname">save_xml</code><span class="sig-paren">(</span><em>i=0</em>, <em>append_name=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.save_xml" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to save the loaded data in the xml file.</p>
<p>This function adds the name and the path of the newly chosen hydrological data to the xml project file. First,
it open the xml project file (and send an error if the project is not saved, or if it cannot find the project
file). Then, it opens the xml file and add the path and name of the file to this xml file. If the model data was
already loaded, it adds the new name without erasing the old name IF the switch append_name is True. Otherwise,
it erase the old name and replace it by a new name. The variable “i” has the same role than in show_dialog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i</strong> &#8211; a int for the case where there is more than one file to load</li>
<li><strong>append_name</strong> &#8211; A boolean. If True, the name found will be append to the existing name in the xml file,
instead of remplacing the old name by the new name.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.send_data">
<code class="descname">send_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.send_data" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is call regularly by the methods which have a second thread (so moslty the function
to load the hydrological data). To call this functin regularly, the variable self.timer of QTimer type is used.
The variable self.timer is connected to this function in the initiation of SubHydroW() and so in the initation
of all class which inherits from SubHydroW().</p>
<p>This function just wait while the thread is alive. When it has terminated, it creates the figure and the error
messages.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.send_err_log">
<code class="descname">send_err_log</code><span class="sig-paren">(</span><em>check_ok=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.send_err_log" title="Permalink to this definition">¶</a></dt>
<dd><p>This function sends the errors and the warnings to the logs.
The stdout was redirected to self.mystdout before calling this function. It only sends the hundred first errors
to avoid freezing the GUI. A similar function exists in estimhab_GUI.py. Correct both if necessary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>check_ok</strong> &#8211; This is an optional paramter. If True, it checks if the function returns any error</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A Pyqtsignal to write the log.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.show_dialog">
<code class="descname">show_dialog</code><span class="sig-paren">(</span><em>i=0</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.show_dialog" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to obtain the name of the file chosen by the user. This method open a dialog so that the user select
a file. This file is NOT loaded here. The name and path to this file is saved in an attribute. This attribute
is then used to loaded the file in other function, which are different for each children class. Based on the
name of the chosen file, a name is proposed for the hdf5 file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>i</strong> &#8211; a int for the case where there is more than one file to load</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal to show the figure.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubHydroW.was_model_loaded_before">
<code class="descname">was_model_loaded_before</code><span class="sig-paren">(</span><em>i=0</em>, <em>many_file=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubHydroW.was_model_loaded_before" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to test if the model loaded before. If yes, it updates the attibutes anf the widgets of the
hydrological model on consideration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i</strong> &#8211; an int used in cases where there is more than one file to load (geometry and output for example)</li>
<li><strong>many_file</strong> &#8211; A bollean. If true this function will load more than one file, separated by &#8216;,&#8217;. If False,
it will only loads the file of one model (see the comment below).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comment</strong></p>
<p>This method opens the xml project file and look in the attribute of the xml file to see if data from the
hydrological model have been loaded before. If yes, the name of the data is written on the GUI of HABBY in the
Widget related to the hydrological model. Now, there are often more than one data loaded. This method allows
choosing what should be written. There are two different case to be separated: a) We have loaded two different
models (like two rivers modeled by HEC-RAS) b) One model type needs two data file (like HEC-RAS would need a
geometry and output data). For the case a), the default is to write only the last model loaded. If this
default behaviour is changed, the behaviour of gethdf5_name_GUI should also be changed. If we wish to
write all data, the switch “many_file” should be True. This switch is also useful for the river2D model, because
this model create one output file per time step. For the case b), the argument “i”(which is an int) allows us to
choose which data type should be shown. “i” is in the order of the self.attributexml variable. The definition of
this order is given in the definition of the class of each hydrological model.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.SubstrateW">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">SubstrateW</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>This is the widget used to load the substrate. It is practical to re-use some of the method from SubHydroW.
So this class inherit from SubHydroW.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.add_const_widgets">
<code class="descname">add_const_widgets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.add_const_widgets" title="Permalink to this definition">¶</a></dt>
<dd><p>This function shows the widgets realted to the loading of constatns subtrate</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.add_file_widgets">
<code class="descname">add_file_widgets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.add_file_widgets" title="Permalink to this definition">¶</a></dt>
<dd><p>This functions shows the widgets</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.btnstate">
<code class="descname">btnstate</code><span class="sig-paren">(</span><em>rb_sel</em>, <em>rb_del</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.btnstate" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to select and deslect radiobutton
:param rb_sel: the radio button which was just selected
:param rb_del: the radio button which should be deselected</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.drop_merge">
<code class="descname">drop_merge</code><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.drop_merge" title="Permalink to this definition">¶</a></dt>
<dd><p>A pyqtsignal which signal that merged hydro data is ready. The signal is for the bioinfo_tab and is collected
by MainWindows1.py.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.get_att_name">
<code class="descname">get_att_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.get_att_name" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to get the attribute name of the shapefile which contains the substrate data. it is given by the user
in the GUI.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.get_attribute_from_shp">
<code class="descname">get_attribute_from_shp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.get_attribute_from_shp" title="Permalink to this definition">¶</a></dt>
<dd><p>This function opens a shapefile and obtain the attribute. It then update the GUI
to reflect this and also update the label as needed.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initialization by __init__().</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.load_sub_gui">
<code class="descname">load_sub_gui</code><span class="sig-paren">(</span><em>const_sub=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.load_sub_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to load the substrate data. The substrate data can be in two forms: a) in the form of a shp
file form ArGIS (or another GIS-program). b) in the form of a text file (x,y, substrate data line by line).
Generally this function has some similarities to the functions used to load the hydrological data and it re-uses
some of the methods developed for them.</p>
<p>It is possible to have a constant substrate if const_sub= True. In this
case, an hdf5 is created with only the default value marked. This form of hdf5 file is then managed by the merge
function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>const_sub</strong> &#8211; If True, a constant substrate is being loaded. Usually it is set to False.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.log_txt">
<code class="descname">log_txt</code><span class="sig-paren">(</span><em>code_type</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.log_txt" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gives the log for the substrate in text form. this is in a function because it is used twice in
the function load_sub_gui()</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.name_last_merge">
<code class="descname">name_last_merge</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.name_last_merge" title="Permalink to this definition">¶</a></dt>
<dd><p>This function opens the xml project file to find the name of the last hdf5 merge file and to add it
to the GUI on the QLabel self.lm2. It also add a QToolTip with the name of substrate and hydraulic files used
to create this merge file. If there is no file found, this function do nothing.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.recreate_image_sub">
<code class="descname">recreate_image_sub</code><span class="sig-paren">(</span><em>save_fig=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.recreate_image_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to recreate the image linked with the subtrate. So this is not the figure for the &#8220;merge&#8221;
part, but only to show the substrat alone.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param:</th><td class="field-body">save_fig: A boolean to save or not the figure</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.send_merge_grid">
<code class="descname">send_merge_grid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.send_merge_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls the function merge grid in substrate.py. The goal is to have the substrate and hydrological
data on the same grid. Hence, the hydrological grid will need to be cut to the form of the substrate grid.</p>
<p>This function can be slow so it call on a second thread.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.SubstrateW.update_sub_hdf5_name">
<code class="descname">update_sub_hdf5_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.SubstrateW.update_sub_hdf5_name" title="Permalink to this definition">¶</a></dt>
<dd><p>This function update the QComBox on substrate data which is on the substrate tab. The similiar function
for hydrology is in Main_Windows_1.py as it is more practical to have it there to collect all the signals.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.hydro_GUI_2.TELEMAC">
<em class="property">class </em><code class="descclassname">src_GUI.hydro_GUI_2.</code><code class="descname">TELEMAC</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.TELEMAC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#src_GUI.hydro_GUI_2.SubHydroW" title="src_GUI.hydro_GUI_2.SubHydroW"><code class="xref py py-class docutils literal"><span class="pre">src_GUI.hydro_GUI_2.SubHydroW</span></code></a></p>
<p>The class Telemac is there to manage the link between the graphical interface and the functions in src/selafin_habby1.py
which loads the Telemac data in 2D. It inherits from SubHydroW() so it have all the methods and the variables
from the class SubHydroW(). It is very similar to RUBAR2D class, but data from Telemac is on the node as in HABBY.</p>
<dl class="method">
<dt id="src_GUI.hydro_GUI_2.TELEMAC.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.TELEMAC.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used by __init__() during the initialization.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.hydro_GUI_2.TELEMAC.load_telemac_gui">
<code class="descname">load_telemac_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.hydro_GUI_2.TELEMAC.load_telemac_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>The function which call the function which load telemac and save the name of files in the project file</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="figure-option-gui">
<h2>Figure Option - GUI<a class="headerlink" href="#figure-option-gui" title="Permalink to this headline">¶</a></h2>
<p>in src_GUI/output_fig_GUI.py</p>
<p>This python module lets the user select various options to create the figures, notably the colormap or the size of the text.
It is also wehre the user select the needed outputs.</p>
<span class="target" id="module-src_GUI.output_fig_GUI"></span><dl class="function">
<dt id="src_GUI.output_fig_GUI.create_default_figoption">
<code class="descclassname">src_GUI.output_fig_GUI.</code><code class="descname">create_default_figoption</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.output_fig_GUI.create_default_figoption" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates the default dictionnary of option for the figure.</p>
</dd></dl>

<dl class="function">
<dt id="src_GUI.output_fig_GUI.load_fig_option">
<code class="descclassname">src_GUI.output_fig_GUI.</code><code class="descname">load_fig_option</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.output_fig_GUI.load_fig_option" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the figure option saved in the xml file and create a dictionnary will be given to the functions
which create the figures to know the different options chosen by the user. If the options are not written, this
function uses data by default which are in the fonction create_default_fig_options().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path_prj</strong> &#8211; the path to the xml project file</li>
<li><strong>name_prj</strong> &#8211; the name to this file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the dictionary containing the figure options</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="src_GUI.output_fig_GUI.outputW">
<em class="property">class </em><code class="descclassname">src_GUI.output_fig_GUI.</code><code class="descname">outputW</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.output_fig_GUI.outputW" title="Permalink to this definition">¶</a></dt>
<dd><p>The class which support the creation and management of the output. It is notably used to select the options to
create the figures.</p>
<dl class="method">
<dt id="src_GUI.output_fig_GUI.outputW.check_uncheck">
<code class="descname">check_uncheck</code><span class="sig-paren">(</span><em>main_checkbox</em>, <em>other_checkbox</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.output_fig_GUI.outputW.check_uncheck" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to check a box when the user clied on it and unckeked another passed as parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>main_checkbox</strong> &#8211; A QCheckBox which sould by selected</li>
<li><strong>other_checkbox</strong> &#8211; A QCheckbox which should be &#8220;unticked&#8221; when main_checkbox is selected by the user</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.output_fig_GUI.outputW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.output_fig_GUI.outputW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="src_GUI.output_fig_GUI.outputW.save_option_fig">
<code class="descname">save_option_fig</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.output_fig_GUI.outputW.save_option_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which save the options for the figures in the xlm project file. The options for the figures are
contained in a dictionnary. The idea is to give this dictinnory in argument to all the fonction which create
figures. In the xml project file, the options for the figures are saved under the attribute &#8220;Figure_Option&#8221;.</p>
<p>If you change things here, it is necessary to start a new project as the old projects will not be compatible.
For the new version of HABBY, it will be necessary to insure compatibility by adding xml attribute.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.output_fig_GUI.outputW.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.output_fig_GUI.outputW.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal used to write the log.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="src_GUI.output_fig_GUI.set_lang_fig">
<code class="descclassname">src_GUI.output_fig_GUI.</code><code class="descname">set_lang_fig</code><span class="sig-paren">(</span><em>nb_lang</em>, <em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.output_fig_GUI.set_lang_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>This function write in the xml file in which langugage the figures should be done. This is kept in the
group of attribute in the Figure_Option
:param lang: An int indicating the langugage (0 for english, 1 for french,...)
:param path_prj: the path to the project
:param name_prj: the name of the project</p>
</dd></dl>

</div>
<div class="section" id="the-stathab-model-gui">
<h2>The Stathab model - GUI<a class="headerlink" href="#the-stathab-model-gui" title="Permalink to this headline">¶</a></h2>
<p>in src_GUI/stathab_GUI.py</p>
<span class="target" id="module-src_GUI.stathab_GUI"></span><dl class="class">
<dt id="src_GUI.stathab_GUI.StathabW">
<em class="property">class </em><code class="descclassname">src_GUI.stathab_GUI.</code><code class="descname">StathabW</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW" title="Permalink to this definition">¶</a></dt>
<dd><p>The class to load and manage the widget controlling the Stathab model.</p>
<p><strong>Technical comments</strong></p>
<p>The class StathabW makes the link between the data prepared by the user for Stathab and  the Stathab model
which is in the src folder (stathab_c.py) using the graphical interface.  Most of the Stathab input are given in
form of text file. For more info on the preparation of text files for stathab, read the document called
&#8216;stathabinfo.pdf&#8221;.  To use Stathab in HABBY, all Stathab input should be in the same directory. The user select
this directory (using the button “loadb”) and HABBY tries to find the file it needs. All found files are added to
the list called “file found”. If file are missing, they are added to the “file still needed” list.  The user can then
select the fishes on which it wants to run stathab, then it run it by pressing on the “runb” button.</p>
<p>If file where loaded before by the user in the same project, StathabW looks for them and load them again. Here we
can have two cases: a) the data was saved in hdf5 format (as it is done when a stathab run was done) and the path
to this file noted in the xml project file. b) Only the name of the directory was written in the xml project file,
indicated that data was loaded but not saved in hdf5 yet. HABBY manages both cases.</p>
<p>Next, we check in the xml project file where the folder to save the figure (path_im) is. In case, there are
no path_im saved, Stathab create one folder to save the figure outputs. This should not be the usual case. Generally,
path_im is created with the xml project file, but you cannot be sure.</p>
<p>There is a list of error message which are there for the case where the data which was loaded before do not exist
anymore. For example, somebody erased the directory with the Stathab data in the meantime.  In this case,
a pop-up message open and warn the user.</p>
<p>An important attribute of StathabW() is self.mystathab. This is an object fo the stahab class. The stathab model,
which is in the form of a class and not a function, will be run on this object.</p>
<p>StathabW inherit StatModUseful, which is a class mostly used to manage the exchange of the fish name between the
two QListWidget (selected fish and available fish).</p>
<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.add_all_fish">
<code class="descname">add_all_fish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.add_all_fish" title="Permalink to this definition">¶</a></dt>
<dd><p>This function add the name of all known fish (the ones in Pref.txt) to the QListWidget. Careful,
a similar function exists in Fstress_GUI. Modify both if needed.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.change_riv_type">
<code class="descname">change_riv_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.change_riv_type" title="Permalink to this definition">¶</a></dt>
<dd><p>This function manage the changes which needs to happends to the GUI when the user want to pass from
tropical river to temperate river and vice-versa. Indeed the fish species and the input files are not
the same for tropical and temperate river.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.load_from_hdf5_gui">
<code class="descname">load_from_hdf5_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.load_from_hdf5_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls from the GUI the load_stathab_from_hdf5 function. In addition to call the function to load
the hdf5, it also updates the GUI according to the info contained in the hdf5.</p>
<p><strong>Technical comments</strong></p>
<p>This functino updates the Qlabel similarly to the function “load_from_txt_gui()”.
It also loads the data calling the load_stathab_from_hdf5 function from the Stathab class in src. The info
contains in the hdf5 file are now in the memory in various variables called self.mystathab.”something”.
HABBY used them to update the GUI. First, it updates the list which contains the name of the reaches
(self.list_re.). Next, it checks that each of the variable needed exists and that they contain some data.
Afterwards, HABBY looks which preference file to use. Either, it will use the default preference file
(contained in HABBY/biology) or a custom preference prepared by the user. This custom preference
file should be in the same folder than the hdf5 file. When the preference file was found, HABBY reads all
the fish type which are described and add their name to the self.list_f list which show the available fish
to the user in the GUI. Finally it checks if all the variables were found or if some were missing</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.load_from_txt_gui">
<code class="descname">load_from_txt_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.load_from_txt_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>The main roles of load_from_text_gui() are to call the load_function of the stathab class (which is in
stathab_c.py in the folder src) and to call the function which create an hdf5 file. However, it does some
modifications to the GUI before.</p>
<p><strong>Technical comments</strong></p>
<p>Here is the list of the modifications done to the graphical user interface before calling the load_function of
Stathab.</p>
<p>First, it updates the label. Because a new directory was selected, we need to update the label containing the
directory’s name. We only show the 30 last character of the directory name. In addition, we also need to update
the other label. Indeed, it is possible that the data used by Stathab would be loaded from an hdf5 file.
In this case, the labels on the top of the list of file are slightly modified. Here, we insure that we are in
the “text” version since we will load the data from text file.</p>
<p>Next, it gets the name of all the reach and adds them to the list of reach name. For this, it calls a function
from the stathab class (in src). Then, it looks which files are present and add them to the list which contains
the reach name called self.list_re.</p>
<p>Afterwards, it checks if the files needed by Stathab are here. The list of file is given in the
self.end_file_reach list. The form of the file is always the name of the reach + one item of
self.end_file_reach. If it does not find all files, it add the name of the files not found to self.list_needed,
so that the user can be aware of which file he needs. The exception is Pref.txt. If HABBY do not find it in the
directory, it uses the default “Pref.txt”. All files (apart from Pref.txt) should be in the same directory.
If the river is temperate, the files needed are not the same than if the river is in the tropic. This is
accounted using the variable rivint. If rivint is zero, the river is temparate and this function looks for the
file needed for temperate type (list of file contained in self.end_file_reach and self.name_file_allreach).
If riverin is equal to 1 or 2, the river is tropical (list of file contained in self.end_file_reach_top and
biological data in the stathab folder in the biology folder (many files). If the river is temperate,
all preference coeff are in one file called Pref.txt (also in the stathab folder of the biology folder).</p>
<p>Then, it calls a method of the Stathab class (in src) which reads the “pref.txt” file and adds the name
of the fish to the GUI. If the &#8220;tropical river&#8221; option is selected, it looks which preference file are present
in self.path_bio_stathab. The name of the tropical preference file needs to be in this form: YuniYh_XXX.csv and
YuniYh_XX.csv for the univariate case and YbivYXXX.csv for the bivarate where XX is the three letter fish code
from ONEMA and Y is whatever string. The form of the preference file is the form from the R version of
stathab 2.</p>
<p>Next, if all files are present, it loads the data using the method written in Stathab
(in the src folder). When the data is loaded, it creates an hdf5 file from this data and save the name of this
new hdf5 file in the xml project file (also using a method in the stathab class).</p>
<p>Finally, it sends the log info as explained in the log section of the documentation</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.reach_selected">
<code class="descname">reach_selected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.reach_selected" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which indcates which files are linked with which reach.</p>
<p><strong>Technical comment</strong></p>
<p>This is a small function which only impacts the GUI. When a Stathab model has more than one reach,
the user can click on the name of the reach. When he does this, HABBY selects the first file linked
with this reach and shows it in self.list_f. This first file is highlighted and the list is scrolled
down so that the files linked with the selected reach are shown. This function manages this. It is connected
with the list self.list_re, which is the list with the name of the reaches.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.recreate_image">
<code class="descname">recreate_image</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.recreate_image" title="Permalink to this definition">¶</a></dt>
<dd><p>This function redo the figures from Stahtab</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.run_stathab_gui">
<code class="descname">run_stathab_gui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.run_stathab_gui" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the function which calls the function to run the Stathab model.  First it read the list called
self.list_s. This is the list with the fishes selected by the user. Then, it calls the function to run
stathab and the one to create the figure if the figures were asked by the user. Finally, it writes the log.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.select_dir">
<code class="descname">select_dir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.select_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to select the directory and find the files to laod stathab from txt files. It calls
load_from_txt_gui() when done.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.select_hdf5">
<code class="descname">select_hdf5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.select_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>This function allows the user to choose an hsdf5 file as input from Stathab.</p>
<p><strong>Technical comment</strong></p>
<p>This function is for example useful if the user would have created an hdf5 file for a Stathab model in another
project and he would like to send the same model on other fish species.</p>
<p>This function writes the name of the new hdf5 file in the xml project file. It also notes that the last data
loaded was of hdf5 type. This is useful when HABBY is restarting because it is possible to have a
directory name and the address of an hdf5 file in the part of the xml project file concerning Stathab.
HABBY should know if the last file loaded was this hdf5 or the files in the directory.
Finally, it calls the function to load the hdf5 called load_from_hdf5_gui.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.stathab_GUI.StathabW.send_err_log">
<code class="descname">send_err_log</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.send_err_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Send the errors and warnings to the logs. It is useful to note that the stdout was redirected to self.mystdout.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.stathab_GUI.StathabW.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal used to write the log.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.stathab_GUI.StathabW.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.stathab_GUI.StathabW.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyQtsignal used to show the figures.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="fstress-model-gui">
<h2>FStress model - GUI<a class="headerlink" href="#fstress-model-gui" title="Permalink to this headline">¶</a></h2>
<p>in src_GUI/fstress_GUI.py</p>
<span class="target" id="module-src_GUI.fstress_GUI"></span><dl class="class">
<dt id="src_GUI.fstress_GUI.FstressW">
<em class="property">class </em><code class="descclassname">src_GUI.fstress_GUI.</code><code class="descname">FstressW</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.fstress_GUI.FstressW" title="Permalink to this definition">¶</a></dt>
<dd><p>This class provides the graphical user interface for the habby version of Fstress. The Fstress model is described in
fstress.py. FstressW just loads the data given by the user. He/She can write this data in the GUI or loads it
from files. The following files are needed:</p>
<ul class="simple">
<li>listriv.txt the list of the river (if the file does not exist, the river is called river1).</li>
<li>rivqwh.txt discharge, width, height for two discharge (measured) for each rivers.</li>
<li>rivdeb.txt max and min discharge.</li>
</ul>
<p>FStress inherits from the class StatModUseful. This class is a &#8220;parent&#8221; class with some functions which are the same
for estimhab and fstress. Hence, we can re-use these function without re.writing them (a bit like SubHydroW)</p>
<dl class="method">
<dt id="src_GUI.fstress_GUI.FstressW.add_all_fish">
<code class="descname">add_all_fish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.fstress_GUI.FstressW.add_all_fish" title="Permalink to this definition">¶</a></dt>
<dd><p>This function add the name of all known fish (the ones in Pref.txt) to the QListWidget. This function
was copied from the one in SStathab_GUI.py</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.fstress_GUI.FstressW.erase_name">
<code class="descname">erase_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.fstress_GUI.FstressW.erase_name" title="Permalink to this definition">¶</a></dt>
<dd><p>This function erases the data from the river selected by the user.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.fstress_GUI.FstressW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.fstress_GUI.FstressW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to initialized an instance of the FstressW() class. It is called by __init__().
It is very similar to EstihabW but it is possible to get more than one river and it can load the data from
folder.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.fstress_GUI.FstressW.load_all_fish">
<code class="descname">load_all_fish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.fstress_GUI.FstressW.load_all_fish" title="Permalink to this definition">¶</a></dt>
<dd><p>This function find the preference file, load the preference coefficient for each invertebrate and show their name
on QListWidget. it is run at the start of the program. FStress cannot be run as long as a preference file is not
found.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.fstress_GUI.FstressW.load_data_fstress">
<code class="descname">load_data_fstress</code><span class="sig-paren">(</span><em>rind</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.fstress_GUI.FstressW.load_data_fstress" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the data for fstress and add it to the variable self.qrange and self.qhw for the river
rind.
:param rind: The indices of the river is self.river_name. So it is which river should be loaded</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.fstress_GUI.FstressW.load_hdf5_fstress">
<code class="descname">load_hdf5_fstress</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.fstress_GUI.FstressW.load_hdf5_fstress" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads an hdf5 file in the fstress format and add it to the project. This hdf5 file was not part of
the project previously.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.fstress_GUI.FstressW.load_txt">
<code class="descname">load_txt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.fstress_GUI.FstressW.load_txt" title="Permalink to this definition">¶</a></dt>
<dd><p>In this function, the user select a qhw.txt or a listriv.txt file. This files are loaded and written on the GUI.
If a listriv.txt is selected, the river in lisriv.txt are loaded. If a qhw.txt is loaded and if there are
more than one qhw.txt in the folder, we ask the user if all files must be loaded. The needed text files are
the following:</p>
<ul class="simple">
<li>listriv.txt is a text file with one river name by line (not necessary)</li>
<li>rivnameqhw.txt is a text file with minimum two lines which the measured discharge, height and width for
2 measureement (necessary)</li>
<li>rivernamedeb.txt is a text file which has two lines. The first line is the minimum discharge and the second is
the maximum discharge to be modelled. It is chosen by the user (necessary to run, but can be given by the user
on the GUI)</li>
</ul>
<p>All data should be in SI unit.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.fstress_GUI.FstressW.modify_name">
<code class="descname">modify_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.fstress_GUI.FstressW.modify_name" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to modify the name of a river. It will only be saved if FStress is run. Otherwise it
is not kept in the data.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.fstress_GUI.FstressW.runsave_fstress">
<code class="descname">runsave_fstress</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.fstress_GUI.FstressW.runsave_fstress" title="Permalink to this definition">¶</a></dt>
<dd><p>This function save the data related to FStress and call the model Fstress. It is the method which makes the
link between the GUI and fstress.py.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.fstress_GUI.FstressW.save_river_data">
<code class="descname">save_river_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.fstress_GUI.FstressW.save_river_data" title="Permalink to this definition">¶</a></dt>
<dd><p>This function save the data for one river based on the data from the GUI (i.e., after modification by the user).
It can be used to save the data given directely by the user or modified by him.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.fstress_GUI.FstressW.show_data_one_river">
<code class="descname">show_data_one_river</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.fstress_GUI.FstressW.show_data_one_river" title="Permalink to this definition">¶</a></dt>
<dd><p>This function shows the qhw and the [qmin, qmax] data on the GUI for the river selected by the user.
The river must have been loaded before. It also show the selected fish</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.fstress_GUI.FstressW.update_list_riv">
<code class="descname">update_list_riv</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.fstress_GUI.FstressW.update_list_riv" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is a small function to update the QCombobox which contains the river name</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.fstress_GUI.FstressW.was_loaded_before">
<code class="descname">was_loaded_before</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.fstress_GUI.FstressW.was_loaded_before" title="Permalink to this definition">¶</a></dt>
<dd><p>This function looks in the xml project file is an hdf5 exists already. If yes, it loads this data
and show it on the GUI.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="estimhab-gui">
<h2>Estimhab - GUI<a class="headerlink" href="#estimhab-gui" title="Permalink to this headline">¶</a></h2>
<p>in src_GUI/estimhab_GUI.py</p>
<span class="target" id="module-src_GUI.estimhab_GUI"></span><dl class="class">
<dt id="src_GUI.estimhab_GUI.EstimhabW">
<em class="property">class </em><code class="descclassname">src_GUI.estimhab_GUI.</code><code class="descname">EstimhabW</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW" title="Permalink to this definition">¶</a></dt>
<dd><p>The Estimhab class provides the graphical interface for the version of the Estimhab model written in HABBY.
The Estimhab model is described elsewhere. EstimhabW() just loads the data for Estimhab given by the user.</p>
<dl class="method">
<dt id="src_GUI.estimhab_GUI.EstimhabW.change_folder">
<code class="descname">change_folder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.change_folder" title="Permalink to this definition">¶</a></dt>
<dd><p>A small method to change the folder which indicates where is the biological data</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.EstimhabW.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to initialized an instance of the EstimhabW() class. It is called by __init__().</p>
<blockquote>
<div><p><strong>Technical comments and walk-through</strong></p>
<p>First we looked if some data for Estimhab was saved before by an user. If yes, we will fill the GUI with
the information saved before. Estimhab information is saved in hdf5 file format and the path/name of the
hdf5 file is saved in the xml project file. So we open the xml project file and look if the name of an hdf5
file was saved for Estimhab. If yes, the hdf5 file is read.</p>
<p>The format of hdf5 file is relatively simple. Each input data for Estimhab has its own dataset (qmes, hmes,
wmes, q50, qrange, and substrate).  Then, we have a list of string which are a code for the fish species which
were analyzed.  All the data contained in hdf5 file is loaded into variable.</p>
<p>The different label are written on the graphical interface. Then, two QListWidget are modified. The first
list contains all the fish species on which HABBY has info (see XML Estimhab format for more info).
The second list is the fish selected by the user on which Estimhab will be run. Here, we link these lists
with two functions so that the user can select/deselect fish using the mouse. The function name are add_fish()
and remove_fish().</p>
<p>Then, we fill the first list. HABBY look up all file of xml type in the “Path_bio” folder (the one indicated in
the xml project file under the attribute “Path_bio”).  The name are them modified so that the only the name of
species appears (and not the full path). We set the layout with all the different QLineEdit where the user
can write the needed data.</p>
<p>Estimhab model is saved using a function situated in MainWindows_1.py  (frankly, I am not so sure why I did put
the save function there, but anyway). So the save button just send a signal to MainWindows
here, which save the data.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.EstimhabW.open_estimhab_hdf5">
<code class="descname">open_estimhab_hdf5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.open_estimhab_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>This function opens the hdf5 data created by estimhab</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.EstimhabW.run_estmihab">
<code class="descname">run_estmihab</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.run_estmihab" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to execute Estimhab by calling the estimhab function.</p>
<p><strong>Technical comment</strong></p>
<p>This is the function making the link between the GUI and the source code proper. The source code for Estimhab
is in src/Estimhab.py.</p>
<p>This function loads in memory the data given in the graphical interface and call sthe Estimhab model.
The data could be written by the user now or it could be data which was saved in the hdf5 file before and
loaded when HABBY was open (and the init function called).  We check that all necessary data is present and
that the data given makes sense (e.g.,the minimum discharge should not be bigger than the maximal discharge,
the data should be a float, etc.). We then remove the duplicate fish species (in case the user select one
specie twice) and the Estimhab model is called. The log is then written (see the paragraph on the log for more
information). Next, the figures created by Estimmhab are shown. As there is only a short number of outputs
for Estimhab, we create a figure in all cases (it could be changed by adding a checkbox on the GUI like
in the Telemac or other hydrological class).</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.estimhab_GUI.EstimhabW.save_signal_estimhab">
<code class="descname">save_signal_estimhab</code><a class="headerlink" href="#src_GUI.estimhab_GUI.EstimhabW.save_signal_estimhab" title="Permalink to this definition">¶</a></dt>
<dd><p>PyQtsignal to save the Estimhab data.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="src_GUI.estimhab_GUI.StatModUseful">
<em class="property">class </em><code class="descclassname">src_GUI.estimhab_GUI.</code><code class="descname">StatModUseful</code><a class="headerlink" href="#src_GUI.estimhab_GUI.StatModUseful" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is not called directly by HABBY, but it is the parent class of EstihabW and FstressW. As fstress and
estimhab have a similar graphical user interface, this architecture allows to re-use some functions between the
two classes, which saves a bit of coding.</p>
<dl class="method">
<dt id="src_GUI.estimhab_GUI.StatModUseful.add_fish">
<code class="descname">add_fish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.StatModUseful.add_fish" title="Permalink to this definition">¶</a></dt>
<dd><p>The function is used to select a new fish species (or inverterbrate)</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.StatModUseful.add_sel_fish">
<code class="descname">add_sel_fish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.StatModUseful.add_sel_fish" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the xml file and check if some fish were selected before. If yes, we add them to the list</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.StatModUseful.find_path_hdf5_est">
<code class="descname">find_path_hdf5_est</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.StatModUseful.find_path_hdf5_est" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to find the path where to save the hdf5 file. Careful a simialar one is in hydro_GUI_2.py and in
stathab_c. By default, path_hdf5 is in the project folder in the folder &#8216;fichier_hdf5&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.StatModUseful.find_path_im_est">
<code class="descname">find_path_im_est</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.StatModUseful.find_path_im_est" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to find the path where to save the figues. Careful there is similar function in hydro_GUI_2.py.
Do not mix it up</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">path_im a string which indicates the path to the folder where are save the images.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.StatModUseful.find_path_input_est">
<code class="descname">find_path_input_est</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.StatModUseful.find_path_input_est" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to find the path where to save the input file. Careful a simialar one is in estimhab_GUI.py. By default,
path_input indicates the folder &#8216;input&#8217; in the project folder.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.StatModUseful.find_path_output_est">
<code class="descname">find_path_output_est</code><span class="sig-paren">(</span><em>att</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.StatModUseful.find_path_output_est" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to find the path where to save the shapefile, paraview files and other future format. Here, we gave
the xml attribute as argument so this functin can be used to find all path needed. However, it is less practical
to use as the function above as one should remember the xml tribute to call this function. However, it can be
practical to use to add new folder.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>att</strong> &#8211; the xml attribute (from the xml project file) linked to the path needed, without the .//</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.StatModUseful.find_path_text_est">
<code class="descname">find_path_text_est</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.StatModUseful.find_path_text_est" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to find the path where to save the hdf5 file. Careful a simialar one is in estimhab_GUI.py. By default,
path_hdf5 is in the project folder in the folder &#8216;fichier_hdf5&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.StatModUseful.remove_all_fish">
<code class="descname">remove_all_fish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.StatModUseful.remove_all_fish" title="Permalink to this definition">¶</a></dt>
<dd><p>This function removes all fishes from the selected fish</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.StatModUseful.remove_fish">
<code class="descname">remove_fish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.StatModUseful.remove_fish" title="Permalink to this definition">¶</a></dt>
<dd><p>The function is used to remove fish species (or inverterbates species)</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.estimhab_GUI.StatModUseful.send_err_log">
<code class="descname">send_err_log</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.estimhab_GUI.StatModUseful.send_err_log" title="Permalink to this definition">¶</a></dt>
<dd><p>This function sends the errors and the warnings to the logs.
The stdout was redirected to self.mystdout before calling this function. It only sends the hundred first errors
to avoid freezing the GUI. A similar function exists in hydro_GUI_2.py. Correct both if necessary.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.estimhab_GUI.StatModUseful.send_log">
<code class="descname">send_log</code><a class="headerlink" href="#src_GUI.estimhab_GUI.StatModUseful.send_log" title="Permalink to this definition">¶</a></dt>
<dd><p>PyQtsignal to write the log.</p>
</dd></dl>

<dl class="attribute">
<dt id="src_GUI.estimhab_GUI.StatModUseful.show_fig">
<code class="descname">show_fig</code><a class="headerlink" href="#src_GUI.estimhab_GUI.StatModUseful.show_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>PyQtsignal to show the figures.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="information-biological-and-run-habitat">
<h2>Information Biological and Run habitat<a class="headerlink" href="#information-biological-and-run-habitat" title="Permalink to this headline">¶</a></h2>
<p>in src_GUI/bio_info_GUI.py</p>
<p>This python module is where the biological info is managed and shown to the user.
It is also where the user can run the habitat calculation.</p>
<span class="target" id="module-src_GUI.bio_info_GUI"></span><dl class="class">
<dt id="src_GUI.bio_info_GUI.BioInfo">
<em class="property">class </em><code class="descclassname">src_GUI.bio_info_GUI.</code><code class="descname">BioInfo</code><span class="sig-paren">(</span><em>path_prj</em>, <em>name_prj</em>, <em>lang='French'</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.bio_info_GUI.BioInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>This class contains the tab with the biological information (the curves of preference). It inherites from
StatModUseful. StatModuseful is a QWidget, with some practical signal (send_log and show_fig) and some functions
to find path_im and path_bio (the path wher to save image) and to manage lists.</p>
<dl class="method">
<dt id="src_GUI.bio_info_GUI.BioInfo.get_autocompletion">
<code class="descname">get_autocompletion</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.bio_info_GUI.BioInfo.get_autocompletion" title="Permalink to this definition">¶</a></dt>
<dd><p>This function update the auto-complextin model as a function of the QComboxBox next to it</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.bio_info_GUI.BioInfo.init_iu">
<code class="descname">init_iu</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.bio_info_GUI.BioInfo.init_iu" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in the initialization by __init__()</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.bio_info_GUI.BioInfo.recreate_fig">
<code class="descname">recreate_fig</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.bio_info_GUI.BioInfo.recreate_fig" title="Permalink to this definition">¶</a></dt>
<dd><p>This function use show_image_hab() to recreate the habitat figures shown before</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.bio_info_GUI.BioInfo.run_habitat_value">
<code class="descname">run_habitat_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.bio_info_GUI.BioInfo.run_habitat_value" title="Permalink to this definition">¶</a></dt>
<dd><p>This function runs HABBY to get the habitat value based on the data in a &#8220;merged&#8221; hdf5 file and the chosen
preference files.</p>
<p>We should not add a comma in the name of the selected fish.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.bio_info_GUI.BioInfo.select_fish">
<code class="descname">select_fish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.bio_info_GUI.BioInfo.select_fish" title="Permalink to this definition">¶</a></dt>
<dd><p>This function select the fish which corresponds at the chosen criteria by the user. The type of criteria
is given in the list self.keys and the criteria is given in self.cond1. The condition should exactly
match the criteria. Sign such as * does not work.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.bio_info_GUI.BioInfo.show_hydrosignature">
<code class="descname">show_hydrosignature</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.bio_info_GUI.BioInfo.show_hydrosignature" title="Permalink to this definition">¶</a></dt>
<dd><p>This function make the link with function in bio_info.py which allows to load and plot the data realted
to the hydrosignature.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.bio_info_GUI.BioInfo.show_image_hab">
<code class="descname">show_image_hab</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.bio_info_GUI.BioInfo.show_image_hab" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is linked with the timer started in run_habitat_value. It is run regulary and
check if the function on the second thread have finised created the figures. If yes,
this function create the 1d figure for the HABBY GUI.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.bio_info_GUI.BioInfo.show_info_fish">
<code class="descname">show_info_fish</code><span class="sig-paren">(</span><em>select=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.bio_info_GUI.BioInfo.show_info_fish" title="Permalink to this definition">¶</a></dt>
<dd><p>This function shows the useful information concerning the selected fish on the GUI.</p>
<dl class="docutils">
<dt>:param select:If False, the selected items comes from the QListWidgetcontaining the available fish.</dt>
<dd>If True, the items comes the QListWidget with the selected fish</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="src_GUI.bio_info_GUI.BioInfo.show_info_fish_avai">
<code class="descname">show_info_fish_avai</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.bio_info_GUI.BioInfo.show_info_fish_avai" title="Permalink to this definition">¶</a></dt>
<dd><p>This function shows the useful information concerning the available fish on the GUI and
add the fish to  the selected fish This is what happens when the user click on the
first QListWidget (the one called available fish).</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.bio_info_GUI.BioInfo.show_info_fish_sel">
<code class="descname">show_info_fish_sel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.bio_info_GUI.BioInfo.show_info_fish_sel" title="Permalink to this definition">¶</a></dt>
<dd><p>This function shows the useful information concerning the already selected fish on the GUI and
remove the selected fish from the list of selected fish. This is what happens when the user click on the
second QListWidget (the one called selected fish and guild).</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.bio_info_GUI.BioInfo.show_pref">
<code class="descname">show_pref</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.bio_info_GUI.BioInfo.show_pref" title="Permalink to this definition">¶</a></dt>
<dd><p>This function shows the image of the preference curve of the selected xml file. For this it calls, the functions
read_pref and figure_pref of bio_info.py. Hence, this function justs makes the link between the GUI and
the functions effectively doing the image.</p>
</dd></dl>

<dl class="method">
<dt id="src_GUI.bio_info_GUI.BioInfo.update_merge_list">
<code class="descname">update_merge_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src_GUI.bio_info_GUI.BioInfo.update_merge_list" title="Permalink to this definition">¶</a></dt>
<dd><p>This function goes in the projet xml file and gets all available merged data. Usually, it is called
by Substrate() (when finished to merge some data) or at the start of HABBY.</p>
<p>We add a &#8220;tooltip&#8221; which indicates the orginal hydraulic and substrate files.</p>
</dd></dl>

</dd></dl>

<div class="section" id="biological-data-estimhab">
<h3>Biological data - Estimhab<a class="headerlink" href="#biological-data-estimhab" title="Permalink to this headline">¶</a></h3>
<p>The biological data, i.e., the preference curves of Estimhab, are saved in xml files
situated in the folder given by the path written in the xml project file under the
attribute Path_bio. By default, it is HABBY/biology. It is possible to change this folder
using the GUI.</p>
<p>Estimhab is a statistical model, which functions using mathematical regressions.
The different regressions (or preference curve) of each fish are described in an xml file
whose format is given here.</p>
<p>Conceptually, the regressions R are of two types:</p>
<ul class="simple">
<li>Type 0          R = C * Q^{m1} * exp(m2*Q)</li>
<li>Type 1          R = C * (1+m1*exp(m2*Q))</li>
</ul>
<p>Where Q is the discharge, m1 and m2 are coefficients which depend on the fish type, and C is a
constant which depends on the stream characteristic and the fish type.</p>
<p>The constant C is of the form C = a + sum ai * ln(Si) where a and ai are coefficients which depend on
the fish type. Si are particular stream characteristics. Which characteristics should be used is a
function of the fish type and is so given in the xml file. The value of S i is a function of the stream
and is calculated by the program.</p>
<p>In the xml file,</p>
<ul class="simple">
<li>Attribute coeff_q: Give the main coefficients of the regression (m1 and m2)</li>
<li>Attribute func_q : Give the type of regression R used.  Type 0 and type 1, as described above, are known by HABBY.</li>
<li>Attribute coeff_const: Give the coefficient used to construct the constant C (a, a1, a2, a3,…). The number of coefficient differs for each fish, but should be at least one.</li>
<li>Attribute var_const: Give which type of stream characteristics is used. This is not the value of the particular characteristic, but only which type is used. The following list of type is accepted:<ul>
<li>0 for Q50, natural median discharge</li>
<li>1 for H50, the height of the stream at q50</li>
<li>2 for L50, the width of the stream at q50</li>
<li>3 for V50, the velocity of the stream at q50</li>
<li>4 for Re50, the discharge divided by 10 times the width at Q50</li>
<li>5 for Fr50, the Froude number at Q50</li>
<li>6 for Dh50, the mean substrate height divided by h50</li>
<li>7 for Exp(Dh50). Erase the log() of this particular term of the constant</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="section" id="calculation-of-fish-s-habitat">
<h1>Calculation of fish&#8217;s habitat<a class="headerlink" href="#calculation-of-fish-s-habitat" title="Permalink to this headline">¶</a></h1>
<p>The src folder contains the python module which are not linked with the graphical user interface.</p>
<span class="target" id="module-src"></span><div class="section" id="hec-ras-model-1d">
<h2>Hec-ras model 1D<a class="headerlink" href="#hec-ras-model-1d" title="Permalink to this headline">¶</a></h2>
<p>in src/Hec_ras06.py</p>
<p>This module contains the functions used to load the outputs from the hec-ras model in 1.5D.</p>
<span class="target" id="module-src.Hec_ras06"></span><dl class="function">
<dt id="src.Hec_ras06.coord_profile_non_georeferenced">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">coord_profile_non_georeferenced</code><span class="sig-paren">(</span><em>data_bank_all</em>, <em>data_dist_all</em>, <em>data_river_all</em>, <em>data_profile_all</em>, <em>nb_pro_reach</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.coord_profile_non_georeferenced" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to create the coordinates of the profile in the non-georeferenced case.
This function is called by open geo_file(). Hypothesis: The profile are straight and perpendicular to the river.
The last profile is at the end of the river.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_bank_all</strong> &#8211; distance along the profile of bank station</li>
<li><strong>data_dist_all</strong> &#8211; the distance between the profile (left, center channel, right)</li>
<li><strong>data_river_all</strong> &#8211; the coordinate of the river</li>
<li><strong>data_profile_all</strong> &#8211; the (d,z) data of the profile</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the coordinates of the profile</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>For each profile, we create an array composed of five points: Start of profile, left bank, intersection between
river and profile, right bank and end of profile. The intersection with the river is directly given as input to
the function. Then we find the vector perpendicular to this river and we get the four other points on the same line.</p>
<p>To get the distance for these four other point, we must be careful to pass from the distance given in meter and the
distance in the model coordinates (scaled between [0, 1] usually). The way to go from one coordinate system to
another is to use the “alpha” variable.  We only need to correct distance, no problem with a system of coordinate
which would not be in the same direction (as the data is given along a profile). The river passes in the middle of
the right and left bank, so we can find where is left and right bank is. Because we know the total length of the
profile, we can also find the beginning and end of the profile.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.figure_xml">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">figure_xml</code><span class="sig-paren">(</span><em>data_profile</em>, <em>coord_pro_old</em>, <em>coord_r</em>, <em>xy_h_all</em>, <em>zone_v_all</em>, <em>pro</em>, <em>path_im</em>, <em>fig_opt</em>, <em>nb_sim=0</em>, <em>name_profile='no_name'</em>, <em>coord_p2=-99</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.figure_xml" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to plot the results of the loading of hec-ras data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data_profile</strong> &#8211; (list with np.array)</li>
<li><strong>coord_pro_old</strong> &#8211; (x,y) data of the profile (list with np.array)</li>
<li><strong>coord_r</strong> &#8211; (x,y) data of the river (list with np.array)</li>
<li><strong>xy_h_all</strong> &#8211; (x,y, h) for the height data for each simulation (list with np.array)</li>
<li><strong>zone_v_all</strong> &#8211; (x,y, v) for the velocity data. velocity is by zone of profile. for each simulation.
the (x,y) indicates the start of the zone which end with the next velocity</li>
<li><strong>pro</strong> &#8211; a list of int with the profile whcih should be ploted [2,3,4]</li>
<li><strong>nb_sim</strong> &#8211; which simulation should be plotted. In fact, it often relates to the time step.</li>
<li><strong>name_profile</strong> &#8211; a list of string with the name of the profiles</li>
<li><strong>coord_p2</strong> &#8211; the data of the profile when non geo-referenced, optional</li>
<li><strong>path_im</strong> &#8211; the path where the figure should be saved (string)</li>
<li><strong>fig_opt</strong> &#8211; the figure options</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>We first choose the size of the font to be written. At term, it should be given by the options.</p>
<p>Two main groups of figure will be done: One list of figure with the form of the profil, the water height, and the
velocity for the chosen profiles and one (x,y) view of the position of each profile.</p>
<p>We chose the time step to be written (the variable nb_sim here). The variable pro is a list which says which
profiles are to be plotted. Hence, we get the velocity and water height for the time step and profile of interest.</p>
<p>To plot the velocity, we first get the distance along the profile where the water level cut the profile elevation.
This is the variable xint1 and xint2. We then get the velocity data for the region under the water. We add three
points for velocity at 0, xint1 and xint2. We then used the step function to plot the vecloity. Because of the added
point, we will have a zero velocity from 0 to xint1, then the velocity data, then again zeros from xint2 to the end.</p>
<p>To plot the elevation of the profile, we plot the variable xz and we use the function fill_between to fill
in blue the region under water. This function creates a line at the water elevation and fills in blue between this
line and the profile elevation. We add some titles and save the figures.</p>
<p>For the second type of figure (view in x,y coordinates), We first plot the river position which is saved in the
coord_r variable. Then we plot the coordinate of each profile and their names. If the name of the profile is not
known, we plot the profile number.  We also plot the position of each velocity data and height data (as it could be
useful). If the figure gets too complicated, this can be taken away by changing the two lines which finish
with height or velocity as comment.  We add some titles and save the figures.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.find_coord_height_velocity">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">find_coord_height_velocity</code><span class="sig-paren">(</span><em>coord_pro</em>, <em>data_profile</em>, <em>vel</em>, <em>wse</em>, <em>nb_sim</em>, <em>max_vel_dist=0</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.find_coord_height_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>This function finds the coordinates of the height/velocity. In hec-ras outputs the data are often written in the
form (profile, distance along the profile, data). This function passes this type of information in the usual
coordinate form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coord_pro</strong> &#8211; the coordinate (x,y) of the profile. List of np.array.</li>
<li><strong>data_profile</strong> &#8211; data concening the geometry of the profile, notably its elevation (x,z). List of np.array.</li>
<li><strong>vel</strong> &#8211; the velocity data. List of np.array.</li>
<li><strong>wse</strong> &#8211; the water surface elevation. List of np.array.</li>
<li><strong>nb_sim</strong> &#8211; the number of simulation in case there is more than one</li>
<li><strong>max_vel_dist</strong> &#8211; the minimum number of velocity point by ten meter before a warnings appears</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">for each simulation, a list of np.array representing (x,y,v) and (x,y,h,)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>This is a function called after having loaded the data. Hec-Ras present the data in (profil, distance along
profile, data) form for the height. For the velocity, it is similar but the distance is given by a number between
0 and 1 (0 is the start of the profile, 1 is the end of the profile). This function transforms this data in the form
(x,y, dist, data) using the (x,y) coordinates given in the coord_pro variable. In other word,  we have the
coordinate of the profile, not of the coordinates of the height and velocity data.</p>
<p>First, we get the distance between all points in (x,y) system. Then, we get the length of the profile in
meter or feet. It is possible to have a (x,y) coordinate system in a different unit. Hence, the length of the profil
is valid for the (profile, distance along profile, data) view. We multiply the velocity distance data by this
length. Hence, the distance information is now in meter or feet along the profile for water height and velocity.</p>
<p>There are some lines added to account for the last and first points of the profile (annoying in hec-ras). We then
calculate the new coordinates. For each velocity and water height point, we find the last known point in the (x,y)
coordinates. We do a vectorial addition from this point plus the vector between this point and the next multiplied
by the distance from this point to the point that we tried to calculate.  The variable alpha is used to pass from
one coordinate system to the next one.</p>
<p>Careful the height is on the node and the velocity is by zone.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.get_rid_of_white_space">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">get_rid_of_white_space</code><span class="sig-paren">(</span><em>stream_str</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.get_rid_of_white_space" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a small fonction to get rid of white space at the end of name which could contain white space. Not used
anymore as str.strip() functions well. But, as it was done already, we let it here.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>stream_str</strong> &#8211; the name of the string</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the same name without white space.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.load_xml">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">load_xml</code><span class="sig-paren">(</span><em>xml_file</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.load_xml" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function used by openxml_file and opengml_file to load an xml file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xml_file</strong> &#8211; the name of an xml file (string)</li>
<li><strong>path</strong> &#8211; the path where the xml file is (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the loaded data from the XML file in the form of the root of the xml file.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.main">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.main" title="Permalink to this definition">¶</a></dt>
<dd><p>This is not the main() of HABBY. This function is used to test this module independently of the rest of HABBY.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.open_geofile">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">open_geofile</code><span class="sig-paren">(</span><em>geo_file</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.open_geofile" title="Permalink to this definition">¶</a></dt>
<dd><p>This function opens the geometry file (.g0X) from Hecr-rad. It extracts the (x,z) from each profile
and the (x,y) if georeferenced,</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geo_file</strong> &#8211; the name of the Hec-Ras geometry file (string)</li>
<li><strong>path</strong> &#8211; the path to the geo file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list with each river profile (each profile is represented by a numpy array with the x and the altitude
of each point in the profile), the coordinate of the profile (list of np.array),
the coordinate of the river and the name of the reaches/ river in the file order (list of string)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>The geofile is a text file with contains the geographical information. Because it is written to be read by human,
it is complicated to load and regular expression are needed. It is written profile by profile.</p>
<p>Generally, to give a position, hec-ras indicates the profile number and the distance along this profile. In addition,
data can be georeferenced or not. If it is geo-referenced we have some data in an (x,y) form. Otherwise, we only
have geometrical data in the form (profile, dist).</p>
<p>First, for each profile, we get the elevation of the points forming each profile in the form (dist, elevation).
The list of elevation for each profile starts with the keyword “Sta/Elev”. The data found in the text file is in a
string format. We use the function pass_in_float_from_geo to pass it in float. It is usually done using the function
float. However, there are cases where there are no space between two number. However, in this case, the number of
character per number is constant. In this case, we separate the number first.</p>
<p>Then, we get the coordinate of the river. If no coordinate are available the river is assumed to be straight. Next,
we get the bank limit (even if we do not really used afterwards), and the name of the reach. It is also important
to save the order in which the names of the reach are given. Indeed, we want this order to be the same in all
functions, but they can be different between the geo file and the data output.</p>
<p>Next, we want to get the position (x,y) of each profile. If it is georeferenced, we will be able to get this
position directly from the file and put it in the data_dist_str variable. We will then pass it to float. If not,
we will use the function coord_profil_non_georeferenced to estimate the position of the profile (see below).</p>
<p>If the profile is not georeferenced, it is important to have the distance between two profile, so we extract the
information from the geo file in all cases (georeferenced or not). The last profile of a reach does not have a
distance to the next (not existing) profile. However, if a profile does not have a distance to the next profile
and is not the last profile, we ignore this profile. It is usually not a problem because this profile is usually
not a “real” profile, but the representation of a bridge or a culvert.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.open_hec_hec_ras_and_create_grid">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">open_hec_hec_ras_and_create_grid</code><span class="sig-paren">(</span><em>name_hdf5</em>, <em>path_hdf5</em>, <em>name_prj</em>, <em>path_prj</em>, <em>model_type</em>, <em>namefile</em>, <em>pathfile</em>, <em>interpo_choice</em>, <em>path_im</em>, <em>save_fig1d</em>, <em>pro_add=1</em>, <em>q=[]</em>, <em>print_cmd=False</em>, <em>fig_opt=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.open_hec_hec_ras_and_create_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>This function open the hec_ras data and creates the 2D grid from the 1.5 data. It is called by the class HEC_RAS1D
in a second thread to not freeze the GUI.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name_hdf5</strong> &#8211; the name of the hdf5 to be created (string)</li>
<li><strong>path_hdf5</strong> &#8211; the path to the hdf5 to be created (string)</li>
<li><strong>model_type</strong> &#8211; the name of the model (hec_ras in most case, but given as argument in case we change
the form of the name)</li>
<li><strong>name_prj</strong> &#8211; the name of the project (string)</li>
<li><strong>path_prj</strong> &#8211; the path of the project</li>
<li><strong>namefile</strong> &#8211; the name of the geo file and the data file, which contains respectively geographical data and
the ouput data (see open_hec_ras() for more precision) -&gt; list of string</li>
<li><strong>pathfile</strong> &#8211; the absolute path to the file chosen into namefile</li>
<li><strong>interpo_choice</strong> &#8211; the interpolation type (int: 0,1,2 or 3). See grid_and_interpo() for mroe details.</li>
<li><strong>path_im</strong> &#8211; the path to where to save the image</li>
<li><strong>save_fig1d</strong> &#8211; create and save the figure related to the loading of the data (profile and so on)</li>
<li><strong>pro_add</strong> &#8211; the number of addictional profile (one used for interpolation_choice 1 and 2)</li>
<li><strong>q</strong> &#8211; used in the second thread</li>
<li><strong>print_cmd</strong> &#8211; if True the print command is directed in the cmd, False if directed to the GUI</li>
<li><strong>fig_opt</strong> &#8211; the options to crete the figure if save_fig1d is True</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>** Technical comments**</p>
<p>This function redirect the sys.stdout. The point of doing this is because this function will be call by the GUI or
by the cmd. If it is called by the GUI, we want the output to be redirected to the windows for the log under HABBY.
If it is called by the cmd, we want the print function to be sent to the command line. We make the switch here.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.open_hecras">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">open_hecras</code><span class="sig-paren">(</span><em>geo_file</em>, <em>res_file</em>, <em>path_geo</em>, <em>path_res</em>, <em>path_im</em>, <em>save_fig=False</em>, <em>fig_opt=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.open_hecras" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will open HEC-RAS outputs, i.e. the .geo file and the outputs (either .XML, .sdf or .rep) from HEC-RAS.
All arguments from this function are string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geo_file</strong> &#8211; the name of .goX (example .go3) file which is an output from hec-ras containg the profile data</li>
<li><strong>res_file</strong> &#8211; the name of O0X.xml file for the name of the .sdf file  or the name of the .rep file (output data)</li>
<li><strong>path_res</strong> &#8211; path to the result file</li>
<li><strong>path_geo</strong> &#8211; path to the geo file</li>
<li><strong>path_im</strong> &#8211; the path to the folder where the images should be saved</li>
<li><strong>save_fig</strong> &#8211; if True image is saved</li>
<li><strong>fig_opt</strong> &#8211; the figure option is save_fig is True</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coord_pro (for each profile, x,y,elev, dist along the profile), vh_pro
(for each profile, dist along the profile, water height, velocity). Both variable are a list of numpy array.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>How to obtain the input files</strong></p>
<p>To obtain the xml file in HEC-RAS version 4:</p>
<ul class="simple">
<li>open the project in HEC-RAS.</li>
<li>click on File , then export geometry and result (RAS Mapper), then OK</li>
</ul>
<p>To obtain the sdf file in HEC-RAS version 5 which should be used if the model is georeferenced:</p>
<ul class="simple">
<li>click on File, then Export GIS data</li>
<li>Export all reaches (select Reaches to export -. Full List -&gt; Ok)</li>
<li>Export all needed profile (select Profile to export -&gt; Select all -&gt; ok)</li>
</ul>
<p>To obtain the report file .rep in HEC-RAS version which should be used if the model is NOT geo-referenced</p>
<ul class="simple">
<li>click on File, generate report</li>
<li>Select Flow data and Geometry data in input data and, in Specific Table, select Flow distribution and
Cross section Table</li>
</ul>
<p><strong>Technical comments</strong></p>
<p>This is function which loads the hec_ras inputs in 1D for the version 4 and 5 of HEC-RAS. It accepts different type
of hec-ras output as input and calls the appropriate sub-function for each input file.  The geometrical data is
always given in the geo file (with the extension g01, G01, g02, G02, g03, etc.). The output data can be in an xml
file for the hec-ras in the version 4, an sdf file for hec-ras in version 5 or a .rep file in the version 5 if the
model is not georeferenced. The xml file is the format which has been tested the most.</p>
<p>First, it loads the geometrical data. Then it select the function to load the output data and loads it. Then, it
transforms the loaded data in a (x,y) coordinates system. Indeed, most of the data in hec-ras is given by indicating
a profile (which crossed the modelled river) and the distance along this profile. For HABBY, it is better to get
(x,y) coordinates. Then it create figure if asked by the switch “save_fig”. Finally, it updates the forms of the
output to be coherent with the dist_velocity_hecras function.  This way, in HABBY, the output from mascaret and
rubar after the velocity distribution have the same form than the output from hec-ras, which is useful afterwards
to save all these data in the hdf5 file.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.open_repfile">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">open_repfile</code><span class="sig-paren">(</span><em>report_file</em>, <em>reach_name</em>, <em>path</em>, <em>data_profile</em>, <em>data_bank</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.open_repfile" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to open the report file (.rep) from HEC-RAS. To obtain the report file, see the doc of the function
open_hecras.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>report_file</strong> &#8211; a string with the name of the report file (.rep)</li>
<li><strong>reach_name</strong> &#8211; a list of string containing the name of the reaches/rivers in the order of the geo file,
which might not be the order of the sdf file.</li>
<li><strong>path</strong> &#8211; the path where the report file is stored (string)</li>
<li><strong>data_profile</strong> &#8211; the data from each profile from the geofile (output from the open_geofile function)</li>
<li><strong>data_bank</strong> &#8211; the position of the bank limit (output from the open_geofile function)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">velocity and the water surface elevation for each river profiles in a list of np.array,
the number of simulation (int) and the name of the river profile (list of string)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments and walk-through</strong></p>
<p>This function is used to open output from models which were not geo-referenced in hec-ras v5. It cannot be used if
the model was georeferenced (or at least one should make some tests before).</p>
<p>First, we obtain the water height. Then, we obtain the number of time step (which is called the number of
simulation by hec-ras). To get the number of time step, we count each outputs given (one by profiles) and we
divided it by the number of profile in the river. It is a bit indirect, but I did not find a simpler solution.</p>
<p>We get the name of each profile and reach. Then, we get the velocity data. We have in a case which is not
geo-referenced. By consequence, there are only three velocities: one the left bank, one in the main river channel
and one the right bank.  Next we get the distance along the profile for these three velocities. Finally, we use
the function reoder_reach for the same reason than in open_sdffile and open_xml.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.open_sdffile">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">open_sdffile</code><span class="sig-paren">(</span><em>sdf_file</em>, <em>reach_name</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.open_sdffile" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to load .sdf file from HEC-RAS v5 used if the model is georeferenced. To find how to obtain the
sdf file, read the doc of open_hecras.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sdf_file</strong> &#8211; the name of the sdf file (string)</li>
<li><strong>reach_name</strong> &#8211; a list of string containing the name of the reaches/rivers in the order of the geo file
which might not be the one of the sdf file. Output from open_geofile.</li>
<li><strong>path</strong> &#8211; the path where the file is stored (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">velocity, water height, river_name, number of  time step (nb_sim)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>To strat loading the sdf file, we open the sdf file. It is mostly a text file. Then we find velocity data and we
pass this velocity data from string to float. The process is a bit similar to the one used in the function
open_geofile with a healthy dose of regular expressions. We do this again for height data.</p>
<p>We also extract the name of the river, reaches and profile. The number of simulation (nb_sim) is a bit confusing
for a variable name. In fact, it is the number of time step. Hec-Ras considers that one simulation is the simulation
for one time step. Hence, nb_sim is more or less nb_timestep.</p>
<p>As in the xml file, we finally re-order the data as in the geo file. Indeed, it is possible to have different order
between the reaches in the geo file and in the sdf file. Here, we use the function reorder_reach for this.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.open_xmlfile">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">open_xmlfile</code><span class="sig-paren">(</span><em>xml_file</em>, <em>reach_name</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.open_xmlfile" title="Permalink to this definition">¶</a></dt>
<dd><p>This function open the xml file from HEC-RAS v4 to get the velocity and water surface elevation. To know how to
obtain this xml file, read the doc of open_hecras.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xml_file</strong> &#8211; the name of O0X.xml file from HEC-RAS. (string)</li>
<li><strong>reach_name</strong> &#8211; a list of string containing the name of the reaches/rivers in the order of the geo file
which might not be the one of the xml file.</li>
<li><strong>path</strong> &#8211; path to the xml file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">velocity and the water surface elevation for each river profiles (list of np.array),
the number of simulation(int) and the name of the river profile (list of string)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>To load the xml file, we first call the load_xml function. It is a function which check that the xml file is well
formed and which return the “root” part fo the xml. With this “root”, it is possible to load other part of the xml
file using the Etree module.</p>
<p>Then, we load the velocity and water height data from the xml file. We also load the name of the profiles and of
the reach names.  Next, we pass the data into float. For each velocity of height point, we get its position along
the profile (see below for format) and the value at this point.</p>
<p>Finally, we re-order the data as in the geo file. Indeed, it is possible to have different order between the reaches
in the geo file and in the xml file. The last part of this function is there to order all the data as in the geo
file. There is a function reorder_reach which does something similar, but could not be used by the output from the
xml file (it is slighty different). However the reorder_reach function and this part of the open_xml function is
very similar.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.pass_in_float_from_geo">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">pass_in_float_from_geo</code><span class="sig-paren">(</span><em>data_str</em>, <em>len_number</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.pass_in_float_from_geo" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to pass the string data into float for open_geofile() and open_sdffile(). It is in a function
because it is possible that two number are not separated by a space in the input data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_str</strong> &#8211; the data in a string form</li>
<li><strong>len_number</strong> &#8211; the number of digit for one number (int)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a np.array of float with 2 columns  (x,y) or (x,z)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.reorder_reach">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">reorder_reach</code><span class="sig-paren">(</span><em>wse</em>, <em>vel</em>, <em>riv_name</em>, <em>reach_name</em>, <em>reach_str</em>, <em>stream_str</em>, <em>nb_sim</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.reorder_reach" title="Permalink to this definition">¶</a></dt>
<dd><p>The order of the reach in HABBY is in the order given in the geo file. However, it can be given in any order
in the other file. (xml, sdf, rep,...). This function re-order the reaches based on their name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>wse</strong> &#8211; water height data (list of np.array for each profile)</li>
<li><strong>vel</strong> &#8211; velocity data (list of np.array for each profile)</li>
<li><strong>riv_name</strong> &#8211; the name of the profile (yeah I know it is not really logical as a name)</li>
<li><strong>reach_name</strong> &#8211; the name of the reach and stream (stream,reach) in the geo file order</li>
<li><strong>reach_str</strong> &#8211; the name of the reach in the anaylsed file order</li>
<li><strong>stream_str</strong> &#8211; the name of the stream in the anaylsed file order</li>
<li><strong>nb_sim</strong> &#8211; the number of simulation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">wse, vel, riv_name all re-ordered</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>The reach name should not have white space at the end/start but can have white space into them.</p>
</dd></dl>

<dl class="function">
<dt id="src.Hec_ras06.update_output">
<code class="descclassname">src.Hec_ras06.</code><code class="descname">update_output</code><span class="sig-paren">(</span><em>zone_v</em>, <em>coord_pro_old</em>, <em>data_profile</em>, <em>xy_h</em>, <em>nb_pro_reach_old</em><span class="sig-paren">)</span><a class="headerlink" href="#src.Hec_ras06.update_output" title="Permalink to this definition">¶</a></dt>
<dd><p>This function updates the form of the output so it is coherent with mascaret and rubar after the lateral
distribution of velocity for these two models. There are three important changes. First, coord_pro contains dist along
the profile (x) and height in addition to the coordinates. Secondly, vh_pro contains only height if height is above
or equal to zero. Thirdly, a point is created at the water limits and v and height are given at the same points.
nb_pro_reach is also modified as in mascaret. We want to modify it so it start by zero and is additive, i.e., that
it gives total number of profile before, not the number of profile by reach.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>zone_v</strong> &#8211; (x,y, dist along profile, v) for each time step. However, the zone are the one from the models.
They are different than the one from xy_h, which is unpractical for the rest of HABBY.</li>
<li><strong>coord_pro_old</strong> &#8211; the (x,y) coordinate for the profile</li>
<li><strong>data_profile</strong> &#8211; the distance along the porfile and height of each profile</li>
<li><strong>xy_h</strong> &#8211; the water height</li>
<li><strong>nb_pro_reach_old</strong> &#8211; the number of the profile by reach in the old form.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coord_pro, vh_pro, nb_pro_reach</p>
</td>
</tr>
</tbody>
</table>
<p>[doc to be finished]</p>
</dd></dl>

<div class="section" id="notes-on-hec-ras-outputs">
<h3>Notes on hec-ras outputs<a class="headerlink" href="#notes-on-hec-ras-outputs" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Data in HEC-RAS can be geo-referenced or not georeferenced. It is advised to geo-reference
all model in HEC-RAS. If the model is not geo-referenced, the function makes some assumptions to
load the data: 1) the river profile are straight and perpendicular to the river.
2) the last profile is at the end of the river.</li>
<li>To geo-reference a model in hec_ras: In the “geometric data” window, GIS tool, GIS Cut Line, Accept Display location, choose all profile</li>
<li>Numerical data are sometime not separated (0.4556 0.3453233.454 05.343). In this case, the number of digit is assumed to be 8 for the profile and 16 for the river coordinates.</li>
<li>Part of the profile can be vertical: The function also functions in this case.</li>
<li>There is sometimes more than one reach in the modelled river and these reaches sometimes form loops: The function load each reach one after the other.</li>
<li>The river reaches are sometimes not in the same order in the xml file and in the .goX file. The order of the .goX is used by the function. Reach are automatically re-ordered.</li>
<li>If the river is straight, the coordinates of the river are given differently. The function try to load the river in the “straight” style if the usual style fail.</li>
<li>The .goX file includes data on bridges and culvert. Currently, the function neglects this information.</li>
<li>Sometimes distances between profiles are not given in the .goX file. The function neglects the distance data of this profile as long as it is not the last profile.</li>
<li>The velocity data for the end and the beginning of the river profile is indicated by a large number (example 1.23e35 or -1.234e36). The function considers that velocity info is situated at the start of the profile if x&gt;-1e30 and at the end of the profile if x&gt; 1e30.</li>
<li>There are two concepts called “profile” in HEC-RAS: The river profiles and the simulation profiles. The river profiles are the geometry perpendicular to the river and the simulation profile are the different simulations.</li>
<li>Data in many of the example cases of HEC-RAS are in foot and miles. 1 miles = 5280 foot, and not 1000 foot.</li>
</ul>
</div>
</div>
<div class="section" id="hec-ras-model-2d">
<h2>Hec-ras model 2D<a class="headerlink" href="#hec-ras-model-2d" title="Permalink to this headline">¶</a></h2>
<p>in src/Hec_ras2D.py</p>
<p>This module contains the functions used to load the outputs from the hec-ras model in 2D.</p>
<span class="target" id="module-src.hec_ras2D"></span><dl class="function">
<dt id="src.hec_ras2D.figure_hec_ras2d">
<code class="descclassname">src.hec_ras2D.</code><code class="descname">figure_hec_ras2d</code><span class="sig-paren">(</span><em>v_all, h_all, elev_all, coord_p_all, coord_c_all, ikle_all, path_im, time_step=[0], flow_area=[0], max_point=-99</em><span class="sig-paren">)</span><a class="headerlink" href="#src.hec_ras2D.figure_hec_ras2d" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to plot figure of the output from hec-ras 2D. This function is only used to debug, not directly by HABBY.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>v_all</strong> &#8211; a list of np array representing the velocity at the center of the cells</li>
<li><strong>h_all</strong> &#8211; a list of np array representing the water depth at the center of the cells</li>
<li><strong>elev_all</strong> &#8211; a list of np array representing the mimium elevation of each cells</li>
<li><strong>coord_p_all</strong> &#8211; a list of np array representing the coordinates of the points of the grid</li>
<li><strong>coord_c_all</strong> &#8211; a list of np array representing the coordinates of the centers of the grid</li>
<li><strong>ikle_all</strong> &#8211; a list of np array representing the connectivity table
one array by flow area</li>
<li><strong>time_step</strong> &#8211; which time_step should be plotted (default, the first one)</li>
<li><strong>flow_area</strong> &#8211; which flow_area should be plotted (default, the first one)</li>
<li><strong>max_point</strong> &#8211; the number of cell to be drawn when reconstructing the grid (it might long)</li>
<li><strong>path_im</strong> &#8211; the path where the figure should be saved</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comment</strong></p>
<p>This function creates three figures which represent: a) the grid of the loaded models b) the water height and
c) the velocity.</p>
<p>The two last figures will be modified when the data will be loaded by node and not by cells. So we will not explai
n them here as they should be re-written.</p>
<p>The first figure is used to plot the gird. If we would plot the grid by drawing one side of each triangle
separately, it would be very long to draw. To optimize the process, we use the prepare_grid function.</p>
</dd></dl>

<dl class="function">
<dt id="src.hec_ras2D.get_triangular_grid_hecras">
<code class="descclassname">src.hec_ras2D.</code><code class="descname">get_triangular_grid_hecras</code><span class="sig-paren">(</span><em>ikle_all</em>, <em>coord_c_all</em>, <em>point_all</em>, <em>h</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#src.hec_ras2D.get_triangular_grid_hecras" title="Permalink to this definition">¶</a></dt>
<dd><p>In Hec-ras, it is possible to have non-triangular cells, often rectangular cells This function transform the
&#8220;mixed&#8221; grid to a triangular grid. For this,
it uses the centroid of each cell with more than three side and it create a triangle by side (linked with the
center of the cell). A similar function exists in rubar.py, but, as there are only one reach in rubar
and because ikle is different in hec-ras, it was hard to marge both functions together.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ikle_all</strong> &#8211; the connectivity table by reach (list of np.array)</li>
<li><strong>coord_c_all</strong> &#8211; the coordinate of the centroid of the cell by reach</li>
<li><strong>point_all</strong> &#8211; the points of the grid</li>
<li><strong>h</strong> &#8211; data on water height by reach by time step</li>
<li><strong>v</strong> &#8211; data on velocity by reach by time step</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the updated ikle, coord_c (the center of the cell , must be updated ) and xy (the grid coordinate)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.hec_ras2D.load_hec_ras2d">
<code class="descclassname">src.hec_ras2D.</code><code class="descname">load_hec_ras2d</code><span class="sig-paren">(</span><em>filename</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.hec_ras2D.load_hec_ras2d" title="Permalink to this definition">¶</a></dt>
<dd><p>The goal of this function is to load 2D data from Hec-RAS in the version 5.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> &#8211; the name of the file containg the results of HEC-RAS in 2D. (string)</li>
<li><strong>path</strong> &#8211; the path where the file is (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">velocity and height at the center of the cells, the coordinate of the point of the cells,
the coordinates of the center of the cells and the connectivity table. Each output is a list of numpy array
(one array by 2D flow area)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>How to obtain the input file</strong></p>
<p>The file neede as input is an hdf5 file (.hdf) created automatically by Hec-Ras. There are many .hdf created by
Hec-Ras. The one to choose is the one with the extension p0X.hdf (not g0x.hdf). It is usually the largest file in
the results folder.</p>
<p><strong>Technical comments</strong></p>
<p>Outputs from HEC-RAS in 2D are in the hdf5 format. However, it is not possible to directly use the output of HEC-RAS
as an hdf5 input for HABBY. Indeed, even if they are both in hdf5, the formats of the hdf5 files are different
(and would miss some important info for HABBY).  So we still need to load the HEC-RAS data in HABBY even if in 2D.</p>
<p>This function call the function get_trianglar grid which is in rubar.py.</p>
<p><strong>Walk-through</strong></p>
<p>The name and path of the file is given as input to the load_hec_ras_2D function. Usually this is done by the class
HEC_RAS() in the GUI.  We load the file using the h5py module. This module opens and reads hdf5 file.</p>
<p>Then we can read different part of the hdf5 file when we know the address of it (this is a bit like a file system).
In hdf5 file of Hec-RAS, this first thing is to get the names of the flow area in “Geometry/2D Flow Area”. In
general, this is the name of each reach, but it could be lake or pond also. In an hdf5 file, to see the name of
the member in a group, use: list(&#8220;group&#8221;.keys())</p>
<p>Then, we go to “Geometry/2D Flow Area/&lt;name&gt;/FacePoint Coordinates” to get the points forming the grid.
We can also get the connectivity table (or ikle) to the path “Geometry/2D Flow Area/&lt;name&gt;/Cells Face Point Indexes”
We also get the elevations of the cells. However, this is just the minimum elevation of the cells, so it is
to be used only for a quick estimation. We then get the water depth by cell.
The velocity is given by face of the cells and is averaged to get it on the middle of the cells.</p>
<p>To get Hec-Ras data by nodes, it is necessary to intepolate the data. There is a function to do this in
manage_grid_8.</p>
</dd></dl>

<dl class="function">
<dt id="src.hec_ras2D.load_hec_ras_2d_and_cut_grid">
<code class="descclassname">src.hec_ras2D.</code><code class="descname">load_hec_ras_2d_and_cut_grid</code><span class="sig-paren">(</span><em>name_hdf5</em>, <em>filename</em>, <em>path</em>, <em>name_prj</em>, <em>path_prj</em>, <em>model_type</em>, <em>nb_dim</em>, <em>path_hdf5</em>, <em>q=[]</em>, <em>print_cmd=False</em>, <em>fig_opt={}</em><span class="sig-paren">)</span><a class="headerlink" href="#src.hec_ras2D.load_hec_ras_2d_and_cut_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls load_hec_ras_2d and the cut_2d_grid function. Hence, it loads the data,
pass it from cell to node (as data output in hec-ras is by cells) and it cut the grid to
get only the wetted area. This was done before in the HEC_RAS2D Class in hydro_gui_2.py, but it was necessary to
create a separate function to called this task in a second thread to avoid freezing the GUI.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name_hdf5</strong> &#8211; the base name of the created hdf5 (string)</li>
<li><strong>filename</strong> &#8211; the name of the file containg the results of HEC-RAS in 2D. (string)</li>
<li><strong>path</strong> &#8211; the path where the file is (string)</li>
<li><strong>name_prj</strong> &#8211; the name of the project (string)</li>
<li><strong>path_prj</strong> &#8211; the path of the project</li>
<li><strong>model_type</strong> &#8211; the name of the model such as Rubar, hec-ras, etc. (string)</li>
<li><strong>nb_dim</strong> &#8211; the number of dimension (model, 1D, 1,5D, 2D) in a float</li>
<li><strong>path_hdf5</strong> &#8211; A string which gives the adress to the folder in which to save the hdf5</li>
<li><strong>q</strong> &#8211; used by the second thread to get the error back to the GUI at the end of the thread</li>
<li><strong>print_cmd</strong> &#8211; If True will print the error and warning to the cmd. If False, send it to the GUI.</li>
<li><strong>fig_opt</strong> &#8211; the figure option, used here to get the minimum water height to have a wet node (can be &gt; 0)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>** Technical comments**</p>
<p>This function redirect the sys.stdout. The point of doing this is because this function will be call by the GUI or
by the cmd. If it is called by the GUI, we want the output to be redirected to the windoows for the log under HABBY.
If it is called by the cmd, we want the print function to be sent to the command line.</p>
</dd></dl>

<dl class="function">
<dt id="src.hec_ras2D.main">
<code class="descclassname">src.hec_ras2D.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.hec_ras2D.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module independantly of HABBY.</p>
</dd></dl>

<dl class="function">
<dt id="src.hec_ras2D.prepare_grid">
<code class="descclassname">src.hec_ras2D.</code><code class="descname">prepare_grid</code><span class="sig-paren">(</span><em>ikle</em>, <em>coord_p</em>, <em>max_point=-99</em><span class="sig-paren">)</span><a class="headerlink" href="#src.hec_ras2D.prepare_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to put in the new form the data forming the grid to accelerate the plotting of the grid. This function creates
a list of points of the grid which are re-ordered compared to the usual list of grid point (the variable coord_p
here). These points are reordered so that it is possible to draw only one line to form the grid (one point can
appears more than once). The grid is drawn as one long line and not as a succession of small lines, which is
quicker. When this new list is created by prepare_function(), it is send back to figure-hec_ras_2D and plotted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ikle</strong> &#8211; the connectivity table</li>
<li><strong>coord_p</strong> &#8211; the coordinates of the point</li>
<li><strong>max_point</strong> &#8211; if the grid is very big, it is possible to only plot the first points, up to max_points (int)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list of x and y coordinates ordered.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.hec_ras2D.scatter_plot">
<code class="descclassname">src.hec_ras2D.</code><code class="descname">scatter_plot</code><span class="sig-paren">(</span><em>coord</em>, <em>data</em>, <em>data_name</em>, <em>my_cmap</em>, <em>s1</em>, <em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#src.hec_ras2D.scatter_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to plot the scatter of the data. Will not be used in the final version, but can be useful to
plot data by cells.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coord</strong> &#8211; the coordinates of the point</li>
<li><strong>data</strong> &#8211; the data to be plotted (np.array)</li>
<li><strong>data_name</strong> &#8211; the name of the data (string)</li>
<li><strong>my_cmap</strong> &#8211; the color map (string with matplotlib colormap name)</li>
<li><strong>s1</strong> &#8211; the size of the dot for the scatter</li>
<li><strong>t</strong> &#8211; the time step being plotted</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="mascaret">
<h2>Mascaret<a class="headerlink" href="#mascaret" title="Permalink to this headline">¶</a></h2>
<p>in src/mascaret.py</p>
<p>This module contains the functions used to load the outputs from the mascaret model.</p>
<span class="target" id="module-src.mascaret"></span><dl class="function">
<dt id="src.mascaret.correct_duplicate">
<code class="descclassname">src.mascaret.</code><code class="descname">correct_duplicate</code><span class="sig-paren">(</span><em>seq</em>, <em>send_warn</em>, <em>idfun=None</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.correct_duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>It is possible to have a vertical line on a profile (different h, identical x). This is not possible for HABBY and
the 2D grid. So this function correct duplicates along the profile.</p>
<p>A similiar function exists in rubar, for the case where input is (x,y) coordinates and not distance along the profile.
This function is inspired by <a class="reference external" href="https://www.peterbe.com/plog/uniqifiers-benchmark">https://www.peterbe.com/plog/uniqifiers-benchmark</a></p>
<p>It should be tested more as manage_grid sometime still send warning about duplicate data in profile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>seq</strong> &#8211; the list to be corrected (list)</li>
<li><strong>send_warn</strong> &#8211; a bool to avoid printing certains warning too many time</li>
<li><strong>idfun</strong> &#8211; support an optional transform function (not used)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the profile data without duplicate and the bollean which manages the warning.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.define_stream_network">
<code class="descclassname">src.mascaret.</code><code class="descname">define_stream_network</code><span class="sig-paren">(</span><em>node_number</em>, <em>start_node</em>, <em>end_node</em>, <em>angles</em>, <em>nb_pro_reach</em>, <em>nb_reach</em>, <em>abcisse</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.define_stream_network" title="Permalink to this definition">¶</a></dt>
<dd><p>This function extracts the stream network from the node and angle data. This is used if we have more than one
reach to define the geometry of the junction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>node_number</strong> &#8211; the start/end number of the reaches for each nodes (list of list)</li>
<li><strong>start_node</strong> &#8211; the numbers indicating the start of each reach (list)</li>
<li><strong>end_node</strong> &#8211; the numbers indicating the end of each reach</li>
<li><strong>angles</strong> &#8211; for each node the angle between the reach</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach</li>
<li><strong>nb_reach</strong> &#8211; the number of reach</li>
<li><strong>abcisse</strong> &#8211; the distance along the river of each reach</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the river coordinates and the unit vector indicating the river direction</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.figure_mascaret">
<code class="descclassname">src.mascaret.</code><code class="descname">figure_mascaret</code><span class="sig-paren">(</span><em>coord_pro, coord_r, xhzv_data, on_profile, nb_pro_reach, fig_opt, name_pro, name_reach, path_im, pro, plot_timestep=[-1], reach_plot=[0]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.figure_mascaret" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to plot the figures related to mascaret.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coord_pro</strong> &#8211; the cordinates (x,y,h, dist along the river) of the profiles</li>
<li><strong>coord_r</strong> &#8211; the coordinate (x,y) of the river</li>
<li><strong>name_pro</strong> &#8211; the name of the profile</li>
<li><strong>name_reach</strong> &#8211; the name of the reach</li>
<li><strong>on_profile</strong> &#8211; which result are on the profile. Some output are not the profiles.</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach (careful this is the number of profile, not the number of output)</li>
<li><strong>fig_opt</strong> &#8211; the figure option</li>
<li><strong>xhzv_data</strong> &#8211; the height and velcoity (x,h,v) list by time step</li>
<li><strong>profile</strong> (<em>pro</em>) &#8211; which profile to be plotted (list of int)</li>
<li><strong>plot_timestep</strong> &#8211; which timestep to be plotted</li>
<li><strong>reach_plot</strong> &#8211; the reach to be plotted for the river view</li>
<li><strong>path_im</strong> &#8211; the path where to save the figure</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.find_node">
<code class="descclassname">src.mascaret.</code><code class="descname">find_node</code><span class="sig-paren">(</span><em>node_number</em>, <em>reach_to_find</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.find_node" title="Permalink to this definition">¶</a></dt>
<dd><p>This function finds which node is a stream end or a stream start. It is associated by the function
define_stream_network()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>node_number</strong> &#8211; the list of list of the reaches linked with one node</li>
<li><strong>reach_to_find</strong> &#8211; the number indicating the start or end of the reach</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the node number, ordered as in the xcas file</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.flat_coord_pro">
<code class="descclassname">src.mascaret.</code><code class="descname">flat_coord_pro</code><span class="sig-paren">(</span><em>coord_pro</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.flat_coord_pro" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is not used anymroe.</p>
<p>The variable coord_pro was a list of profile by reach. Finally, it was useful to have each profile one after the
other with accounting for the reach. So we stop to use this function whose goal was to pass from one form of
coord_pro to the other form 9with or wihtout reach information).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coord_pro</strong> &#8211; the list of profile (x,y,h, dist along the river) by reach</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">coord_pro_f: a list of profile without the reach information. The list is flatten</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.get_geo_name_from_xcas">
<code class="descclassname">src.mascaret.</code><code class="descname">get_geo_name_from_xcas</code><span class="sig-paren">(</span><em>file_gen</em>, <em>path_gen</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.get_geo_name_from_xcas" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets the name of the .geo file from the .xcas xml file. It is not used yet, but it could be useful
in the GUI to simplify the loading of mascaret. The user would not need to give the name of the geo and the xcas
files separetly. However, it is not written in yet.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_gen</strong> &#8211; the xcas file</li>
<li><strong>path_gen</strong> &#8211; the path to the xcas file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the name of the .geo file (no path indicated)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.get_name_from_cas">
<code class="descclassname">src.mascaret.</code><code class="descname">get_name_from_cas</code><span class="sig-paren">(</span><em>file_gen</em>, <em>path_gen</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.get_name_from_cas" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets the name of the .geo file from the .cas text file. It is not used yet, but it could be useful
in the GUI to simplify the loading of mascaret. The user would not need to give the name of the geo and the cas
files separetly. However, it is not written in yet.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_gen</strong> &#8211; the name of .cas file (string)</li>
<li><strong>path_gen</strong> &#8211; the path to the cas file (string</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the name of the .geo file (no path indicated)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.is_this_res_on_the_profile">
<code class="descclassname">src.mascaret.</code><code class="descname">is_this_res_on_the_profile</code><span class="sig-paren">(</span><em>abscisse</em>, <em>xhzv_data_all</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.is_this_res_on_the_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>The output of mascaret can be given at points of the river where there is no profile.
The function here says which results are on the profiles. All profiles are linked with an output, but some output
are not linked with a profile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>abscisse</strong> &#8211; the distance between each profile (list of float)</li>
<li><strong>xhzv_data_all</strong> &#8211; the outputs from mascaret by time step</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list of bool of the length of xhzv_data, True on profile, False not on profile</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comment</strong></p>
<p>In the mascaret outputs, some rounding are suprising. For example, 0.49 can be transformed to 0.50 in an otehr file
(not 0.5). To avoid this type of problem, we says that outputs with a distance smaller than 3cm of the profile are
on the profile. If there are more than one output by profile, we takes the output which is the closest to the
profile.</p>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.load_mascaret">
<code class="descclassname">src.mascaret.</code><code class="descname">load_mascaret</code><span class="sig-paren">(</span><em>file_gen</em>, <em>file_geo</em>, <em>file_res</em>, <em>path_gen</em>, <em>path_geo</em>, <em>path_res</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.load_mascaret" title="Permalink to this definition">¶</a></dt>
<dd><p>The function is used to load the mascaret data. It load the geofile and the general file. Then, it re-forms the
geometrical data. Next, it loads the output data from mascaret. Fianally, it looks which outputs is close to
a profile and which outputs is not linked with a profile as there are some outputs given between profiles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_gen</strong> &#8211; the xcas .xml file giving general info about the model (string)</li>
<li><strong>file_geo</strong> &#8211; the file containting the profile data (.geo) (string)</li>
<li><strong>file_res</strong> &#8211; the files containting the mascaret output in the Optyca format (.opt) (string)</li>
<li><strong>path_gen</strong> &#8211; the path to the xcas file or .cas file (string). By default, choose the xcas file.</li>
<li><strong>path_geo</strong> &#8211; the path to the geo file (string)</li>
<li><strong>path_res</strong> &#8211; the path to the res file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the coordinates of the profile (x,y,z, dist along the profile), the coordinate of the river (x,y), name of
reach and profile, data height and velocity (list by time step), list of bollean indicating which data is
on the profile and the number of profile by reach.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.load_mascaret_and_create_grid">
<code class="descclassname">src.mascaret.</code><code class="descname">load_mascaret_and_create_grid</code><span class="sig-paren">(</span><em>name_hdf5</em>, <em>path_hdf5</em>, <em>name_prj</em>, <em>path_prj</em>, <em>model_type</em>, <em>namefile</em>, <em>pathfile</em>, <em>interpo_choice</em>, <em>manning_data</em>, <em>nb_point_vel</em>, <em>show_fig_1D</em>, <em>pro_add</em>, <em>q=[]</em>, <em>path_im='.'</em>, <em>print_cmd=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.load_mascaret_and_create_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to load the mascaret data by calling the load_mascaret() function and to create the grid
by calling the grid_and_interpo function in manage_grid_8. This function is called in a second thread by the class
Mascaret() in Hydro_grid_2(). It also distribute the velocity by calling dist_vitess2.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name_hdf5</strong> &#8211; the name of the hdf5 to be created (string)</li>
<li><strong>path_hdf5</strong> &#8211; the path to the hdf5 to be created (string)</li>
<li><strong>model_type</strong> &#8211; the name of the model (mascaret in most case, but given as argument in case we change
the form of the name)</li>
<li><strong>name_prj</strong> &#8211; the name of the project (string)</li>
<li><strong>path_prj</strong> &#8211; the path of the project</li>
<li><strong>namefile</strong> &#8211; the name of the geo file and the data file, which contains respectively geographical data and
the ouput data (see open_hec_ras() for more precision) -&gt; list of string</li>
<li><strong>pathfile</strong> &#8211; the absolute path to the file chosen into namefile -&gt; list of string</li>
<li><strong>interpo_choice</strong> &#8211; the interpolation type (int: 0,1,2 or 3). See grid_and_interpo() for mroe details.</li>
<li><strong>manning_data</strong> &#8211; Contains the manning data. It can be in an array form (variable) or as a float (constant)</li>
<li><strong>nb_point_vel</strong> &#8211; the number of velcoity point by whole profile</li>
<li><strong>show_fig_1D</strong> &#8211; A boolean. If True, image from the 1D data are created and savec</li>
<li><strong>q</strong> &#8211; used by the second thread.</li>
<li><strong>pro_add</strong> &#8211; the number of addictional profile (one used for interpolation_choice 1 and 2)</li>
<li><strong>path_im</strong> &#8211; the path where to save the figure</li>
<li><strong>print_cmd</strong> &#8211; if True the print command is directed in the cmd, False if directed to the GUI</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>** Technical comments**</p>
<p>This function redirect the sys.stdout. The point of doing this is because this function will be call by the GUI or
by the cmd. If it is called by the GUI, we want the output to be redirected to the windows for the log under HABBY.
If it is called by the cmd, we want the print function to be sent to the command line. We make the switch here.</p>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.main">
<code class="descclassname">src.mascaret.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module separately.</p>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.open_geo_mascaret">
<code class="descclassname">src.mascaret.</code><code class="descname">open_geo_mascaret</code><span class="sig-paren">(</span><em>file_geo</em>, <em>path_geo</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.open_geo_mascaret" title="Permalink to this definition">¶</a></dt>
<dd><p>This function load the mascaret geo file. Generally, the profile are not geo-referenced when using this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_geo</strong> &#8211; the name of the geo file (string)</li>
<li><strong>path_geo</strong> &#8211; the path to the geo file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the profile data (x,y), profile name (list of string),
brief name (list of string), the number of profile in each reach and distance along the river/abcisse (list)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.open_res_file">
<code class="descclassname">src.mascaret.</code><code class="descname">open_res_file</code><span class="sig-paren">(</span><em>file_res</em>, <em>path_res</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.open_res_file" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to load the output from mascaret (.opt file). The format is Optyca.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_res</strong> &#8211; the name of the .opt file (string)</li>
<li><strong>path_res</strong> &#8211; the path to this file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.open_rub_file">
<code class="descclassname">src.mascaret.</code><code class="descname">open_rub_file</code><span class="sig-paren">(</span><em>file_res</em>, <em>path_res</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.open_rub_file" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to open the binary output file from mascaret (.rub format).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_res</strong> &#8211; the name of the rub binary file (string)</li>
<li><strong>path_res</strong> &#8211; the path to this file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">xhzv_data, timestep</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comment</strong></p>
<p>The binary output file was done using a program written in FORTRAN. So there are often suprising
octet which are added to the binary file. Be careful before changing anything.</p>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.profil_coord_non_georef">
<code class="descclassname">src.mascaret.</code><code class="descname">profil_coord_non_georef</code><span class="sig-paren">(</span><em>coord_pro</em>, <em>coord_r</em>, <em>nr</em>, <em>nb_pro_reach</em>, <em>bt=None</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.profil_coord_non_georef" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets the coordinates (x,y) of the profile as masacret outputs are not georeferenced.</p>
<p>Hypothesis: The river and the profile are straight. The profile is perpendicular to the river.
The river pass at the minimum elevation of the river bed. If there is a distinction between the main bed the
secondary bed is given, we take the minimum elevation of the main bed</p>
<p>The origin of the coordinate system is the start of the river.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coord_pro</strong> &#8211; the coordinate of the profile. This variable is not in the general coordinate system,
just distance along the profile and bed elevation (p, dist, h)</li>
<li><strong>coord_r</strong> &#8211; the river coordinates</li>
<li><strong>n</strong> &#8211; the vector indicating the river direction</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach (additive)</li>
<li><strong>bt</strong> &#8211; optional, it indicates which points in the profiles are in the minor/major bed</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the velocity and height data, the timestep</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.river_coord_non_georef_from_cas">
<code class="descclassname">src.mascaret.</code><code class="descname">river_coord_non_georef_from_cas</code><span class="sig-paren">(</span><em>file_gen</em>, <em>path_gen</em>, <em>abcisse</em>, <em>nb_pro_reach</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.river_coord_non_georef_from_cas" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the coordinates of the river based on the cas text file. If there are only one river, this is an easy task as
the river is straight. If there are more than one reach, the junctions and the angles between the reach sould be
managed using the define_stream_network function and the information in the .cas file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_gen</strong> &#8211; the .cas file whcih contains general info (string)</li>
<li><strong>path_gen</strong> &#8211; the path to this file (string)</li>
<li><strong>abcisse</strong> &#8211; ditance along the profiles</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of reach by profile</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the river coordinate and the unit vector indicating the river direction</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mascaret.river_coord_non_georef_from_xcas">
<code class="descclassname">src.mascaret.</code><code class="descname">river_coord_non_georef_from_xcas</code><span class="sig-paren">(</span><em>file_gen</em>, <em>path_gen</em>, <em>abcisse</em>, <em>nb_pro_reach</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mascaret.river_coord_non_georef_from_xcas" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the coordinates of the river based on the xcas xml file. If there are only one river, this is an easy task as
the river is straight. If there are more than one reach, the junctions and the angles between the reach sould be
managed using the define_stream_network function and the information in the .xcas file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_gen</strong> &#8211; the .xcas file with the information concerning the reach (string)</li>
<li><strong>path_gen</strong> &#8211; the path to the xcas file (string)</li>
<li><strong>abcisse</strong> &#8211; the distance along the river</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coord_r the coordinate of the river</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="river-2d">
<h2>River 2D<a class="headerlink" href="#river-2d" title="Permalink to this headline">¶</a></h2>
<p>in src/river2D.py</p>
<p>This module contains the functions used to load the outputs from the River2D model.</p>
<span class="target" id="module-src.river2d"></span><dl class="function">
<dt id="src.river2d.figure_river2d">
<code class="descclassname">src.river2d.</code><code class="descname">figure_river2d</code><span class="sig-paren">(</span><em>xyzhv</em>, <em>ikle</em>, <em>path_im</em>, <em>t=0</em><span class="sig-paren">)</span><a class="headerlink" href="#src.river2d.figure_river2d" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to plot the output from river 2d. Need hec-ras2d as import because it re-used most of the plot from this
script. It is only used to debug. It is not used directly by HABBY.</p>
<p>Plot only one time step because river 2d output have one file by time step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xyzhv</strong> &#8211; the x,y, coordinates of the node (h,v are nodal output in river 2d), the river bed, the water height
and the velocity (one data by column, row are node)</li>
<li><strong>ikle</strong> &#8211; connectivity table</li>
<li><strong>path_im</strong> &#8211; the path where to save the figure</li>
<li><strong>t</strong> &#8211; the time step which is being plotted</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.river2d.get_rid_of_lines">
<code class="descclassname">src.river2d.</code><code class="descname">get_rid_of_lines</code><span class="sig-paren">(</span><em>datahere</em>, <em>nb_data</em><span class="sig-paren">)</span><a class="headerlink" href="#src.river2d.get_rid_of_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>There are lines which are useless in the cdg file. This function is used to correct ikle and data_node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>datahere</strong> &#8211; the data with the empty lines</li>
<li><strong>nb_data</strong> &#8211; nb_node or nb_el</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">datahere wihtout the useless lines</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.river2d.load_river2d_and_cut_grid">
<code class="descclassname">src.river2d.</code><code class="descname">load_river2d_and_cut_grid</code><span class="sig-paren">(</span><em>name_hdf5</em>, <em>namefiles</em>, <em>paths</em>, <em>name_prj</em>, <em>path_prj</em>, <em>model_type</em>, <em>nb_dim</em>, <em>path_hdf5</em>, <em>q=[]</em>, <em>print_cmd=False</em>, <em>fig_opt={}</em><span class="sig-paren">)</span><a class="headerlink" href="#src.river2d.load_river2d_and_cut_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the river2d data and cut the grid to the wet area. Originally, this function was in the class
River2D() in hydro_GUI_2. This function was added as it was practical to have a second thread to avoid freezing
the GUI.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name_hdf5</strong> &#8211; the base name of the created hdf5 (string)</li>
<li><strong>namefiles</strong> &#8211; the names of all the cdg file (list of string)</li>
<li><strong>paths</strong> &#8211; the path to the files (list of string).</li>
<li><strong>name_prj</strong> &#8211; the name of the project (string)</li>
<li><strong>path_prj</strong> &#8211; the path of the project</li>
<li><strong>model_type</strong> &#8211; the name of the model such as Rubar, hec-ras, etc. (string)</li>
<li><strong>nb_dim</strong> &#8211; the number of dimension (model, 1D, 1,5D, 2D) in a float</li>
<li><strong>path_hdf5</strong> &#8211; A string which gives the adress to the folder in which to save the hdf5</li>
<li><strong>q</strong> &#8211; used to send the error back from the second thread (can be used to send other variable too)</li>
<li><strong>print_cmd</strong> &#8211; if True the print command is directed in the cmd, False if directed to the GUI</li>
<li><strong>fig_opt</strong> &#8211; the figure option, used here to get the minimum water height to have a wet node (can be &gt; 0)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.river2d.load_river2d_cdg">
<code class="descclassname">src.river2d.</code><code class="descname">load_river2d_cdg</code><span class="sig-paren">(</span><em>file_cdg</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.river2d.load_river2d_cdg" title="Permalink to this definition">¶</a></dt>
<dd><p>The file to load the output data from River2D. Careful the input data of River2D has the same ending and nearly
the same format as the output. However, it is nessary to have the output here. River2D gives one cdg. file by timestep.
Hence, this function read only one timeste. HABBY read all time step by calling this function once for each time step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_cdg</strong> &#8211; the name of the cdg file (string)</li>
<li><strong>path</strong> &#8211; the path to this file (string).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the velocity and height data, the coordinate and the connectivity table.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.river2d.main">
<code class="descclassname">src.river2d.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.river2d.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module.</p>
</dd></dl>

</div>
<div class="section" id="rubar">
<h2>Rubar<a class="headerlink" href="#rubar" title="Permalink to this headline">¶</a></h2>
<p>in src/rubar.py</p>
<p>This module contains the functions used to load the Rubar data in 2D and 1D.</p>
<span class="target" id="module-src.rubar"></span><dl class="function">
<dt id="src.rubar.correct_duplicate_xy">
<code class="descclassname">src.rubar.</code><code class="descname">correct_duplicate_xy</code><span class="sig-paren">(</span><em>seq3D</em>, <em>send_warn</em>, <em>idfun=None</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.correct_duplicate_xy" title="Permalink to this definition">¶</a></dt>
<dd><p>It is possible to have a vertical line on a profile (different h, identical x). This is not possible for HABBY and
the 2D grid. So this function correct duplicates along the profile.</p>
<p>A similiar function exists in mascaret, for the case where the input is the distance along the profile and not
(x,y) coordinates. This function is inspired by <a class="reference external" href="https://www.peterbe.com/plog/uniqifiers-benchmark">https://www.peterbe.com/plog/uniqifiers-benchmark</a>.</p>
<p>It should be tested more as manage_grid sometime still send warning about duplicate data in profile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>seq3D</strong> &#8211; the list to be corrected in this case (x,y,z,dist along the profile)</li>
<li><strong>send_warn</strong> &#8211; a bool to avoid printing the warning too many time</li>
<li><strong>idfun</strong> &#8211; support an optional transform function (not tested)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the list wihtout duplicate and the boolean which helps manage the warnings</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.figure_rubar1d">
<code class="descclassname">src.rubar.</code><code class="descname">figure_rubar1d</code><span class="sig-paren">(</span><em>coord_pro, lim_riv, data_xhzv, name_profile, path_im, pro, plot_timestep, nb_pro_reach=[0, 10000000000], fig_opt={}</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.figure_rubar1d" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to plot the loaded RUBAR 1D data (Rubar BE).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coord_pro</strong> &#8211; the coordinate of the profile (x, y, z, dist along the river)</li>
<li><strong>lim_riv</strong> &#8211; the right bank, river center, left bank</li>
<li><strong>data_xhzv</strong> &#8211; the data by time step with x the distance along the river, h the water height and v the vlocity</li>
<li><strong>cote</strong> &#8211; the altitude of the river center</li>
<li><strong>name_profile</strong> &#8211; the name of the profile</li>
<li><strong>path_im</strong> &#8211; the path where to save the image</li>
<li><strong>pro</strong> &#8211; the profile number which should be plotted</li>
<li><strong>plot_timestep</strong> &#8211; which timestep should be plotted</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach</li>
<li><strong>fig_opt</strong> &#8211; the dictionnary with the figure option</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">none</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.figure_rubar2d">
<code class="descclassname">src.rubar.</code><code class="descname">figure_rubar2d</code><span class="sig-paren">(</span><em>xy, coord_c, ikle, v, h, path_im, time_step=[-1]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.figure_rubar2d" title="Permalink to this definition">¶</a></dt>
<dd><p>This functions plots the rubar 2d data. This function is only used to debug. It is not used direclty by Habby.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>xy</strong> &#8211; coordinates of the points</li>
<li><strong>coord_c</strong> &#8211; the center of the point</li>
<li><strong>ikle</strong> &#8211; connectivity table</li>
<li><strong>v</strong> &#8211; speed</li>
<li><strong>h</strong> &#8211; height</li>
<li><strong>path_im</strong> &#8211; the path where to save the figure</li>
<li><strong>time_step</strong> &#8211; The time step which will be plotted</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.get_triangular_grid">
<code class="descclassname">src.rubar.</code><code class="descname">get_triangular_grid</code><span class="sig-paren">(</span><em>ikle</em>, <em>coord_c</em>, <em>xy</em>, <em>h</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.get_triangular_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>In Rubar, it is possible to have non-triangular cells. It is possible to have a grid composed of a mix
of pentagonal, 4-sided and triangualr cells. This function transform the &#8220;mixed&#8221; grid to a triangular grid. For this,
it uses the centroid of each cell with more than three side and it create a triangle by side (linked with the
center of the cell). A similar function exists in hec-ras2D.py, but, as there is only one reach in rubar
and because ikle is different in hec-ras, it was hard to marge both functions together.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ikle</strong> &#8211; the connectivity table (list)</li>
<li><strong>coord_c</strong> &#8211; the coordinate of the centroid of the cell (list)</li>
<li><strong>xy</strong> &#8211; the points of the grid (np.array)</li>
<li><strong>h</strong> &#8211; data on water height</li>
<li><strong>v</strong> &#8211; data on velocity</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the updated ikle, coord_c (the center of the cell , must be updated ) and xy (the grid coordinate)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_coord_1d">
<code class="descclassname">src.rubar.</code><code class="descname">load_coord_1d</code><span class="sig-paren">(</span><em>name_rbe</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_coord_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>the function to load the rbe file, which is an xml file. The gives the geometry of the river system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name_rbe</strong> &#8211; The name fo the rbe file (string)</li>
<li><strong>path</strong> &#8211; the path to this file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the coordinates of the profiles and the coordinates of the right bank, center of the river, left bank
(list of np.array with x,y,z coordinate), name of the profile (list of string), dist along the river (list of float)
number of cells (int)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_dat_2d">
<code class="descclassname">src.rubar.</code><code class="descname">load_dat_2d</code><span class="sig-paren">(</span><em>geofile</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_dat_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>This  function is used to load the geomtery info for the 2D case, using the .dat file
The .dat file has the same role than the .mai file but with more information (number of side and more
complicated connectivity table).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geofile</strong> &#8211; the .dat file which contain the connectivity table and the (x,y)</li>
<li><strong>path</strong> &#8211; the path to this file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">connectivity table, point coordinates, coordinates of the cell centers</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_data_1d">
<code class="descclassname">src.rubar.</code><code class="descname">load_data_1d</code><span class="sig-paren">(</span><em>name_data_vh</em>, <em>path</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_data_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the output data for Rubar BE (in 1D). The geometry data should be loaded before using this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name_data_vh</strong> &#8211; the name of the profile.ETUDE file (string)</li>
<li><strong>path</strong> &#8211; the path to this file</li>
<li><strong>x</strong> &#8211; the distance along the river (from the .geo file)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">data x, velocity height, cote for each time step (list of np.array), time step</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_mai_1d">
<code class="descclassname">src.rubar.</code><code class="descname">load_mai_1d</code><span class="sig-paren">(</span><em>mailfile</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_mai_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is not used anymore. It was used to load the coordinate of the 1D data. It might become useful again
in the case where we found a Rubar model with more than one reach (which we do not have yet).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mailfile</strong> &#8211; the name of the file which contain the (x,z) data</li>
<li><strong>path</strong> &#8211; the path to this file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">x of the river, np.array and the number of mail</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_mai_2d">
<code class="descclassname">src.rubar.</code><code class="descname">load_mai_2d</code><span class="sig-paren">(</span><em>geofile</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_mai_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to load the geomtery info for the 2D case when we use the .mai file. It would also be possible
to use the .dat file. In fact, it is advised to use the dat file when possible as there are more info in the .dat file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geofile</strong> &#8211; the .mai file which contain the connectivity table and the (x,y)</li>
<li><strong>path</strong> &#8211; the path to this file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">connectivity table, point coordinates, coordinates of the cell centers</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_rubar1d">
<code class="descclassname">src.rubar.</code><code class="descname">load_rubar1d</code><span class="sig-paren">(</span><em>geofile</em>, <em>data_vh</em>, <em>pathgeo</em>, <em>pathdata</em>, <em>path_im</em>, <em>savefig</em>, <em>fig_opt=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_rubar1d" title="Permalink to this definition">¶</a></dt>
<dd><p>the function to load the RUBAR BE data (in 1D).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geofile</strong> &#8211; the name of .rbe file which gives the coordinates of each profile (string)</li>
<li><strong>data_vh</strong> &#8211; the name of the profile.ETUDE file which contains the height and velocity data (string)</li>
<li><strong>pathgeo</strong> &#8211; the path to the geofile - string</li>
<li><strong>pathdata</strong> &#8211; the path to the data_vh file</li>
<li><strong>path_im</strong> &#8211; the file where to save the image</li>
<li><strong>savefig</strong> &#8211; a boolean. If True create and save the figure.</li>
<li><strong>fig_opt</strong> &#8211; A dictionarry with the figure option</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coordinates of the profile (x,y,z dist along the profile) coordinates (x,y) of the river and the bed,
data xhzv by time step where x is the distance along the river, h the water height, z the elevation of the bed
and v the velocity</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_rubar1d_and_create_grid">
<code class="descclassname">src.rubar.</code><code class="descname">load_rubar1d_and_create_grid</code><span class="sig-paren">(</span><em>name_hdf5</em>, <em>path_hdf5</em>, <em>name_prj</em>, <em>path_prj</em>, <em>model_type</em>, <em>namefile</em>, <em>pathfile</em>, <em>interpo_choice</em>, <em>manning_data</em>, <em>nb_point_vel</em>, <em>show_fig_1D</em>, <em>pro_add</em>, <em>q=[]</em>, <em>path_im='.'</em>, <em>print_cmd=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_rubar1d_and_create_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to load rubar 1d data by calling the load_rubar1d() function and to create the grid
by calling the grid_and_interpo function in manage_grid_8. This function is called in a second thread by the class
Rubar() in Hydro_grid_2(). It also distribute the velocity by calling dist_vitess2.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name_hdf5</strong> &#8211; the name of the hdf5 to be created (string)</li>
<li><strong>path_hdf5</strong> &#8211; the path to the hdf5 to be created (string)</li>
<li><strong>name_prj</strong> &#8211; the name of the project (string)</li>
<li><strong>path_prj</strong> &#8211; the path of the project</li>
<li><strong>model_type</strong> &#8211; the name of the model (rubar in most case, but given as argument in case we change
the form of the name)</li>
<li><strong>namefile</strong> &#8211; the name of the geo file and the data file, which contains respectively geographical data and
the ouput data (see open_hec_ras() for more precision) -&gt; list of string</li>
<li><strong>pathfile</strong> &#8211; the absolute path to the file chosen into namefile -&gt; list of string</li>
<li><strong>interpo_choice</strong> &#8211; the interpolation type (int: 0,1,2 or 3). See grid_and_interpo() for mroe details.</li>
<li><strong>manning_data</strong> &#8211; Contains the manning data. It can be in an array form (variable) or as a float (constant)</li>
<li><strong>nb_point_vel</strong> &#8211; the number of velcoity point by whole profile</li>
<li><strong>show_fig_1D</strong> &#8211; A boolean. If True, image from the 1D data are created and savec</li>
<li><strong>q</strong> &#8211; used by the second thread.</li>
<li><strong>path_im</strong> &#8211; the path where to save the figure</li>
<li><strong>print_cmd</strong> &#8211; if True the print command is directed in the cmd, False if directed to the GUI</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>** Technical comments**</p>
<p>This function redirect the sys.stdout. The point of doing this is because this function will be call by the GUI or
by the cmd. If it is called by the GUI, we want the output to be redirected to the windows for the log under HABBY.
If it is called by the cmd, we want the print function to be sent to the command line. We make the switch here.</p>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_rubar2d">
<code class="descclassname">src.rubar.</code><code class="descname">load_rubar2d</code><span class="sig-paren">(</span><em>geofile</em>, <em>tpsfile</em>, <em>pathgeo</em>, <em>pathtps</em>, <em>path_im</em>, <em>save_fig</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_rubar2d" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the function used to load the RUBAR data in 2D.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geofile</strong> &#8211; the name of the .mai or .dat file which contains the connectivity table and the coordinates (string)</li>
<li><strong>tpsfile</strong> &#8211; the name of the .tps file (string)</li>
<li><strong>pathgeo</strong> &#8211; path to the geo file (string)</li>
<li><strong>pathtps</strong> &#8211; path to the tps file which contains the outputs (string)</li>
<li><strong>path_im</strong> &#8211; the path where to save the figure (string)</li>
<li><strong>save_fig</strong> &#8211; a boolean indicating if the figures should be created or not</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">velocity and height at the center of the cells, the coordinate of the point of the cells,
the coordinates of the center of the cells and the connectivity table.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_rubar2d_and_create_grid">
<code class="descclassname">src.rubar.</code><code class="descname">load_rubar2d_and_create_grid</code><span class="sig-paren">(</span><em>name_hdf5</em>, <em>geofile</em>, <em>tpsfile</em>, <em>pathgeo</em>, <em>pathtps</em>, <em>path_im</em>, <em>name_prj</em>, <em>path_prj</em>, <em>model_type</em>, <em>nb_dim</em>, <em>path_hdf5</em>, <em>q=[]</em>, <em>print_cmd=False</em>, <em>fig_opt={}</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_rubar2d_and_create_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the function used to load the RUBAR data in 2D, to pass the data from the cell to the node using
interpolation and to save the whole in an hdf5 format</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name_hdf5</strong> &#8211; the base name of the created hdf5 (string)</li>
<li><strong>geofile</strong> &#8211; the name of the .mai or .dat file which contains the connectivity table and the coordinates (string)</li>
<li><strong>tpsfile</strong> &#8211; the name of the .tps file (string)</li>
<li><strong>pathgeo</strong> &#8211; path to the geo file (string)</li>
<li><strong>pathtps</strong> &#8211; path to the tps file which contains the outputs (string)</li>
<li><strong>path_im</strong> &#8211; the path where to save the figure (string)</li>
<li><strong>name_prj</strong> &#8211; the name of the project (string)</li>
<li><strong>path_prj</strong> &#8211; the path of the project</li>
<li><strong>model_type</strong> &#8211; the name of the model such as Rubar, hec-ras, etc. (string)</li>
<li><strong>nb_dim</strong> &#8211; the number of dimension (model, 1D, 1,5D, 2D) in a float</li>
<li><strong>path_hdf5</strong> &#8211; A string which gives the adress to the folder in which to save the hdf5</li>
<li><strong>q</strong> &#8211; used by the second thread to get the error back to the GUI at the end of the thread</li>
<li><strong>print_cmd</strong> &#8211; if True the print command is directed in the cmd, False if directed to the GUI</li>
<li><strong>fig_opt</strong> &#8211; the figure option, used here to get the minimum water height to have a wet node (can be &gt; 0)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.load_tps_2d">
<code class="descclassname">src.rubar.</code><code class="descname">load_tps_2d</code><span class="sig-paren">(</span><em>tpsfile</em>, <em>path</em>, <em>nb_cell</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.load_tps_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to load the output data in the 2D rubar case. The geometry file (.mai or .dat) should be loaded before.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>tpsfile</strong> &#8211; the name of the file with the data for the 2d case</li>
<li><strong>path</strong> &#8211; the path to the tps file.</li>
<li><strong>nb_cell</strong> &#8211; the number of cell extracted from the .mai file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">v, h, timestep (all in list of np.array)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.m_file_load_coord_1d">
<code class="descclassname">src.rubar.</code><code class="descname">m_file_load_coord_1d</code><span class="sig-paren">(</span><em>geofile_name</em>, <em>pathgeo</em><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.m_file_load_coord_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the m.ETUDE file which is based on .st format from cemagref. When we use the M.ETUDE file
instead of the rbe file, more than one reach can be studied but the center and side of the river is not
indicated anymore.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>geofile_name</strong> &#8211; The name to the m.ETUDE file (string)</li>
<li><strong>pathgeo</strong> &#8211; the path to this file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the coordinates of the profiles (list of np.array with x,y,z coordinate), name of the profile
(list of string), dist along the river (list of float), number of profile by reach</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.rubar.main">
<code class="descclassname">src.rubar.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.rubar.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module</p>
</dd></dl>

</div>
<div class="section" id="telemac">
<h2>Telemac<a class="headerlink" href="#telemac" title="Permalink to this headline">¶</a></h2>
<p>in src/selafin_habby1.py</p>
<p>This module contains the functions used to load the Telemac data.</p>
<span class="target" id="module-src.selafin_habby1"></span><dl class="class">
<dt id="src.selafin_habby1.Selafin">
<em class="property">class </em><code class="descclassname">src.selafin_habby1.</code><code class="descname">Selafin</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin" title="Permalink to this definition">¶</a></dt>
<dd><p>Selafin file format reader for Telemac 2D. Create an object for reading data from a slf file.
Adapted from the original script &#8216;parserSELAFIN.py&#8217; from the open Telemac distribution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; the name of the binary Selafin file</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="src.selafin_habby1.Selafin.addcontent">
<code class="descname">addcontent</code><span class="sig-paren">(</span><em>fileName</em>, <em>times</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.addcontent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.appendcoretimeslf">
<code class="descname">appendcoretimeslf</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.appendcoretimeslf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.appendcorevarsslf">
<code class="descname">appendcorevarsslf</code><span class="sig-paren">(</span><em>varsor</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.appendcorevarsslf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.appendheaderslf">
<code class="descname">appendheaderslf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.appendheaderslf" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the header file</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.getheaderfloatsslf">
<code class="descname">getheaderfloatsslf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.getheaderfloatsslf" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the mesh coordinates</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.getheaderintegersslf">
<code class="descname">getheaderintegersslf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.getheaderintegersslf" title="Permalink to this definition">¶</a></dt>
<dd><p>Get dimensions and descritions (mesh)</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.getheadermetadataslf">
<code class="descname">getheadermetadataslf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.getheadermetadataslf" title="Permalink to this definition">¶</a></dt>
<dd><p>Get header information</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.gettimehistoryslf">
<code class="descname">gettimehistoryslf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.gettimehistoryslf" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the timesteps</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.getvalues">
<code class="descname">getvalues</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.getvalues" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the values for the variables at time t</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.getvariablesat">
<code class="descname">getvariablesat</code><span class="sig-paren">(</span><em>frame</em>, <em>varindexes</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.getvariablesat" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the values for the variables at a particular time step</p>
</dd></dl>

<dl class="method">
<dt id="src.selafin_habby1.Selafin.putcontent">
<code class="descname">putcontent</code><span class="sig-paren">(</span><em>fileName</em>, <em>times</em>, <em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.Selafin.putcontent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="src.selafin_habby1.getendianfromchar">
<code class="descclassname">src.selafin_habby1.</code><code class="descname">getendianfromchar</code><span class="sig-paren">(</span><em>fileslf</em>, <em>nchar</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.getendianfromchar" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Get the endian encoding</dt>
<dd>&#8220;&lt;&#8221; means little-endian
&#8220;&gt;&#8221; means big-endian</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="src.selafin_habby1.getfloattypefromfloat">
<code class="descclassname">src.selafin_habby1.</code><code class="descname">getfloattypefromfloat</code><span class="sig-paren">(</span><em>fileslf</em>, <em>endian</em>, <em>nfloat</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.getfloattypefromfloat" title="Permalink to this definition">¶</a></dt>
<dd><p>Get float precision</p>
</dd></dl>

<dl class="function">
<dt id="src.selafin_habby1.load_telemac">
<code class="descclassname">src.selafin_habby1.</code><code class="descname">load_telemac</code><span class="sig-paren">(</span><em>namefilet</em>, <em>pathfilet</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.load_telemac" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which load the telemac data using the Selafin class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>namefilet</strong> &#8211; the name of the selafin file (string)</li>
<li><strong>pathfilet</strong> &#8211; the path to this file (string)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the velocity, the height, the coordinate of the points of the grid, the connectivity table.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.selafin_habby1.load_telemac_and_cut_grid">
<code class="descclassname">src.selafin_habby1.</code><code class="descname">load_telemac_and_cut_grid</code><span class="sig-paren">(</span><em>name_hdf5</em>, <em>namefilet</em>, <em>pathfilet</em>, <em>name_prj</em>, <em>path_prj</em>, <em>model_type</em>, <em>nb_dim</em>, <em>path_hdf5</em>, <em>q=[]</em>, <em>print_cmd=False</em>, <em>fig_opt={}</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.load_telemac_and_cut_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls the function load_telemac and call the function cut_2d_grid(). Orginally, this function
was part of the TELEMAC class in Hydro_GUI_2.py but it was separated to be able to have a second thread, which
is useful to avoid freezing the GUI.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name_hdf5</strong> &#8211; the base name of the created hdf5 (string)</li>
<li><strong>namefilet</strong> &#8211; the name of the selafin file (string)</li>
<li><strong>pathfilet</strong> &#8211; the path to this file (string)</li>
<li><strong>name_prj</strong> &#8211; the name of the project (string)</li>
<li><strong>path_prj</strong> &#8211; the path of the project</li>
<li><strong>model_type</strong> &#8211; the name of the model such as Rubar, hec-ras, etc. (string)</li>
<li><strong>nb_dim</strong> &#8211; the number of dimension (model, 1D, 1,5D, 2D) in a float</li>
<li><strong>path_hdf5</strong> &#8211; A string which gives the adress to the folder in which to save the hdf5</li>
<li><strong>q</strong> &#8211; used by the second thread to get the error back to the GUI at the end of the thread</li>
<li><strong>print_cmd</strong> &#8211; if True the print command is directed in the cmd, False if directed to the GUI</li>
<li><strong>fig_opt</strong> &#8211; the figure option, used here to get the minimum water height to have a wet node (can be &gt; 0)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.selafin_habby1.plot_vel_h">
<code class="descclassname">src.selafin_habby1.</code><code class="descname">plot_vel_h</code><span class="sig-paren">(</span><em>coord_p2, h, v, path_im, timestep=[-1]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.selafin_habby1.plot_vel_h" title="Permalink to this definition">¶</a></dt>
<dd><p>a function to plot the velocity and height which are the output from TELEMAC. It is used to debug.
It is not used direclty by HABBY.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coord_p2</strong> &#8211; the coordinates of the point forming the grid</li>
<li><strong>h</strong> &#8211; the  water height</li>
<li><strong>v</strong> &#8211; the velocity</li>
<li><strong>path_im</strong> &#8211; the path where the image should be saved (string)</li>
<li><strong>timestep</strong> &#8211; which time step should be plotted</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="lammi">
<h2>LAMMI<a class="headerlink" href="#lammi" title="Permalink to this headline">¶</a></h2>
<p>in src/lammi.py</p>
<p>This module contains functions used to load data from LAMMI. For more information on LAMMI, please see the pdf document <a class="reference download internal" href="_downloads/LAMMIGuideMetho.pdf" download=""><code class="xref download docutils literal"><span class="pre">LAMMI.pdf</span></code></a></p>
<span class="target" id="module-src.lammi"></span><dl class="function">
<dt id="src.lammi.check_code_change">
<code class="descclassname">src.lammi.</code><code class="descname">check_code_change</code><span class="sig-paren">(</span><em>facies_path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.lammi.check_code_change" title="Permalink to this definition">¶</a></dt>
<dd><p>If we can find the habitat.txt file, we check that the conversion from EDF to Cemagref code was done as in HABBY.
In most case, the habiat.txt file will not be found. This is not a problem.
:param facies_path: the path to the facies.txt file
:return: a boolean</p>
</dd></dl>

<dl class="function">
<dt id="src.lammi.compare_lammi">
<code class="descclassname">src.lammi.</code><code class="descname">compare_lammi</code><span class="sig-paren">(</span><em>filename_habby</em>, <em>filename_lammi</em>, <em>filename_lammi_sur</em><span class="sig-paren">)</span><a class="headerlink" href="#src.lammi.compare_lammi" title="Permalink to this definition">¶</a></dt>
<dd><p>This function compares the SPU for the trut done by lammi and by HABBY (using hydrological lammi output). It is
not directly used by HABBY, but it can be useful to check the differences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename_habby</strong> &#8211; the name and path of the text file giving the spu from HABBY (spu_xxx.txt)</li>
<li><strong>filename_lammi</strong> &#8211; the name and the file of the lammi spu (FaciesTRF.txt)</li>
<li><strong>filename_lammi_sur</strong> &#8211; the name and the file of the lammi surface</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.lammi.coord_lammi">
<code class="descclassname">src.lammi.</code><code class="descname">coord_lammi</code><span class="sig-paren">(</span><em>dist_all</em>, <em>vel_all</em>, <em>height_all</em>, <em>sub_all</em>, <em>length_all</em><span class="sig-paren">)</span><a class="headerlink" href="#src.lammi.coord_lammi" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes the data from the lammi outputs and get the coordinate for the river. It also
reform the data to put it in the needed for HABBY (as the other 1.5D hydraulic model as hec_ras).</p>
<p>To get the coordinates, we assume that the river is straight, that each facies is one after the other and
that the river passes by the deepest point of the profile. In addition we assume that the profile are straight
and perpendicular to the river. We assume that each facies (or reach for HABBY) is separated by a constant value</p>
<p>We loop through all the profiles for all reach all time steps. For each profile, the x coordinate is identical
for all point of the profile and is calculated using length_all. When a new reach starts, a x constant distance
is added to the x coordinate. To find the y coordinate, we first pass from cell data (in lammi) to point data.
The point are the center of each cell and the border of this cells.  Then, we find the higher water height and
we assume that the river passes there. Hence, this is the origin of y-coordinate axes.</p>
<p>We double the last and the first profile of each reach/facies. Indded, in HABBY,the information of a profile are
given to the cells of the grid before and after the profile. If no cell would be done before or after the last/first
profile, these profiles would have less wight than the other which is a problem to reproduce lammi results. This
also avoid the case of a facies with only one profile, which is complicated to maange for the grid creation.</p>
<p>To keep as much as possible the same data than in Lammi, we create four points for each orginal lammi cells. The
three first points have the cell value of lammi and the last one is the average of the value of these cells and
the next. The point are disposed so that the first and last points are close to the end of the cells.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dist_all</strong> &#8211; the distance along profile by reach (or facies) and by time step</li>
<li><strong>vel_all</strong> &#8211; the velocity along profile by reach (or facies) and by time step</li>
<li><strong>height_all</strong> &#8211; the height along profile by reach (or facies) and by time step</li>
<li><strong>sub_all</strong> &#8211; the substrate data along profile by reach (or facies) and by time step. Eacu subtrate data is a list
of eight number representing the percentage of each of the eight subtrate class.</li>
<li><strong>length_all</strong> &#8211; the distance between profile</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coord_pro, nb_pro_reach and vh_pro in the same form as in final form for hec-ras, a variable with the eight
subtrate data in a percetage form (sub_pro) and a variable to find the position of the middle profile
(used by manage grid)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.lammi.fig_lammi">
<code class="descclassname">src.lammi.</code><code class="descname">fig_lammi</code><span class="sig-paren">(</span><em>vh_pro</em>, <em>coord_pro</em>, <em>nb_pro_reach</em>, <em>pro_num</em>, <em>sim_num</em>, <em>fig_opt</em>, <em>path_im</em><span class="sig-paren">)</span><a class="headerlink" href="#src.lammi.fig_lammi" title="Permalink to this definition">¶</a></dt>
<dd><p>This function create a figure with the loaded lammi data.
It work only for one time steps gven by the number sim_num.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>vh_pro</strong> &#8211; dist along the profile, height, vel</li>
<li><strong>coord_pro</strong> &#8211; x,y, dist along profile, height</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach</li>
<li><strong>pro_num</strong> &#8211; the profile to plot</li>
<li><strong>sim_num</strong> &#8211; the time step (or simuation) to plot</li>
<li><strong>fig_opt</strong> &#8211; the option for the figure</li>
<li><strong>path_im</strong> &#8211; path path where to save the figure</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.lammi.get_transect_filename">
<code class="descclassname">src.lammi.</code><code class="descname">get_transect_filename</code><span class="sig-paren">(</span><em>facies_path</em>, <em>facies_name</em>, <em>transect_path</em>, <em>transect_name</em>, <em>new_dir</em><span class="sig-paren">)</span><a class="headerlink" href="#src.lammi.get_transect_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>For each facies, we obtain the name of the transect file and the length of this reach</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>facies_path</strong> &#8211; the path the facies.txt file</li>
<li><strong>facies_name</strong> &#8211; the name of the facies file, usually &#8216;Facies.txt&#8217;</li>
<li><strong>transect_path</strong> &#8211; the path to the transect.txt path</li>
<li><strong>transect_name</strong> &#8211; the name of the transect file, usually &#8216;Transect.txt&#8217;</li>
<li><strong>new_dir</strong> &#8211; If the folder with the transect have been moved, this argument allos it to be corrected without
modification to transect.txt</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the length of each transect (arranged by facies and station) and the filename with the transect info</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.lammi.load_lammi">
<code class="descclassname">src.lammi.</code><code class="descname">load_lammi</code><span class="sig-paren">(</span><em>facies_path</em>, <em>transect_path</em>, <em>path_im</em>, <em>new_dir</em>, <em>fig_opt</em>, <em>savefig1d</em>, <em>transect_name</em>, <em>facies_name</em><span class="sig-paren">)</span><a class="headerlink" href="#src.lammi.load_lammi" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the data from the LAMMI model. A description of the LAMMI model is available in the
documentation folder (LAMMIGuideMetho.pdf).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>transect_path</strong> &#8211; the path to the transect.txt path</li>
<li><strong>facies_path</strong> &#8211; the path the facies.txt file</li>
<li><strong>path_im</strong> &#8211; the path where to save the image</li>
<li><strong>fig_opt</strong> &#8211; the figure option</li>
<li><strong>savefig1d</strong> &#8211; create and save the figure related to the loading of the data (profile and so on)</li>
<li><strong>new_dir</strong> &#8211; if necessary, the path to the resultat file (.prn file). Be default, use the one in transect.txt</li>
<li><strong>transect_name</strong> &#8211; the name of the transect file, usually &#8216;Transect.txt&#8217;</li>
<li><strong>facies_name</strong> &#8211; the name of the facies file, usually &#8216;Facies.txt&#8217;</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical Comments</strong></p>
<p>LAMMI is organised aroung group of transects. Transect are river profile which describe the river geometry.
In LAMMI, there are four way of grouping transect. The facies is the a group a transect which is considered by HABBY
to form a reach. The facies can then begroup in station. HABBY do not considered station directly, but it is
possible to use the function &#8220;load_station&#8221; to get the station info if needed. The group Secteur are used in case
where water is brought to the river.</p>
<p>To load LAMMI data, we first load the facies file, which gives which transect are in which facies. Then, we use
the transect file to know the length of each transect (length between transects along the river) and the
name of the file containing the transect precise data. The name of the file is an absolute path to the file.
This can be annoying if one want to move the files. Hence, we add the variable new_dir which correct the transect
file in case the files containing the transect data have been moved (they should however all be in the same
directory). This is done by the function get_transect_name().</p>
<p>Then it uses the function load_transect_data to read all this data , file by file. Consequentely, we have
the data in memory but no(x,y) coordinate. In addition, this data is is in the different form than in the other
hydraulic model.</p>
<p>To obtain the coordainte of the river and to put the data is the form usually needed by HABBY for 1.5D model
(coord_pro, vh_pro, nb_pro_reach), we use the coord_lammi() function.</p>
<p>There is also an optionnal check to control that the conversion between lammi and cemagref code is as normal.
This check is only done if HABBY can find the habitat.txt file where the conversion can be modified by the user.
Otherwise we assume that the normal conversion is used. Obviously, this check should be modifed if the edf
to cemagref conversion is modified.</p>
</dd></dl>

<dl class="function">
<dt id="src.lammi.load_station">
<code class="descclassname">src.lammi.</code><code class="descname">load_station</code><span class="sig-paren">(</span><em>station_path</em>, <em>station_name</em><span class="sig-paren">)</span><a class="headerlink" href="#src.lammi.load_station" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the station data from the LAMMI model. This is the data contains in Station.txt. It is not used
by HABBY but it could be useful.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>station_path</strong> &#8211; the path to the station.txt file</li>
<li><strong>station_name</strong> &#8211; the name of the station file, usually &#8216;Station.txt&#8217;</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the length of the station (list of float) and the id of the facies for each station (list of list)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.lammi.load_transect_data">
<code class="descclassname">src.lammi.</code><code class="descname">load_transect_data</code><span class="sig-paren">(</span><em>fac_filename_all</em><span class="sig-paren">)</span><a class="headerlink" href="#src.lammi.load_transect_data" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the transect data. In this data, there are the subtrate, the height and the velocity data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fac_filename_all</strong> &#8211; the list of transect name organized by facies</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.lammi.main">
<code class="descclassname">src.lammi.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.lammi.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module</p>
</dd></dl>

<dl class="function">
<dt id="src.lammi.open_lammi_and_create_grid">
<code class="descclassname">src.lammi.</code><code class="descname">open_lammi_and_create_grid</code><span class="sig-paren">(</span><em>facies_path</em>, <em>transect_path</em>, <em>path_im</em>, <em>name_hdf5</em>, <em>name_prj</em>, <em>path_prj</em>, <em>path_hdf5</em>, <em>new_dir=''</em>, <em>fig_opt=[]</em>, <em>savefig1d=False</em>, <em>transect_name='Transect.txt'</em>, <em>facies_name='Facies.txt'</em>, <em>print_cmd=False</em>, <em>q=[]</em>, <em>dominant_case=1</em>, <em>model_type='LAMMI'</em><span class="sig-paren">)</span><a class="headerlink" href="#src.lammi.open_lammi_and_create_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the data from the LAMMI model using the load_lammi() function., create the grid and save the
data in an hdf5 file. A description of the LAMMI model is available in the documentation folder
(LAMMIGuideMetho.pdf).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>transect_path</strong> &#8211; the path to the transect.txt path</li>
<li><strong>facies_path</strong> &#8211; the path the facies.txt file</li>
<li><strong>path_im</strong> &#8211; the path where to save the image</li>
<li><strong>fig_opt</strong> &#8211; the figure option</li>
<li><strong>savefig1d</strong> &#8211; create and save the figure related to the loading of the data (profile and so on)</li>
<li><strong>name_hdf5</strong> &#8211; the name of the hdf5 to be created</li>
<li><strong>name_prj</strong> &#8211; the name of the project (string)</li>
<li><strong>path_prj</strong> &#8211; the path of the project</li>
<li><strong>path_hdf5</strong> &#8211; the path to the hdf5 data</li>
<li><strong>new_dir</strong> &#8211; if necessary, the path to the resultat file (.prn file). Be default, use the one in transect.txt</li>
<li><strong>transect_name</strong> &#8211; the name of the transect file, usually &#8216;Transect.txt&#8217;</li>
<li><strong>facies_name</strong> &#8211; the name of the facies file, ususally &#8216;Facies.txt</li>
<li><strong>print_cmd</strong> &#8211; if True the print command is directed in the cmd, False if directed to the GUI</li>
<li><strong>q</strong> &#8211; used if this function is send using the second thread</li>
<li><strong>dominant_case</strong> &#8211; an int to manage the case where the transfomation form percentage to dominnat is unclear (two
maxinimum percentage are equal from one element). if -1 take the smallest, if 1 take the biggest,
if 0, we do not know.</li>
<li><strong>model_type</strong> &#8211; which type of model (LAMMI in this case). It is as an argument just in case (lammi, Lammi, etc.)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>LAMMI has a special way of creating a grid from its data. Because spatial information is not very good in LAMMI,
we can only used the create_grid_only_1_profile() function. The function which uses triangle to create the grid can
not be used here as the developper fomr LAMMI did not wish to introduce an interpolation method in their outputs.
In addition, LAMMI integrates substrate data which should be direclty added to the grid while other hydraulic model
get their substrate data from another sources.</p>
</dd></dl>

</div>
<div class="section" id="load-habby-hdf5-file">
<h2>Load HABBY hdf5 file<a class="headerlink" href="#load-habby-hdf5-file" title="Permalink to this headline">¶</a></h2>
<p>in src/load_hdf5.py</p>
<p>This module contains some functions to load and manage hdf5 input/outputs.</p>
<span class="target" id="module-src.load_hdf5"></span><dl class="function">
<dt id="src.load_hdf5.add_habitat_to_merge">
<code class="descclassname">src.load_hdf5.</code><code class="descname">add_habitat_to_merge</code><span class="sig-paren">(</span><em>hdf5_name</em>, <em>path_hdf5</em>, <em>vh_cell</em>, <em>h_cell</em>, <em>v_cell</em>, <em>fish_name</em><span class="sig-paren">)</span><a class="headerlink" href="#src.load_hdf5.add_habitat_to_merge" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes a merge file and add habitat data to it. The habitat data is given by cell. It also save the
velocity and the water height by cell (and not by node)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hdf5_name</strong> &#8211; the name of the merge file</li>
<li><strong>path_hdf5</strong> &#8211; the path to this file</li>
<li><strong>vh_cell</strong> &#8211; the habitat value by cell</li>
<li><strong>h_cell</strong> &#8211; the height data by cell</li>
<li><strong>v_cell</strong> &#8211; the velcoity data by cell</li>
<li><strong>fish_name</strong> &#8211; the name of the fish (with the stage in it)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.load_hdf5.copy_files">
<code class="descclassname">src.load_hdf5.</code><code class="descname">copy_files</code><span class="sig-paren">(</span><em>names</em>, <em>paths</em>, <em>path_input</em><span class="sig-paren">)</span><a class="headerlink" href="#src.load_hdf5.copy_files" title="Permalink to this definition">¶</a></dt>
<dd><p>This function copied the input files to the project file. The input files are usually contains in the input
project file. It is ususally done on a second thread as it might be long.</p>
<p>For the moment this function cannot send warning and error to the GUI. As input shoudl have been cheked before
by HABBY, this should not be a problem.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>names</strong> &#8211; the name of the files to be copied (list of string)</li>
<li><strong>paths</strong> &#8211; the path to these files (list of string)</li>
<li><strong>path_input</strong> &#8211; the path where to send the input (string)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.load_hdf5.get_all_filename">
<code class="descclassname">src.load_hdf5.</code><code class="descname">get_all_filename</code><span class="sig-paren">(</span><em>dirname</em>, <em>ext</em><span class="sig-paren">)</span><a class="headerlink" href="#src.load_hdf5.get_all_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets the name of all file with a particular extension in a folder. Useful to get all the output
from one hydraulic model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dirname</strong> &#8211; the path to the directory (string)</li>
<li><strong>ext</strong> &#8211; the extension (.txt for example). It is a string, the point needs to be the first character.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list with the filename (filename+dir) for each extension</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.load_hdf5.get_hdf5_name">
<code class="descclassname">src.load_hdf5.</code><code class="descname">get_hdf5_name</code><span class="sig-paren">(</span><em>model_name</em>, <em>name_prj</em>, <em>path_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src.load_hdf5.get_hdf5_name" title="Permalink to this definition">¶</a></dt>
<dd><p>This function get the name of the hdf5 file containg the hydrological data for an hydrological model of type
model_name. If there is more than one hdf5 file, it choose the last one. Tha path is the path from the
project folder. Hencem, it is not the absolute path.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>model_name</strong> &#8211; the name of the hydrological model as written in the attribute of the xml project file</li>
<li><strong>name_prj</strong> &#8211; the name of the project</li>
<li><strong>path_prj</strong> &#8211; the path to the project</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the name of the hdf5 file</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.load_hdf5.get_initial_files">
<code class="descclassname">src.load_hdf5.</code><code class="descname">get_initial_files</code><span class="sig-paren">(</span><em>path_hdf5</em>, <em>hdf5_name</em><span class="sig-paren">)</span><a class="headerlink" href="#src.load_hdf5.get_initial_files" title="Permalink to this definition">¶</a></dt>
<dd><p>This function looks into a merge file to find the hydraulic and subtrate file which
were used to create this file.
:param path_hdf5: the path to the hdf5 file
:param hdf5_name: the name fo this hdf5 file
:return: the name of the substrate and hydraulic file used to create the merge file</p>
</dd></dl>

<dl class="function">
<dt id="src.load_hdf5.load_hdf5_hyd">
<code class="descclassname">src.load_hdf5.</code><code class="descname">load_hdf5_hyd</code><span class="sig-paren">(</span><em>hdf5_name_hyd</em>, <em>path_hdf5=''</em>, <em>merge=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.load_hdf5.load_hdf5_hyd" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to load the 2D hydrological data contains in the hdf5 file in the form required by HABBY. f hdf5_name_sub
is an absolute path, the path_prj is not used. If it is a relative path, the path is composed of the path to the
project (path_prj) composed with hdf5_name_sub.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>hdf5_name_hyd</strong> &#8211; filename of the hdf5 file (string)</li>
<li><strong>path_hdf5</strong> &#8211; the path to the hdf5 file</li>
<li><strong>merge</strong> &#8211; If merge is True. this is a merged file with substrate data added</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the connectivity table, the coordinates of the point, the height data, the velocity data on the coordinates.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.load_hdf5.load_hdf5_sub">
<code class="descclassname">src.load_hdf5.</code><code class="descname">load_hdf5_sub</code><span class="sig-paren">(</span><em>hdf5_name_sub</em>, <em>path_hdf5</em>, <em>ind_const=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.load_hdf5.load_hdf5_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to load the substrate data contained in the hdf5 file. It also manage
the constant cases. If hdf5_name_sub is an absolute path, the path_prj is not used. If it is a relative path,
the path is composed of the path to the &#8216;hdf5&#8217; folder (path_prj/fichier_hdf5) composed with hdf5_name_sub. it manages constant and
vairable (based on a grid) cases. The code should be of cemagref type and the data is given as coarser and dominant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hdf5_name_sub</strong> &#8211; path and file name to the hdf5 file (string)</li>
<li><strong>path_prj</strong> &#8211; the path to the hdf5 file</li>
<li><strong>ind_const</strong> &#8211; If True this function reurn a boolean which indicates if the substrant is constant or not</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.load_hdf5.load_sub_percent">
<code class="descclassname">src.load_hdf5.</code><code class="descname">load_sub_percent</code><span class="sig-paren">(</span><em>hdf5_name_hyd</em>, <em>path_hdf5=''</em><span class="sig-paren">)</span><a class="headerlink" href="#src.load_hdf5.load_sub_percent" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the substrate in percent form, if this info is present in the hdf5 file. It send a warning
otherwise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>hdf5_name_hyd</strong> &#8211; filename of the hdf5 file (string)</li>
<li><strong>path_hdf5</strong> &#8211; the path to the hdf5 file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.load_hdf5.load_timestep_name">
<code class="descclassname">src.load_hdf5.</code><code class="descname">load_timestep_name</code><span class="sig-paren">(</span><em>hdf5_name</em>, <em>path_hdf5=''</em><span class="sig-paren">)</span><a class="headerlink" href="#src.load_hdf5.load_timestep_name" title="Permalink to this definition">¶</a></dt>
<dd><p>This function looks for the name of the timesteps in hydrological or merge hdf5. If it find the name
of the time steps, it retruns them. If not, it return an empty lists.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>hdf5_name</strong> &#8211; the name of the merge or hydrological hdf5 file</li>
<li><strong>path_hdf5</strong> &#8211; the path to the hdf5</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the name of the time step if they exist. Otherwise, an empty list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.load_hdf5.open_hdf5">
<code class="descclassname">src.load_hdf5.</code><code class="descname">open_hdf5</code><span class="sig-paren">(</span><em>hdf5_name</em><span class="sig-paren">)</span><a class="headerlink" href="#src.load_hdf5.open_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function which open an hdf5 file and check that it exists. it does not load the data. It only opens the
files.
:param hdf5_name: the path and name of the hdf5 file (string)</p>
</dd></dl>

<dl class="function">
<dt id="src.load_hdf5.save_hdf5">
<code class="descclassname">src.load_hdf5.</code><code class="descname">save_hdf5</code><span class="sig-paren">(</span><em>name_hdf5</em>, <em>name_prj</em>, <em>path_prj</em>, <em>model_type</em>, <em>nb_dim</em>, <em>path_hdf5</em>, <em>ikle_all_t</em>, <em>point_all_t</em>, <em>point_c_all_t</em>, <em>inter_vel_all_t</em>, <em>inter_h_all_t</em>, <em>xhzv_data=[]</em>, <em>coord_pro=[]</em>, <em>vh_pro=[]</em>, <em>nb_pro_reach=[]</em>, <em>merge=False</em>, <em>sub_pg_all_t=[]</em>, <em>sub_dom_all_t=[]</em>, <em>sub_per_all_t=[]</em>, <em>sim_name=[]</em>, <em>sub_ini_name=''</em>, <em>hydro_ini_name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#src.load_hdf5.save_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>This function save the hydrological data in the hdf5 format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name_hdf5</strong> &#8211; the base name for the hdf5 file to be created (string)</li>
<li><strong>name_prj</strong> &#8211; the name of the project (string)</li>
<li><strong>path_prj</strong> &#8211; the path of the project</li>
<li><strong>model_type</strong> &#8211; the name of the model such as Rubar, hec-ras, etc. (string)</li>
<li><strong>nb_dim</strong> &#8211; the number of dimension (model, 1D, 1,5D, 2D) in a float</li>
<li><strong>path_hdf5</strong> &#8211; A string which gives the adress to the folder in which to save the hdf5</li>
<li><strong>ikle_all_t</strong> &#8211; the connectivity table for all discharge, for all reaches and all time steps</li>
<li><strong>point_all_t</strong> &#8211; the point forming the grid, for all reaches and all time steps</li>
<li><strong>point_c_all_t</strong> &#8211; the point at the center of the cells, for all reaches and all time steps</li>
<li><strong>inter_vel_all_t</strong> &#8211; the velocity for all grid point, for all reaches and all time steps (by node)</li>
<li><strong>inter_h_all_t</strong> &#8211; the height for all grid point, for all reaches and all time steps (by node)</li>
<li><strong>xhzv_data</strong> &#8211; data linked with 1D model (only used when a 1D model was transformed to a 2D)</li>
<li><strong>coord_pro</strong> &#8211; data linked with 1.5D model or data created by dist_vist from a 1D model (profile data)</li>
<li><strong>vh_pro</strong> &#8211; data linked with 1.5D model or data created by dist_vist from a 1D model (velcoity and height data)</li>
<li><strong>nb_pro_reach</strong> &#8211; data linked with 1.5D model or data created by dist_vist from a 1D model (nb profile)</li>
<li><strong>merge</strong> &#8211; If True, the data is coming from the merging of substrate and hydrological data.</li>
<li><strong>sub_pg_all_t</strong> &#8211; the data of the coarser substrate given on the merged grid by cell. Only used if merge is True.</li>
<li><strong>sub_dom_all_t</strong> &#8211; the data of the dominant substrate given on the merged grid by cells. Only used if merge is True.</li>
<li><strong>sub_per_all_t</strong> &#8211; the data of the substreate by percentage. Only used with lammi (mostly)</li>
<li><strong>sim_name</strong> &#8211; the name of the simulation or the names of the time steps if the names are not [0,1,2,3, etc.]</li>
<li><strong>sub_ini_name</strong> &#8211; The name of the substrate hdf5 file from which the data originates</li>
<li><strong>hydro_ini_name</strong> &#8211; the name of the hydraulic hdf5 file from which the data originates</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>This function could look better inside the class SubHydroW where it was before. However, it was not possible
to use it on the command line and it was not pratical for having two thread (it is impossible to have a method
as a second thread)</p>
<p>This function creates an hdf5 file which contains the hydrological data. First it creates an empty hdf5.
Then it fill the hdf5 with data. For 1D model, it fill the data in 1D (the original data), then the 1.5D data
created by dist_vitess2.py and finally the 2D data. For model in 2D it only saved 2D data. Hence, the 2D data
is the data which is common to all model and which can always be loaded from a hydrological hdf5 created by
HABBY. The 1D and 1.5D data is only present if the model is 1D or 1.5D. Here is some general info about the
created hdf5:</p>
<ul class="simple">
<li>Name of the file: name_hdf5. If we save all file even if the model is re-run we add a time stamp.
For example, test4_HEC-RAS_25_10_2016_12_23_23.h5.</li>
<li>Position of the file: in the folder  figure_habby currently (probably in a project folder in the final software)</li>
<li>Format of the hdf5 file:<ul>
<li>Dats_gen:  number of time step and number of reach</li>
<li>Data_1D:  xhzv_data_all (given profile by profile)</li>
<li>Data_15D :  vh_pro, coord_pro (given profile by profile in a dict) and nb_pro_reach.</li>
<li>Data_2D : For each time step, for each reach: ikle, point, point_c, inter_h, inter_vel</li>
</ul>
</li>
</ul>
<p>If a list has elements with a changing number of variables, it is necessary to create a dictionary to save
this list in hdf5. For example, a dictionary will be needed to save the following list: [[1,2,3,4], [1,2,3]].
This is used for example, to save data by profile as we can have profile with more or less points. We also note
in the hdf5 attribute some important info such as the project name, path to the project, hdf5 version.
This can be useful if an hdf5 is lost and is not linked with any project. We also add the name of the created
hdf5 to the xml project file. Now we can load the hydrological data using this hdf5 file and the xml project file.</p>
<p>When saving habitat data, we add a time stamp so that if re-run an habitat simulation, we do not loos all the data.
When loading, the last data should be used.</p>
<p>Hdf5 file do not support unicode. It is necessary to encode string to write them.</p>
</dd></dl>

<dl class="function">
<dt id="src.load_hdf5.save_hdf5_sub">
<code class="descclassname">src.load_hdf5.</code><code class="descname">save_hdf5_sub</code><span class="sig-paren">(</span><em>path_hdf5</em>, <em>path_prj</em>, <em>name_prj</em>, <em>sub_pg</em>, <em>sub_dom</em>, <em>ikle_sub=[]</em>, <em>coord_p=[]</em>, <em>name_hdf5=''</em>, <em>constsub=False</em>, <em>model_type='SUBSTRATE'</em>, <em>return_name=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.load_hdf5.save_hdf5_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates an hdf5 with the substrate data. This hdf5 does not have the same form than the hdf5 file used
to store hydrological or merge data. This hdf5 store the substrate data alone before it is merged with the
hydrological info. The substrate info should be given in the cemagref code.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path_hdf5</strong> &#8211; the path where the hdf5 file should be saved</li>
<li><strong>path_prj</strong> &#8211; the project path</li>
<li><strong>name_prj</strong> &#8211; the name of the project</li>
<li><strong>sub_pg</strong> &#8211; the coarser part of the substrate (array with length of ikle if const_sub is False, a float otherwise)</li>
<li><strong>sub_dom</strong> &#8211; the dominant part of the substrate (array with length of ikle if const_sub is False, a float otherwise)</li>
<li><strong>ikle_sub</strong> &#8211; the connectivity table for the substrate (only if constsub = False)</li>
<li><strong>coord_p</strong> &#8211; the point of the grid of the substrate (only if constsub = False)</li>
<li><strong>name_hdf5</strong> &#8211; the name of the substrate h5 file (without the timestamp). If not given, a default name is used.</li>
<li><strong>constsub</strong> &#8211; If True the substrate is a constant value</li>
<li><strong>model_type</strong> &#8211; the attribute for the xml file (usually SUBSTRATE)</li>
<li><strong>return_name</strong> &#8211; If True this function return the name of the substrate hdf5 name</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="section" id="form-of-the-hdf5-files">
<h3>Form of the hdf5 files<a class="headerlink" href="#form-of-the-hdf5-files" title="Permalink to this headline">¶</a></h3>
<p>Here is the actual form of the hdf5 containing the 2D hydrological data.</p>
<ul class="simple">
<li>Number of timestep: Data_gen/Nb_timestep</li>
<li>Number of reach: Data_gen/Nb_reach</li>
<li>Connectivity table for the whole profile: Data_2D/Whole_Profile/Reach_&lt;r&gt;/ikle</li>
<li>Connectivity table for the wetted area (by time step): Data_2D/Timestep&lt;t&gt;/Reach_&lt;r&gt;/ikle</li>
<li>Coordinates for the whole profile: Data_2D/Whole_Profile/Reach_&lt;r&gt;/point_all</li>
<li>Coordinates for the wetted area (by time steps): Data_2D/Timestep&lt;t&gt;/Reach_&lt;r&gt;/point_all</li>
<li>Data for the velocity: Data_2D/Timestep&lt;t&gt;/Reach_&lt;r&gt;/inter_vel_all</li>
<li>Data for the height:  Data_2D/Timestep&lt;t&gt;/Reach_&lt;r&gt;/inter_h_all</li>
</ul>
<p>Here is the actual form of the hdf5 containing the substrate data.</p>
<ul class="simple">
<li>the coordinate of the point forming the substrate &#8220;grid&#8221;: coord_p_sub/</li>
<li>the connectivity table of the substrate &#8220;grid&#8221;: ikle_sub/</li>
<li>Substrate data; not done yet</li>
</ul>
</div>
</div>
<div class="section" id="velocity-distribution">
<h2>Velocity distribution<a class="headerlink" href="#velocity-distribution" title="Permalink to this headline">¶</a></h2>
<p>in src/dist_vitesse2.py</p>
<p>The goal of this list of function is to distribute the velocity along the cross-section
for 1D model such as mascaret or Rubar BE. Hec-Ras outputs do not need to uses this type
of function as they are already distributed along the profiles.</p>
<p>The method of velocity distribution in HABBY is similar to the one used by Hec-Ras to distribute
velocity.</p>
<span class="target" id="module-src.dist_vistess2"></span><dl class="function">
<dt id="src.dist_vistess2.dist_velocity_hecras">
<code class="descclassname">src.dist_vistess2.</code><code class="descname">dist_velocity_hecras</code><span class="sig-paren">(</span><em>coord_pro</em>, <em>xhzv_data_all</em>, <em>manning_pro</em>, <em>nb_point=-99</em>, <em>eng=1.0</em>, <em>on_profile=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.dist_vistess2.dist_velocity_hecras" title="Permalink to this definition">¶</a></dt>
<dd><p>This function distribute the velocity along the profile using the method from hec-ras
which is described in the hydraulic reference manual p 4-20 (Flow distribtion calculation)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coord_pro</strong> &#8211; the coordinates and elevation of the river bed for each profile (x,y, h, dist along the profile)
this list is flatten No reach info.</li>
<li><strong>xhzv_data_all</strong> &#8211; water height and velocity at each profile, 1D</li>
<li><strong>manning_pro</strong> &#8211; the manning coefficient for zone between point of each profile.
For a particular profile, the length of manning_pro is the length of coord_pro[0]</li>
<li><strong>nb_point</strong> &#8211; number of velocity points (-99 takes the number of measured elevation as the number of velocity points).</li>
<li><strong>eng</strong> &#8211; in case the output from hec-ras are in US unit (eng=1 for SI unit and 1.486 for US unit)</li>
<li><strong>on_profile</strong> &#8211; Mascaret also gives outputs in poitns between profile. on_profile is true if the results are
close or on the profile (les than 3cm of difference). This is not important for rubar or other models</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the velocity for each profile by time step (x,v)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comment and walk-through</strong></p>
<p>First, we decide on which point along the profile we will calculate the velocity. This is controlled by the
variable nb_point. If nb_point=-99, we will calculate the velocity at the same point than the profile (i.e., the
velocity will be calculated at each point on which the elevation of the profile was measured). There are cases where
this is not adequate. Let’s imagine for example a rectangular canal. The calculation would only give two velocity
points, which is not enough. So, it is possible to give the number of velocity point on which the calculation must
be made, using the variable nb_point.</p>
<p>Currently, the velocity points are determined by dividing the whole profile in nb_point segments. This means that
some velocity point are not used afterwards because they are in the dry part of the profile and that it is not
possible to select for a part of the profile where more velocity points would be calculated. This could be modified
in the future if it is judged necessary.</p>
<p>To determine the point where velocity should be calculated we need to get two array: one “x” array, the distance
along the profile and one “h” array, the elevation of the profile at this point. As we choose the position of the
velocity point as regularly placed along the profile, the “x” array is easy to determine using linespace. For the
“h” array, we use the hypothesis that the elevation of the profile changes linearly between the measured elevation
points. We find between which elevation point are the new point and we use a linear interpolation to find the new”h”.
To find between which points we are, we use the bisect.bisect function. It is a bit like the np.where function,
but it is quicker when the array is ordered (as it is the case here).</p>
<p>Then, we get the manning array as created by the get_manning_arr and the get_manning function. It should be a float.</p>
<p>Next, we cut the profile to keep only the part under water. For this, we do two things: First we had a point on the
profile where h==0. We should account for the fact that we might have  “islands” (part of the profile which are
dry, but surrounded by water on both side.). So we cannot only looked which part are dry, we need to look
for each point where we pass from “wet to dry” or from “dry to wet”. At this place, we add one point where h= 0.
For these new points water height is obviously known, but x (the distlance along profile) should be determined.
It is determined assuming a linear change between the measured points of the profile.</p>
<p>If the profile is not entirely dry, we will now distribute the velocity along the profile. First, for each part of
the profile where velocity will be calculated, it looks where is the higher height (like if this part of the profile
is going up or down). Next, we calculate the area, the wetted perimeter and the hydraulic radius of each part of the
profile. By combining this geometrical information with the manning parameter, we can calculate the conveyance
of each part of the profile. See manual of hec-ras p.4-20 for the conveyance definition.</p>
<p>We now calculate the conveyance of the whole profile. Normally, the sum of the conveyance of the part is higher
than the total conveyance. The next part of the script corrects for this, using the ratio of the total conveyance
and the sum of the parts of the conveyance. Next, we calculate the velocity using the modelled energy slope (Sf)
and the manning equation. We then then add a velocity of zero where there are no water (velocity is not defined
at his point).</p>
</dd></dl>

<dl class="function">
<dt id="src.dist_vistess2.distribute_velocity">
<code class="descclassname">src.dist_vistess2.</code><code class="descname">distribute_velocity</code><span class="sig-paren">(</span><em>manning_data</em>, <em>nb_point_vel</em>, <em>coord_pro</em>, <em>xhzv_data</em>, <em>on_profile=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.dist_vistess2.distribute_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>This function make the link between the GUI and the functions of dist_vitesse2. It is used by 1D model,
notably rubar and masacret.</p>
<p>Dist vitess needs a manning parameters. It can be given by the user in two forms: a constant (float) or an array
created by the function load_manning_text.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>manning_data</strong> &#8211; the manning data as a float (constant) or as an array (variable)</li>
<li><strong>nb_point_vel</strong> &#8211; the number of velcoity point asked (if -99, the same number of point than the profile
will be used)</li>
<li><strong>coord_pro</strong> &#8211; the form of the profil (x,y, h, dist along the profile)</li>
<li><strong>xhzv_data</strong> &#8211; the vecoity and height data</li>
<li><strong>on_profile</strong> &#8211; Mascaret also gives outputs in poitns between profile. on_profile is true if the results are
close or on the profile (les than 3cm of difference). This is not important for rubar or other models</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.dist_vistess2.get_manning">
<code class="descclassname">src.dist_vistess2.</code><code class="descname">get_manning</code><span class="sig-paren">(</span><em>manning1</em>, <em>nb_point</em>, <em>nb_profil</em>, <em>coord_pro</em><span class="sig-paren">)</span><a class="headerlink" href="#src.dist_vistess2.get_manning" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates an array with the manning value when a single float is given, so when the manning value
is a constant for the whole river.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>manning1</strong> &#8211; the manning value (can be a value or an array)</li>
<li><strong>nb_point</strong> &#8211; the number of velocity point by profile</li>
<li><strong>nb_profil</strong> &#8211; the number of profile</li>
<li><strong>coord_pro</strong> &#8211; necessary if the number is -99 as we need to know the length of each profile</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>The function dist_velcoity_hec_ras needs a manning array with a length equal to the number of profile, where each
row (representing a profile) have one value by velocity point which will be calculated. This function creates an
array of this form based on a float. It creates a list of manning value which is identical for each point of the
river. It can be used for the cases where the same number of point is asked for each profile or for the case where
the number of point is defined by the form of the profile (nb_point = -99).</p>
</dd></dl>

<dl class="function">
<dt id="src.dist_vistess2.get_manning_arr">
<code class="descclassname">src.dist_vistess2.</code><code class="descname">get_manning_arr</code><span class="sig-paren">(</span><em>manning_arr</em>, <em>nb_point</em>, <em>coord_pro</em><span class="sig-paren">)</span><a class="headerlink" href="#src.dist_vistess2.get_manning_arr" title="Permalink to this definition">¶</a></dt>
<dd><p>This function create the manning array when manning data is loaded using a text file. In this case, the manning
value do not needs to be a constant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>manning_arr</strong> &#8211; the data for manning</li>
<li><strong>nb_point</strong> &#8211; the number of velocity point by profile</li>
<li><strong>coord_pro</strong> &#8211; x,y,dist</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comment</strong></p>
<p>The user creates a txt file with a list of manning info. Each manning value is given the following way:
the profile, the distance along the profile and the manning value. One value by line in SI unit.</p>
<p>This function automatically fills the missing value, so that the user do not needs to give each manning value.
He can describe one profile and this profile will be replicated until the next profile written in the text file.</p>
</dd></dl>

<dl class="function">
<dt id="src.dist_vistess2.main">
<code class="descclassname">src.dist_vistess2.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.dist_vistess2.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module.</p>
</dd></dl>

<dl class="function">
<dt id="src.dist_vistess2.plot_dist_vit">
<code class="descclassname">src.dist_vistess2.</code><code class="descname">plot_dist_vit</code><span class="sig-paren">(</span><em>v_pro</em>, <em>coord_pro</em>, <em>xhzv_data</em>, <em>plot_timestep</em>, <em>pro</em>, <em>name_pro=[]</em>, <em>on_profile=[]</em>, <em>zone_v_all=[]</em>, <em>data_profile=[]</em>, <em>xy_h_all=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.dist_vistess2.plot_dist_vit" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to plot the distribution of velocity and the elevation of the profile. It is quite close to the
similar function which is in hec-ras (see this function for a more detailed explanation)</p>
<p>It can be used to test the program if we provide the variable zone_v_all where zone_v_all is an hec-ras output with a
velocity distribution. In this case, it would plot the comparison between the output from this script and the
output from hec-ras. Of course, for this, it is necessary to have prepared the 1D output from hec-ras
(using the function preparetest_velocity) and to have the same points on which to calculate the velocity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>v_pro</strong> &#8211; the calculated velcocity distribution by time step</li>
<li><strong>coord_pro</strong> &#8211; the coordinate of the profiles</li>
<li><strong>xhzv_data</strong> &#8211; the output data from the model, before the velocity distrbution</li>
<li><strong>plot_timestep</strong> &#8211; which time step to be plottied</li>
<li><strong>name_pro</strong> &#8211; the name of the profile (optionnal just for the title)</li>
<li><strong>pro</strong> &#8211; which porfile to be plotted</li>
<li><strong>on_profile</strong> &#8211; select the data which is on the profile</li>
<li><strong>zone_v</strong> &#8211; output from hec-ras used to test dist_vitesse</li>
<li><strong>data_profile</strong> &#8211; output from hec-ras used to test dist_vitesse</li>
<li><strong>xy_h</strong> &#8211; output from hec-ras used to test dist_vitesse</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.dist_vistess2.preparetest_velocity">
<code class="descclassname">src.dist_vistess2.</code><code class="descname">preparetest_velocity</code><span class="sig-paren">(</span><em>coord_pro</em>, <em>vh_pro_orr</em>, <em>v_in</em><span class="sig-paren">)</span><a class="headerlink" href="#src.dist_vistess2.preparetest_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a debugging function. It takes as input the output from the hec-ras model and gives a 1D velocity as
output. This is only to test this program. It will not be used by HABBY directly. To use this function, it is
necessary to use the function to load hec-ras data from HABBY, so that the hec-ras data is in the right form.
The 1D-velocity is assumed to be the velocity as the lowest part of the profile. This is where a 1D-model would
estimate the position of the river (the lowest part of the river bed).</p>
<p>A complicated point to test the program is to put the velocity point at the same point than hec-ras. As hec-ras
calculate velocity between zones and not on one point, this is more or less impossible to do with precision.
However, one can count the number of velocity zone and give this as an input to dist_velocity_hecras() for the
variable nb_point. However, both line will not be exactly at the same place. The results should however be close
enough.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coord_pro</strong> &#8211; the coordinate of the profile (x,y,h,dist along profile)</li>
<li><strong>vh_pro_orr</strong> &#8211; the velocity distribution which is the output from hec ras (produced by hec-ras06.py)</li>
<li><strong>v_in</strong> &#8211; the uni-dimensional velocity</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="create-a-grid">
<h2>Create a grid<a class="headerlink" href="#create-a-grid" title="Permalink to this headline">¶</a></h2>
<p>in src/manage_grid_8</p>
<p>This module is composed of the functions used to manage the grid,
notably to create 2D grid from the output from 1D model.</p>
<p>There are two main way to go from data in 1.5D in a profile form to a 2D grid:</p>
<ul class="simple">
<li>through the usage of the triangle module in create_grid().</li>
<li>through the definition of a middle profile used as a guide to create the grid in create_grid_only_one_profile().</li>
</ul>
<p>For an in-depth explanation on how to create the grids, please see the pdf document <a class="reference download internal" href="_downloads/Grid_info.pdf" download=""><code class="xref download docutils literal"><span class="pre">More</span> <span class="pre">info</span> <span class="pre">on</span> <span class="pre">the</span> <span class="pre">grid</span></code></a></p>
<span class="target" id="module-src.manage_grid_8"></span><dl class="function">
<dt id="src.manage_grid_8.add_point">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">add_point</code><span class="sig-paren">(</span><em>point_all</em>, <em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.add_point" title="Permalink to this definition">¶</a></dt>
<dd><p>To manage the substrate data, we modify the hydrological grid to avoid to have cells with two substrate type.
This function add one coordinate point to the list of coordinates which compose the hydrological grid. This point
is the intersection between one side of one triangluar cell of the hydrological grid and one side of the
sibstrate layer (which is a shp). It only adds this intersection point if it is not already in point_all.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>point_all</strong> &#8211; the coordinates of the hydrological grid</li>
<li><strong>point</strong> &#8211; one intersection point between substrat and hydrological grids</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the updated point_all (the coordinates of the hydrological grid)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.create_dummy_substrate">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">create_dummy_substrate</code><span class="sig-paren">(</span><em>coord_pro</em>, <em>sqrtnp</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.create_dummy_substrate" title="Permalink to this definition">¶</a></dt>
<dd><p>For testing purposes, it can be useful to create a substrate input even if one does not exist.
This substrate is compose of n triangle situated on the rivers in the same coodinates system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coord_pro</strong> &#8211; the coordinate of each profile</li>
<li><strong>sqrtnp</strong> &#8211; the number of point which will compose one side of the new substrate grid (so the total number
of point is sqrtnb squared).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">dummy coord_sub, ikle_sub</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.create_grid">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">create_grid</code><span class="sig-paren">(</span><em>coord_pro, extra_pro, coord_sub, ikle_sub, nb_pro_reach=[0, 10000000000.0], vh_pro_t=[], q=[], pnew_add=1</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.create_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>It creates a grid from the coord_pro data using the triangle module.
It creates the grid up to the end of the profile if vh_pro_t is not present
or up to the water limit if vh_pro_t is present</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>q</strong> &#8211; used in the secondary process  when we do not call this function direclty, but we call it in a second
process so that the GUI do not crash if something go wrong (not used anymore in this form)</li>
<li><strong>coord_pro</strong> &#8211; the profile coordinates (x,y, h, dist along) the profile</li>
<li><strong>extra_pro</strong> &#8211; the number of &#8220;extra&#8221; profiles to be added between profile to simplify the grid</li>
<li><strong>coord_sub</strong> &#8211; (not used anymore)
the coordinate of the point forming the substrate layer (often created with substrate.load_sub)</li>
<li><strong>ikle_sub</strong> &#8211; (not used anymore)
the connectivity table of the substrate grid (often created with substrate.load_sub)</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of reach by profile starting with 0</li>
<li><strong>vh_pro_t</strong> &#8211; the velocity and height of the water (used to cut the limit of the river).</li>
<li><strong>pnew_add</strong> &#8211; (not used anymore) a parameter to cut the substrate side in smaller part (improve grid quality)
in the form dist along profile, h , v for the analyzed time step. f not given, gird is contructed on the whole profile.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">connectivity table and grid point</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Form of the function in summary</strong></p>
<ul class="simple">
<li>if vh_pro_t:<ul>
<li>find cordinate under water and used this to update coord_pro</li>
<li>see if there is islands, find the island limits and the holes indicating the inside/outside of the islands</li>
</ul>
</li>
<li>find the point which give the end/start of the segment defining the grid limit</li>
<li>find all point which need to be added to the grid and add extra profile if needed</li>
<li>based on the start/end points and the island limits, create the segments which gives the grid limit</li>
<li>triangulate and so create the grid</li>
<li>flag point which are overlapping in two grids</li>
</ul>
<p>For more info, see the document &#8220;More info on the grid&#8221;.</p>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.create_grid_only_1_profile">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">create_grid_only_1_profile</code><span class="sig-paren">(</span><em>coord_pro, nb_pro_reach=[0, 10000000000.0], vh_pro_t=[], sub_pg=[], sub_dom=[], sub_per=[], virtual_startend=False, divgiv=[], h0ok=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.create_grid_only_1_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates the grid from the coord_pro data using one additional profil in the middle. No triangulation.
The interpolation of the data is done in this function also, contrarily to create_grid().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coord_pro</strong> &#8211; the profile coordinates (x,y, h, dist along) the profile</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach</li>
<li><strong>vh_pro_t</strong> &#8211; the data with heigh and velocity, giving the river limits</li>
<li><strong>sub_pg</strong> &#8211; the data from the coarser substrate, in case the hydraulic model already contains substrate data</li>
<li><strong>sub_dom</strong> &#8211; the data from the dominant substrate, in case the hydraulic model already contains substrate data</li>
<li><strong>sub_per</strong> &#8211; the data from the subtrate in a percentage form</li>
<li><strong>virtual_startend</strong> &#8211; this indicates that the first and the lst profile is doubled. This is used so that the
grid around the last and the first profile extend after or before this profile, so that all porfile have
the same weight. Useful for LAMMI moslty.</li>
<li><strong>divgiv</strong> &#8211; in case we do not want to middle profile to be at an equal distance of both profile(one value by profile)</li>
<li><strong>h0ok</strong> &#8211; if we want to keep in the grid the cell with an height or velocity of zero (False usually)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the connevtivity table, the coordinate of the grid, the centroid of the grid, the velocity data on this
grid, the height data on this grid.</p>
</td>
</tr>
</tbody>
</table>
<p>For more info on this function, see the document &#8220;More info on the grid&#8221;.</p>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.cut_2d_grid">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">cut_2d_grid</code><span class="sig-paren">(</span><em>ikle</em>, <em>point_all</em>, <em>water_height</em>, <em>velocity</em>, <em>min_height=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.cut_2d_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>This function cut the grid of the 2D model to have correct wet surface. If we have a node with h&lt;0 and other node(s)
with h&gt;0, this function cut the cells to find the wetted perimeter, assuminga linear decrease in the water elevation.
This function works for one time steps and for one reach</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ikle</strong> &#8211; the connectivity table of the 2D grid</li>
<li><strong>point_all</strong> &#8211; the coordinate of the points</li>
<li><strong>water_height</strong> &#8211; the water height data given on the nodes</li>
<li><strong>velocity</strong> &#8211; the velcoity given on the nodes</li>
<li><strong>min_height</strong> &#8211; the minimum water height considered (as model sometime have cell with very low water height)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the update connectivity table, the coodinate of the point, the height of the water and the velocity on the updated grid</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.cut_2d_grid_all_reach">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">cut_2d_grid_all_reach</code><span class="sig-paren">(</span><em>ikle_all</em>, <em>point_all</em>, <em>inter_height_all</em>, <em>inter_vel_all</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.cut_2d_grid_all_reach" title="Permalink to this definition">¶</a></dt>
<dd><p>This function si just use to call cut_2d-grid for all reach. So that if we have a river with more than reach, we
do not need to add a for loops to call for all reach. Sometime it can save place. This can be only use for one
time step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ikle_all</strong> &#8211; the connectivity table of the 2D grid for all reach</li>
<li><strong>point_all</strong> &#8211; the coordinate of the points for all reach</li>
<li><strong>inter_height_all</strong> &#8211; the water height data given on the nodes for all reach</li>
<li><strong>inter_vel_all</strong> &#8211; the velcoity given on the nodes for all reach</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the update connectivity table, the coodinate of the point, the height of the water and the
velocity on the updated grid fro all reaches</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.find_profile_between">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">find_profile_between</code><span class="sig-paren">(</span><em>coord_pro_p0</em>, <em>coord_pro_p1</em>, <em>nb_pro</em>, <em>trim=True</em>, <em>divgiv=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.find_profile_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Find n profile between two profiles which are not straight. This functions is useful to create the grid from 1D model
as profile in 1D model are often far away from another.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coord_pro_p0</strong> &#8211; the coord_pro (x,y,h, z) of the first profile</li>
<li><strong>coord_pro_p1</strong> &#8211; the coord_pro (x,y,h, z) of the second profile</li>
<li><strong>nb_pro</strong> &#8211; the number of profile to add</li>
<li><strong>trim</strong> &#8211; If True cut the end and start of profile to avoid to have part of the grid outside of the water limit</li>
<li><strong>divgiv</strong> &#8211; one value by profile, used to not put the middle profile at an euql distance of two profile</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list with the updated profiles</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.get_crossing_segment_sub">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">get_crossing_segment_sub</code><span class="sig-paren">(</span><em>p1sub, p2sub, lim_here, lim_by_reachr, point_all, island, ind_seg_sub_ini=[0]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.get_crossing_segment_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>This function looks at one substrate segment and find the crossing points of this semgent with the different
segment which composed the hydrological grid. This function is useful to cut the grid as a function of the form
of the substrate layer (to avoid having cells in the hydrological grid which have two substrate value).</p>
<p>If island switch is True, lim_here is the limit of the island, so
inside the polygon is outside the river. If island is false, lim_here is the limit of the reach under investigation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p1sub</strong> &#8211; the start point of the substrate semgent</li>
<li><strong>p2sub</strong> &#8211; the end point of the substrate segment</li>
<li><strong>lim_here</strong> &#8211; the reach?island limit given in the coordinate system</li>
<li><strong>lim_by_reachr</strong> &#8211; the limits for reach r which will be given to triangle given by point_all indices.</li>
<li><strong>point_all</strong> &#8211; all the point (ccordinates) which will be given to triangle</li>
<li><strong>island</strong> &#8211; a boolean indicating if we are on an island or not</li>
<li><strong>ind_seg_sub_ini</strong> &#8211; the indices of the first segment add by p1sub et p2sub by the reach. Only used island = true</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the updated point_all and lim_by_reach</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.get_new_point_and_cell_1_profil">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">get_new_point_and_cell_1_profil</code><span class="sig-paren">(</span><em>coord_pro_p</em>, <em>vh_pro_t_p</em>, <em>point_mid_x</em>, <em>point_mid_y</em>, <em>point_all</em>, <em>ikle</em>, <em>point_c</em>, <em>dir</em>, <em>h0ok=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.get_new_point_and_cell_1_profil" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is use by create_grid_one_profile. It creates the grid for one profile (one &#8220;line&#8221; of triangle).
To create the whole grod this function is called for each profile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coord_pro_p</strong> &#8211; the coordinates of the profile</li>
<li><strong>vh_pro_t_p</strong> &#8211; the height and velocity data of the profile analysed</li>
<li><strong>point_mid_x</strong> &#8211; the x coodinate of the points forming the middle profile</li>
<li><strong>point_mid_y</strong> &#8211; the y coordinate of the points forming the middle profile</li>
<li><strong>point_all</strong> &#8211; the point of the grid</li>
<li><strong>ikle</strong> &#8211; the connectivity table of the grid</li>
<li><strong>point_c</strong> &#8211; the central point of each cell</li>
<li><strong>dir</strong> &#8211; in which direction are we going around the profile (upstream/downstram)</li>
<li><strong>h0ok</strong> &#8211; if True, cell with a water height or a velocity of zero are kept</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">point_all, ikle, point_c (the centroid of the cell)</p>
</td>
</tr>
</tbody>
</table>
<p>For more info, see the document &#8220;More info on the grid&#8221;.</p>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.grid_and_interpo">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">grid_and_interpo</code><span class="sig-paren">(</span><em>vh_pro</em>, <em>coord_pro</em>, <em>nb_pro_reach</em>, <em>interpo_choice</em>, <em>pro_add=1</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.grid_and_interpo" title="Permalink to this definition">¶</a></dt>
<dd><p>This function forms the link between GUI and the various grid and interpolation functions. Is called by
the &#8220;loading&#8221; function of hec-ras 1D, Mascaret and Rubar BE. It used to be a method in hydro_GUI2, but we have
to move it as a function to create a second thread. Hence, the high amount of parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>vh_pro</strong> &#8211; Velcoity and height data</li>
<li><strong>coord_pro</strong> &#8211; the position of the profile</li>
<li><strong>nb_pro_reach</strong> &#8211; the number of profile by reach</li>
<li><strong>interpo_choice</strong> &#8211; an int which gives the choice of interpolatin (see below)</li>
<li><strong>pro_add</strong> &#8211; the number of profile for be added (for interpoation method 1 and 2)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>Here are the list of the interpolation choice:</p>
<ul class="simple">
<li>0 Use the function create_grid_only_1_profile() from manage_grid_8.py for all time steps.</li>
<li>1 Use the function create_grid() from manage_grid_8.py for all time steps followed by a linear interpolation</li>
<li>2 Use the function create_grid() from manage_grid_8.py for all time steps followed by a nearest neighbour interpolation</li>
<li><dl class="first docutils">
<dt>3 Use create_grid() for the whole profile, make a linear inteporlation on this grid for all time step</dt>
<dd>and use the cut_2d_grid to get a grid with only the wet profile for all time step (This part was only started.
It was not finished.)</dd>
</dl>
</li>
</ul>
<p>For the interpolation case 1 and 2, it is possible that the triangle module crashes if the geometry of the
river is too complicated. Generally, the interpolation method 1 and 2 gives smoother results with more control
over the interpolation option and the size of the cells. However, these two interpolation methods are more sensitive
to the inputs, especially if the river has a lot of &#8220;island&#8221; (strongly anastomotic). So the interpoliation method 0
is more adequate in this case.</p>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.inside_polygon">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">inside_polygon</code><span class="sig-paren">(</span><em>seg_poly</em>, <em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.inside_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>This function find if a point is inside a polygon, using a ray casting algorythm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>seg_poly</strong> &#8211; the segmentS forming the polygon</li>
<li><strong>point</strong> &#8211; the point which is indide or outside the polygon</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True is the point is inside the polygon, false otherwise</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.interp_weights">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">interp_weights</code><span class="sig-paren">(</span><em>xyz</em>, <em>uvw</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.interp_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>This fucntion is used by the function pass_grid_cell_to_node_lin(). To optimize the interpolation when more than one time step
is done on the same grid, the first step of scipy.griddata.interolate are done here and are called only once for all
time step. Hence, this function is the first part of a quicker &#8220;scipy.interpolate.griddata&#8221;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>xyz</strong> &#8211; </li>
<li><strong>uvw</strong> &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.interpo_linear">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">interpo_linear</code><span class="sig-paren">(</span><em>point_all</em>, <em>coord_pro</em>, <em>vh_pro_t</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.interpo_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Using scipy.gridata, this function interpolates the 1.5 D velocity and height to the new grid
It can be used for only one time step. The interpolation is linear.
It is usually called after create_grid have been called.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>point_all</strong> &#8211; the coordinate of the grid point</li>
<li><strong>coord_pro</strong> &#8211; the coordinate of the profile. It should be coherent with the coordinate from vh_pro.
To insure this, pass coord_pro through the function &#8220;create_grid&#8221; with the same vh_pro as input</li>
<li><strong>vh_pro_t</strong> &#8211; for each profile, dist along the profile, water height and velocity at a particular time step</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the new interpolated data for velocity and water height</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.interpo_nearest">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">interpo_nearest</code><span class="sig-paren">(</span><em>point_all</em>, <em>coord_pro</em>, <em>vh_pro_t</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.interpo_nearest" title="Permalink to this definition">¶</a></dt>
<dd><p>Using scipy.gridata, this function interpolates the 1.5 D velocity and height to the new grid
It can be used for only one time step. The interpolation is nearest neighbours.
It is usually called after create_grid have been called.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>point_all</strong> &#8211; the coordinate of the grid point</li>
<li><strong>coord_pro</strong> &#8211; the coordinate of the profile. It should be coherent with the coordinate from vh_pro.
To insure this, pass coord_pro through the function &#8220;create_grid&#8221; with the same vh_pro as input</li>
<li><strong>vh_pro_t</strong> &#8211; for each profile, dist along the profile, water height and velocity at a particular time step</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the new interpolated data for velocity and water height</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.interpolate_opti">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">interpolate_opti</code><span class="sig-paren">(</span><em>values</em>, <em>vtx</em>, <em>wts</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.interpolate_opti" title="Permalink to this definition">¶</a></dt>
<dd><p>This fucntion is called by interp_weights(). It is used in the optimization of the function pass_grid_cell_to_node_lin().
This idea of this optimization is to not re-do some calculation when many interpolation are done on the same grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>values</strong> &#8211; </li>
<li><strong>vtx</strong> &#8211; </li>
<li><strong>wts</strong> &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.intersection_seg">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">intersection_seg</code><span class="sig-paren">(</span><em>p1hyd</em>, <em>p2hyd</em>, <em>p1sub</em>, <em>p2sub</em>, <em>col=True</em>, <em>wig=1e-07</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.intersection_seg" title="Permalink to this definition">¶</a></dt>
<dd><p>This function finds if there is an intersection between two segment (AB and CD). Idea from :
<a class="reference external" href="http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect">http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect</a>
It is based on the caluclaion of the cross-product z= 0 for 2D</p>
<p>Careful there is many function using this function, so change here should be thought about. There is a precision
management, so everythion smaller than 10**-8 is ok</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p1hyd</strong> &#8211; point A</li>
<li><strong>p2hyd</strong> &#8211; point B</li>
<li><strong>p1sub</strong> &#8211; point C</li>
<li><strong>p2sub</strong> &#8211; point D</li>
<li><strong>col</strong> &#8211; if True, colinear segment crossed. If false, they do not cross</li>
<li><strong>wig</strong> &#8211; &#8220;wiggle room&#8221;, how precise should the calculation be (careful, complicated!)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">intersect (True or False) and the crossing point (if True, empty is False)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.linear_h_cross">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">linear_h_cross</code><span class="sig-paren">(</span><em>p1</em>, <em>p2</em>, <em>h1</em>, <em>h2</em>, <em>minwh=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.linear_h_cross" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is called by cut_2D_grid. It find the intersection point along a side of the triangle if part of a
cells is dry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p1</strong> &#8211; the coordinate (x,y) of the first point</li>
<li><strong>p2</strong> &#8211; the coordinate (x,y) of the first point</li>
<li><strong>h1</strong> &#8211; the water height at p1 (might be negative or positive)</li>
<li><strong>h2</strong> &#8211; the water height at p2 (might be negative or positive)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the intersection point</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.main">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module</p>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.newp">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">newp</code><span class="sig-paren">(</span><em>p0</em>, <em>p1</em>, <em>extra_pro</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.newp" title="Permalink to this definition">¶</a></dt>
<dd><p>This function find the start/end of the added profile. If only one profile is needed, it is just the
point in the middle of the start/end of the profile. If mroe than one profile is needed, there are linearly
distributed. This function only give the start and the end of the profile, the profile in full are constructed using
find_profile_between()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p0</strong> &#8211; the point at the profile p</li>
<li><strong>p1</strong> &#8211; the point at the profile p-1</li>
<li><strong>extra_pro</strong> &#8211; the number of extra profile needed</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the start/end of the new profile</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.pass_grid_cell_to_node_lin">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">pass_grid_cell_to_node_lin</code><span class="sig-paren">(</span><em>point_all</em>, <em>coord_c</em>, <em>vel_in</em>, <em>height_in</em>, <em>warn1=True</em>, <em>vtx_all=[]</em>, <em>wts_all=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.pass_grid_cell_to_node_lin" title="Permalink to this definition">¶</a></dt>
<dd><p>HABBY uses nodal information. Some hydraulic models have only ouput on the cells. This function pass
from cells information to nodal information. The interpolation is linear and the cell centroid is used as the
point where the cell information is carried. It can be used for one time step only.</p>
<p>This function is also used by hydraulic_chronic to pass from one discharge to another because each discharge
has it own grid. hence, we need to interpolate</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>point_all</strong> &#8211; the coordinates of grid points (new grid here)</li>
<li><strong>coord_c</strong> &#8211; the coordintes of the centroid of the cells (old grid here)</li>
<li><strong>vel_in</strong> &#8211; the velocity data by cell</li>
<li><strong>height_in</strong> &#8211; the height data by cell</li>
<li><strong>warn1</strong> &#8211; if True , show the warning (usually warn1 is True for t=0, False afterwards)</li>
<li><strong>vtx_all</strong> &#8211; if it exists it means than the same grid was interpolated before. This info can be reused to
speed up the interpolation of mulitple time step. (optional, need wts)</li>
<li><strong>wts_all</strong> &#8211; if it exists it means than the same grid was interpolated before. This info can be reused to
speed up the interpolation of mulitple time step. (optional, need vtx)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">velocity and height data by node</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical Comment</strong></p>
<p>This function can be very slow when a lot of time step needs to be interpolated if done directlty with
scipy.interpolate. It was optimized for this case:
<a class="reference external" href="http://stackoverflow.com/questions/20915502/speedup-scipy-griddata-for-multiple">http://stackoverflow.com/questions/20915502/speedup-scipy-griddata-for-multiple</a>-
interpolations-between-two-irregular-grids</p>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.plot_grid">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">plot_grid</code><span class="sig-paren">(</span><em>point_all_reach</em>, <em>ikle_all</em>, <em>lim_by_reach</em>, <em>hole_all</em>, <em>overlap</em>, <em>point_c_all=[]</em>, <em>inter_vel_all=[]</em>, <em>inter_h_all=[]</em>, <em>path_im=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.plot_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to plot a grid and the output. It is mosty used to debug the grid creation. Contrarily to the more
simple function plot_grid_simple, it is posible to plot the position of the holes (which indicates the dry area),
the limits of the reaches used by triangle, the overlap between two reaches, and so on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>point_all_reach</strong> &#8211; the grid point by reach</li>
<li><strong>ikle_all</strong> &#8211; the connectivity table by reach</li>
<li><strong>lim_by_reach</strong> &#8211; the segment giving the limits of the grid</li>
<li><strong>hole_all</strong> &#8211; the coordinates of the holes</li>
<li><strong>overlap</strong> &#8211; the point of each reach which are also on an other reach</li>
<li><strong>point_c_all</strong> &#8211; the centroid of each element</li>
<li><strong>inter_vel_all</strong> &#8211; the interpolated velocity for each reach</li>
<li><strong>inter_h_all</strong> &#8211; the interpolated height</li>
<li><strong>path_im</strong> &#8211; the path where to save the image</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.plot_grid_simple">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">plot_grid_simple</code><span class="sig-paren">(</span><em>point_all_reach</em>, <em>ikle_all</em>, <em>fig_opt</em>, <em>inter_vel_all=[]</em>, <em>inter_h_all=[]</em>, <em>path_im=[]</em>, <em>merge_case=False</em>, <em>time_step=0</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.plot_grid_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the function to plot grid output for one time step. The data is one the node. A more complicated function
exists to plot the grid and additional information (manage-grid_8.plot_grid()) in case there are needed to debug.
The present function only plot the grid and output without more information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>point_all_reach</strong> &#8211; the coordinate of the point. This is given by reaches.</li>
<li><strong>ikle_all</strong> &#8211; the connectivity table. This is given by reaches.</li>
<li><strong>inter_vel_all</strong> &#8211; the velcoity data. This is given by reaches.</li>
<li><strong>inter_h_all</strong> &#8211; the height data. This is given by reaches.</li>
<li><strong>path_im</strong> &#8211; the path where the figure should be saved</li>
<li><strong>merge_case</strong> &#8211; If True, we plot data from grid with merged substrate and hydrological data</li>
<li><strong>time_step</strong> &#8211; time step to be added to the title</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Param:</th><td class="field-body"><p class="first last">fig_opt: the dictionary with the different options to create the figures</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.manage_grid_8.update_coord_pro_with_vh_pro">
<code class="descclassname">src.manage_grid_8.</code><code class="descname">update_coord_pro_with_vh_pro</code><span class="sig-paren">(</span><em>coord_pro</em>, <em>vh_pro_t</em><span class="sig-paren">)</span><a class="headerlink" href="#src.manage_grid_8.update_coord_pro_with_vh_pro" title="Permalink to this definition">¶</a></dt>
<dd><p>The points describing the profile elevation and the points where velocity is measured might not be the same.
Additionally,part of the profile might be dry and we have added points giving the wetted limit in vh_pro_t. They were
are not in the original profil (coord_pro). In this function,
coord_pro is recalculated to account for these modicfications. It is used by create_grid() and
create_grid_one_profile, but only if vh_pro_t exists.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coord_pro</strong> &#8211; the original coord_pro</li>
<li><strong>vh_pro_t</strong> &#8211; the value and position of h and velcoity measurement with the river limits</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">updated coord_pro</p>
</td>
</tr>
</tbody>
</table>
<p>More information in the document &#8220;More info on the grid&#8221; (linked above)</p>
</dd></dl>

</div>
<div class="section" id="estimhab-source">
<h2>Estimhab -source<a class="headerlink" href="#estimhab-source" title="Permalink to this headline">¶</a></h2>
<p>in src/estimhab.py</p>
<p>The module contains the Estimhab model. For an explanation on the estimhab model, please see
the pdf document <a class="reference download internal" href="_downloads/estimhab2008.pdf" download=""><code class="xref download docutils literal"><span class="pre">estimhab2008</span></code></a></p>
<span class="target" id="module-src.estimhab"></span><dl class="function">
<dt id="src.estimhab.estimhab">
<code class="descclassname">src.estimhab.</code><code class="descname">estimhab</code><span class="sig-paren">(</span><em>qmes</em>, <em>width</em>, <em>height</em>, <em>q50</em>, <em>qrange</em>, <em>substrat</em>, <em>path_bio</em>, <em>fish_name</em>, <em>path_im</em>, <em>pict=False</em>, <em>fig_opt={}</em>, <em>path_txt=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.estimhab.estimhab" title="Permalink to this definition">¶</a></dt>
<dd><p>This the function which forms the Estimhab model in HABBY. It is a reproduction in python of the excel file which
forms the original Estimhab model.. Unit in meter amd m^3/sec</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>qmes</strong> &#8211; the two measured discharge</li>
<li><strong>width</strong> &#8211; the two measured width</li>
<li><strong>height</strong> &#8211; the two measured height</li>
<li><strong>q50</strong> &#8211; the natural median discharge</li>
<li><strong>qrange</strong> &#8211; the range of discharge</li>
<li><strong>substrat</strong> &#8211; mean height of substrat</li>
<li><strong>path_im</strong> &#8211; the path where the image should be saved</li>
<li><strong>path_bio</strong> &#8211; the path to the xml file with the information on the fishes</li>
<li><strong>fish_name</strong> &#8211; the name of the fish which have to be analyzed</li>
<li><strong>pict</strong> &#8211; if true the figure is shown. If false, the figure is not shown</li>
<li><strong>fig_opt</strong> &#8211; a dictionnary with the figure option</li>
<li><strong>path_txt</strong> &#8211; the path where to send the text data</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">habitat value and useful surface (VH and SPU) as a function of discharge</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments and walk-through</strong></p>
<p>First, we get all the discharges on which we want to calculate the SPU (surface ponderée utile),
using the inputs from the user.</p>
<p>Next we use hydrological rating curves (info on google if needed) to get the height and the width of the river for
all discharge. The calculation is based on the width and height of the river measured at two discharges (given by the
user).</p>
<p>Next, we get other parameters which are used in the preference curves such as the Froude number of
the mean discharge or the Reynolds number.</p>
<p>Next, we load the fish data contains in the xml files in the biology folder. Careful, this is not the xml project
file. This are the xml files described above in the “Class EstimhabW” section. There are one xml file per fish and
they described the preference curves. For the argumentation on the form of the relationship, report yourself to the
documentation of Estimhab (one pdf file should in the folder “doc “ in HABBY).</p>
<p>Then, we calculate the habitat values (VH and SPU). Finally, we plot the results in a figure and we save it as
a text file.</p>
</dd></dl>

<dl class="function">
<dt id="src.estimhab.main">
<code class="descclassname">src.estimhab.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.estimhab.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module.</p>
</dd></dl>

<dl class="function">
<dt id="src.estimhab.pass_to_float_estimhab">
<code class="descclassname">src.estimhab.</code><code class="descname">pass_to_float_estimhab</code><span class="sig-paren">(</span><em>var_name</em>, <em>root</em><span class="sig-paren">)</span><a class="headerlink" href="#src.estimhab.pass_to_float_estimhab" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to pass from an xml element to a float</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>root</strong> &#8211; the root of the open xml file</li>
<li><strong>var_name</strong> &#8211; the name of the attribute in the xml file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the float data</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="stathab-source">
<h2>Stathab - source<a class="headerlink" href="#stathab-source" title="Permalink to this headline">¶</a></h2>
<p>in src/stathab_c</p>
<p>This module contains the function used to run the model stathab.For an explanation on
the form of the stathab input, please see the pdf document <a class="reference download internal" href="_downloads/stathabinfo.pdf" download=""><code class="xref download docutils literal"><span class="pre">stathabinfo</span></code></a></p>
<span class="target" id="module-src.stathab_c"></span><dl class="class">
<dt id="src.stathab_c.Stathab">
<em class="property">class </em><code class="descclassname">src.stathab_c.</code><code class="descname">Stathab</code><span class="sig-paren">(</span><em>name_prj</em>, <em>path_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab" title="Permalink to this definition">¶</a></dt>
<dd><p>The class for the Stathab model</p>
<dl class="method">
<dt id="src.stathab_c.Stathab.create_hdf5">
<code class="descname">create_hdf5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.create_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to create an hdf5 file from the loaded txt. It creates &#8220;name_prj&#8221;_STATHAB.h5, an hdf5 file with the
info from stathab</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.dengauss">
<code class="descname">dengauss</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.dengauss" title="Permalink to this definition">¶</a></dt>
<dd><p>gaussian density, used only for debugging purposes.
This is not used in Habby, but can be useful if scipy is not available (remplace all stat.norm.cdf with
dengauss)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> &#8211; the parameter of the gaussian</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the gaussian density</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.dist_h">
<code class="descname">dist_h</code><span class="sig-paren">(</span><em>sh0</em>, <em>h0</em>, <em>bornh</em>, <em>h</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.dist_h" title="Permalink to this definition">¶</a></dt>
<dd><p>The calculation of height distribution  acrros the river
The distribution is a mix of an exponential and guassian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sh0</strong> &#8211; the sh of the original data
sh is the parameter of the distribution, gives the relative importance of ganussian and exp distrbution</li>
<li><strong>h</strong> &#8211; the mean height data</li>
<li><strong>h0</strong> &#8211; the mean height</li>
<li><strong>bornh</strong> &#8211; the limits of each class of height</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">disth the distribution of heights across the river for the mean height h.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.dist_h_trop">
<code class="descname">dist_h_trop</code><span class="sig-paren">(</span><em>v</em>, <em>h</em>, <em>mean_slope</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.dist_h_trop" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calulate the height distribution for steep tropical stream based on the R code from
Girard et al. (stathab_hyd_steep). The frequency distribution is based on empirical data which
is given in the list of numbers in the codes below. The final frequency distribution is in the form:
t xf1 + (1-t) x f where t is a function of the froude number and the mean slope of the station.</p>
<p>The height limits are considered constant here (constrarily to dist_h where they are given in the parameter
bornh).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>v</strong> &#8211; the velcoity for this discharge</li>
<li><strong>h</strong> &#8211; the height for this discharge</li>
<li><strong>mean_slope</strong> &#8211; the mean slope of the station (usally in the data_ii[0] variable)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the distribution of height</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.dist_v">
<code class="descname">dist_v</code><span class="sig-paren">(</span><em>h</em>, <em>d</em>, <em>bornv</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.dist_v" title="Permalink to this definition">¶</a></dt>
<dd><p>The calculation of velocity distribution across the river
The distribution is a mix of an exponential and guassian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>h</strong> &#8211; the height which is related to the mean velocity v</li>
<li><strong>d</strong> &#8211; granulo moyenne</li>
<li><strong>bornv</strong> &#8211; the born of the velocity</li>
<li><strong>v</strong> &#8211; the mean velocity</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the distribution of velocity across the river</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.dist_v_trop">
<code class="descname">dist_v_trop</code><span class="sig-paren">(</span><em>v</em>, <em>h</em>, <em>h_waterfall</em>, <em>length_stat</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.dist_v_trop" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calulate the velocity distribution for steep tropical stream based on the R code from
Girard et al. (stathab_hyd_steep). The frequency distribution is based on empirical data which
is given in the list of numbers in the codes below. The final frequency distribution is in the form:
t x f1 + (1-t) x f where t depends on the ratio of the length of station and the height of the waterfall.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>v</strong> &#8211; the velcoity for this discharge</li>
<li><strong>h</strong> &#8211; the height for this discharge</li>
<li><strong>h_waterfall</strong> &#8211; the height of the waterfall</li>
<li><strong>length_stat</strong> &#8211; the length of the station</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the distribution of velocity</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.find_path_hdf5_stat">
<code class="descname">find_path_hdf5_stat</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.find_path_hdf5_stat" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to find the path where to save the hdf5 file. Careful a simialar one is in hydro_GUI_2.py
and in estimhab_GUI. By default,
path_hdf5 is in the project folder in the folder &#8216;fichier_hdf5&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.find_sh0">
<code class="descname">find_sh0</code><span class="sig-paren">(</span><em>disthmesr</em>, <em>h0</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.find_sh0" title="Permalink to this definition">¶</a></dt>
<dd><p>the function to find sh0, using a minimzation technique. Not used because the output was string.
Possibly an error on the bornes? We remplaced this function by the function find_sh0_maxvrais().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>disthmesr</strong> &#8211; the measured distribution of height</li>
<li><strong>h0</strong> &#8211; the measured mean height</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the optimized sh0</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.find_sh0_maxvrais">
<code class="descname">find_sh0_maxvrais</code><span class="sig-paren">(</span><em>disthmesr</em>, <em>h0</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.find_sh0_maxvrais" title="Permalink to this definition">¶</a></dt>
<dd><p>the function to find sh0, using the maximum of vraisemblance.
This function aims at reproducing the results from the c++ code. Hence, no use of scipy</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>disthmesr</strong> &#8211; the measured distribution of height</li>
<li><strong>h0</strong> &#8211; the measured mean height</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the optimized sh0</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.load_stathab_from_hdf5">
<code class="descname">load_stathab_from_hdf5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.load_stathab_from_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to load the file from an hdf5 whose name is given in the xml project file. If the name of the
file is a relative path, use the path_prj to create an absolute path.</p>
<p>It works for tropical and temperate rivers. It checks the river type in the hdf5  files and
used this river type regardless of the one curently used by the GUI. The method load_hdf5 in stathab_GUI
get the value of self.riverint from the object mystathab to check the cohrenence between the GUI and the loaded
hdf5.</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.load_stathab_from_txt">
<code class="descname">load_stathab_from_txt</code><span class="sig-paren">(</span><em>reachname_file</em>, <em>end_file_reach</em>, <em>name_file_allreach</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.load_stathab_from_txt" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to read and check the input from stathab based on the text files.
All files should be in the same folder.
The file Pref.txt is read in run_stathab.
If self.fish_chosen is not present, all fish in the preference file are read.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>reachname_file</strong> &#8211; the file with the name of the reaches to study (usually listirv)</li>
<li><strong>end_file_reach</strong> &#8211; the ending of the files whose names depends on the reach (with .txt or .csv)</li>
<li><strong>name_file_allreach</strong> &#8211; the name of the file common to all reaches</li>
<li><strong>path</strong> &#8211; the path to the file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the inputs needed for run_stathab</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.power_law">
<code class="descname">power_law</code><span class="sig-paren">(</span><em>qwh_r</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.power_law" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to calculate power law for discharge and width
ln(h0 = a1 + a2 ln(Q)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>qwh_r</strong> &#8211; an array where each line in one observatino of Q, width and height</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the coeff of the regression</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.save_xml_stathab">
<code class="descname">save_xml_stathab</code><span class="sig-paren">(</span><em>no_hdf5=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.save_xml_stathab" title="Permalink to this definition">¶</a></dt>
<dd><p>The function which saves the function related to stathab in the xml projexct files</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>no_hdf5</strong> &#8211; If True, no hdf5 file was created (usually because Stathab crashed at some points)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.savefig_stahab">
<code class="descname">savefig_stahab</code><span class="sig-paren">(</span><em>show_class=True</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.savefig_stahab" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to save the results in text and the figure. If the argument show_class is True,
it shows an extra figure with the size of the different height, granulo, and velocity classes. The optional
figure only works when stathab1 for temperate river is used.</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.savetxt_stathab">
<code class="descname">savetxt_stathab</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.savetxt_stathab" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to save the stathab result in .txt form</p>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.stathab_calc">
<code class="descname">stathab_calc</code><span class="sig-paren">(</span><em>path_pref='.'</em>, <em>name_pref='Pref.txt'</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.stathab_calc" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to calculate stathab output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path_pref</strong> &#8211; the path to the preference file</li>
<li><strong>name_pref</strong> &#8211; the name of the preference file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the biological preferrence index (np.array of [reach, specices, nbclaq] size), surface or volume by class, etc.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.stathab_trop_biv">
<code class="descname">stathab_trop_biv</code><span class="sig-paren">(</span><em>path_bio</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.stathab_trop_biv" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculate the stathab outputs  for the bivariate preference file in the case where the river is
steep and in the tropical regions (usually the islands of Reunion and Guadeloupe).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path_bio</strong> &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.stathab_trop_univ">
<code class="descname">stathab_trop_univ</code><span class="sig-paren">(</span><em>path_bio</em>, <em>by_vol</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.stathab_trop_univ" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculate the stathab outputs  for the univariate preference file in the case where the river is
steep and in the tropical regions (usually the islands of Reunion and Guadeloupe).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path_bio</strong> &#8211; the path to the preference file usually biology/stathab</li>
<li><strong>by_vol</strong> &#8211; If True the output is by volum (VPU instead of SPU) from the velcoity pref file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the SPU or VPU</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.test_stathab">
<code class="descname">test_stathab</code><span class="sig-paren">(</span><em>path_ori</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.test_stathab" title="Permalink to this definition">¶</a></dt>
<dd><p>A short function to test part of the outputs of stathab in temperate rivers against the C++ code,
It is not used in Habby but it is practical to debug.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path_ori</strong> &#8211; the path to the files from stathab based on the c++ code</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.test_stathab_trop_biv">
<code class="descname">test_stathab_trop_biv</code><span class="sig-paren">(</span><em>path_ori</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.test_stathab_trop_biv" title="Permalink to this definition">¶</a></dt>
<dd><p>A short function to test part of the outputs of the stathab tropical rivers against the R code
in the bivariate mode. It is not used in Habby but it is practical to debug. Stathab_trop+biv should be
executed before. For the moment only the fish SIC is tested.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path_ori</strong> &#8211; the path to the output files from stathab based on the R code</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="src.stathab_c.Stathab.test_stathab_trop_uni">
<code class="descname">test_stathab_trop_uni</code><span class="sig-paren">(</span><em>path_ori</em>, <em>by_vel=True</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.Stathab.test_stathab_trop_uni" title="Permalink to this definition">¶</a></dt>
<dd><p>A short function to test part of the outputs of the stathab tropical rivers against the R code
in the univariate mode. It is not used in Habby but it is practical to debug. Stathab_trop_uni should be
executed before. For the moment only the fish SIC is tested.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path_ori</strong> &#8211; the path to the output files from stathab based on the R code</li>
<li><strong>by_vel</strong> &#8211; If True, the velcoity-based vpu is used. Otherise, it is height-based spu</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="src.stathab_c.load_float_stathab">
<code class="descclassname">src.stathab_c.</code><code class="descname">load_float_stathab</code><span class="sig-paren">(</span><em>filename</em>, <em>check_neg</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.load_float_stathab" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to load float with extra checks</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> &#8211; the file to load with the path</li>
<li><strong>check_neg</strong> &#8211; if true negative value are not allowed in the data</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">data if ok, -99 if failed</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.stathab_c.load_namereach">
<code class="descclassname">src.stathab_c.</code><code class="descname">load_namereach</code><span class="sig-paren">(</span><em>path</em>, <em>name_file_reach='listriv'</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.load_namereach" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to only load the reach names (useful for the GUI). The extension must be .txt or .csv</p>
<p>:param path : the path to the file listriv.txt or listriv.csv
:param name_file_reach: In case the file name is not listriv
:return: the list of reach name</p>
</dd></dl>

<dl class="function">
<dt id="src.stathab_c.load_pref">
<code class="descclassname">src.stathab_c.</code><code class="descname">load_pref</code><span class="sig-paren">(</span><em>filepref</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.load_pref" title="Permalink to this definition">¶</a></dt>
<dd><p>The function loads the different pref coeffficient contained in filepref, for the temperate river from Stathab</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filepref</strong> &#8211; the name of the file (usually Pref.txt)</li>
<li><strong>path</strong> &#8211; the path to this file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the name of the fish, a np.array with the differen coeff</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.stathab_c.load_pref_trop_biv">
<code class="descclassname">src.stathab_c.</code><code class="descname">load_pref_trop_biv</code><span class="sig-paren">(</span><em>code_fish</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.load_pref_trop_biv" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the bivariate preference files for tropical rivers. The name of the file must be in the form
of xbiv_XXX.csv where XXX is the three-letters fish code and x is whatever string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>code_fish</strong> &#8211; the code for the fish name in three letters (such as ASC)</li>
<li><strong>path</strong> &#8211; the path to files</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the bivariate preferences</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.stathab_c.load_pref_trop_uni">
<code class="descclassname">src.stathab_c.</code><code class="descname">load_pref_trop_uni</code><span class="sig-paren">(</span><em>code_fish</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.load_pref_trop_uni" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the preference files for the univariate data. The file with the univariate data should be in the
form of xuni-h_XXX where XX is the fish code and x is whatever string. The assumption is that the filename for
velocity is very similar to the filename for height. In more detail that the string uni-h is changed to uni-v in
the filename. Otherwise, the file are csv file with two columns: First is velocity or height,
the second is the preference data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>code_fish</strong> &#8211; the code for the fish name in three letters (such as ASC)</li>
<li><strong>path</strong> &#8211; the path to files</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the height data and velcoity data (h, pref) and (v,pref)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.stathab_c.main">
<code class="descclassname">src.stathab_c.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.stathab_c.main" title="Permalink to this definition">¶</a></dt>
<dd><p>used to test this module.</p>
</dd></dl>

</div>
<div class="section" id="fstress-source">
<h2>FStress - source<a class="headerlink" href="#fstress-source" title="Permalink to this headline">¶</a></h2>
<p>in src/fstress.py</p>
<p>This module contains the function used to run the model FStress.For an explanation on
the form of the FStress text input, please see the last page of the pdf document <a class="reference download internal" href="_downloads/stathabinfo.pdf" download=""><code class="xref download docutils literal"><span class="pre">stathabinfo</span></code></a></p>
<span class="target" id="module-src.fstress"></span><dl class="function">
<dt id="src.fstress.denstress">
<code class="descclassname">src.fstress.</code><code class="descname">denstress</code><span class="sig-paren">(</span><em>k</em>, <em>m</em>, <em>nbst</em><span class="sig-paren">)</span><a class="headerlink" href="#src.fstress.denstress" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calulates the stress distrbution function for FStress. This distribution has generally the form
of k*exp() + (1-k)* Sigma(x-m)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>k</strong> &#8211; the first parameter of the distribution</li>
<li><strong>m</strong> &#8211; the second parameter of the disitribution</li>
<li><strong>nbst</strong> &#8211; the number of stress class in the distribution</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the stress disitrbution for the (m,k) parameters</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.fstress.figure_fstress">
<code class="descclassname">src.fstress.</code><code class="descname">figure_fstress</code><span class="sig-paren">(</span><em>qmod_all</em>, <em>vh_all</em>, <em>name_inv</em>, <em>path_im</em>, <em>name_river</em>, <em>fig_opt={}</em><span class="sig-paren">)</span><a class="headerlink" href="#src.fstress.figure_fstress" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates the figures for Fstress, notably the suitability index as a function of discharge for all
rivers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>qmod_all</strong> &#8211; the modelled discharge for each river</li>
<li><strong>vh_all</strong> &#8211; the suitability indoex for each invertebrate species for each river</li>
<li><strong>name_inv</strong> &#8211; The four letter code of each selected invetebrate</li>
<li><strong>path_im</strong> &#8211; the path where to save the figure</li>
<li><strong>name_river</strong> &#8211; the name of the river</li>
<li><strong>fig_opt</strong> &#8211; the figure option in a dictionnary</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.fstress.fstress_test">
<code class="descclassname">src.fstress.</code><code class="descname">fstress_test</code><span class="sig-paren">(</span><em>qmod_all</em>, <em>vh_all</em>, <em>name_inv</em>, <em>name_river</em>, <em>path_rre</em>, <em>fig_opt={}</em><span class="sig-paren">)</span><a class="headerlink" href="#src.fstress.fstress_test" title="Permalink to this definition">¶</a></dt>
<dd><p>This functions compares the output of the C programm of FStress and the output of this script. it is not used
by HABBY, but it is practical to debug.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>qmod_all</strong> &#8211; the modelled discharge for each river</li>
<li><strong>vh_all</strong> &#8211; the suitability indoex for each invertebrate species for each river</li>
<li><strong>name_inv</strong> &#8211; The four letter code of each selected invetebrate</li>
<li><strong>name_river</strong> &#8211; the name of the river</li>
<li><strong>path_rre</strong> &#8211; the path to the C output</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.fstress.func_stress">
<code class="descclassname">src.fstress.</code><code class="descname">func_stress</code><span class="sig-paren">(</span><em>vm</em>, <em>h</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#src.fstress.func_stress" title="Permalink to this definition">¶</a></dt>
<dd><p>This functions calculates the distrbution of stress on the bottom of the river based of height and velocity
at one discharge. In other word, it calculate the distrbution of the &#8220;hemispheres&#8221;.
This function is mainly a copy of stress function contains in the vitess2.c of the C source of FStress.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>vm</strong> &#8211; the velocity for this diacharge value</li>
<li><strong>h</strong> &#8211; the height for this discharge value</li>
<li><strong>tau</strong> &#8211; the constraint values</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the stress distribution for this discharge</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.fstress.main">
<code class="descclassname">src.fstress.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.fstress.main" title="Permalink to this definition">¶</a></dt>
<dd><p>This is not the main() of HABBY. This local function is used to test the Fstress model.</p>
</dd></dl>

<dl class="function">
<dt id="src.fstress.read_fstress_hdf5">
<code class="descclassname">src.fstress.</code><code class="descname">read_fstress_hdf5</code><span class="sig-paren">(</span><em>hdf5_name</em>, <em>hdf5_path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.fstress.read_fstress_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>This functions reads an hdf5 file related to FStress and extract the relevant information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hdf5_name</strong> &#8211; the name of the hdf5 file with the information realted to FStress</li>
<li><strong>hdf5_path</strong> &#8211; the path to this file</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return:[[q,w,h], [q,w,h]] for each river, [qmin,qmax] for each river, the river names, and the selected fish</p>
</dd></dl>

<dl class="function">
<dt id="src.fstress.read_pref">
<code class="descclassname">src.fstress.</code><code class="descname">read_pref</code><span class="sig-paren">(</span><em>path_bio</em>, <em>name_bio</em><span class="sig-paren">)</span><a class="headerlink" href="#src.fstress.read_pref" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads and read the preference file for FStress.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path_bio</strong> &#8211; the path to the preference file</li>
<li><strong>name_bio</strong> &#8211; the name of the preference file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the name invertebrate and their preference coefficient</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.fstress.run_fstress">
<code class="descclassname">src.fstress.</code><code class="descname">run_fstress</code><span class="sig-paren">(</span><em>data_hydro</em>, <em>qrange</em>, <em>riv_name</em>, <em>inv_select</em>, <em>pref_all</em>, <em>name_all</em>, <em>name_prj</em>, <em>path_prj</em><span class="sig-paren">)</span><a class="headerlink" href="#src.fstress.run_fstress" title="Permalink to this definition">¶</a></dt>
<dd><p>This function run the model FStress for HABBY. FStress is based on the model of Nicolas Lamouroux. This model
estimates suitability indices for invertebrate in relation with shear stress distributions. However, shear stress
do not needs to be measured. It is statistically estimated based on velocity and height measurement.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>riv_name</strong> &#8211; the name of the river-&gt; string</li>
<li><strong>data_hydro</strong> &#8211; the hydrological data (q,w,h for each river in riv name) -&gt; list of list</li>
<li><strong>qrange</strong> &#8211; the qmin and qmax for each river [qmin,qmax] -&gt; list of list</li>
<li><strong>inv_select</strong> &#8211; the name of the selected invetebrate</li>
<li><strong>pref_all</strong> &#8211; the preference data for all invertebrate</li>
<li><strong>name_all</strong> &#8211; the four letter code of all possible invertebrate</li>
<li><strong>path_prj</strong> &#8211; the path to the project-&gt; string</li>
<li><strong>name_prj</strong> &#8211; the name of the project-&gt; string</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.fstress.save_fstress">
<code class="descclassname">src.fstress.</code><code class="descname">save_fstress</code><span class="sig-paren">(</span><em>path_hdf5</em>, <em>path_prj</em>, <em>name_prj</em>, <em>name_bio</em>, <em>path_bio</em>, <em>riv_name</em>, <em>data_hydro</em>, <em>qrange</em>, <em>fish_list</em><span class="sig-paren">)</span><a class="headerlink" href="#src.fstress.save_fstress" title="Permalink to this definition">¶</a></dt>
<dd><p>This function saves the data related to the fstress model in an hdf5 file and write the name of this hdf5 file
in the xml project file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path_hdf5</strong> &#8211; the path where to sdave the hdf5-&gt; string</li>
<li><strong>path_prj</strong> &#8211; the path to the project-&gt; string</li>
<li><strong>name_prj</strong> &#8211; the name of the project-&gt; string</li>
<li><strong>name_bio</strong> &#8211; the name of the preference file-&gt; string</li>
<li><strong>path_bio</strong> &#8211; the path to the preference file-&gt; string</li>
<li><strong>riv_name</strong> &#8211; the name of the river-&gt; string</li>
<li><strong>data_hydro</strong> &#8211; the hydrological data (q,w,h for each river in riv name) -&gt; list of list</li>
<li><strong>qrange</strong> &#8211; the qmin and qmax for each river [qmin,qmax] -&gt; list of list</li>
<li><strong>fish_list</strong> &#8211; the name of the selected invertebrate (! no fish) -&gt; list of string</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.fstress.write_txt">
<code class="descclassname">src.fstress.</code><code class="descname">write_txt</code><span class="sig-paren">(</span><em>qmod_all</em>, <em>vh_all</em>, <em>name_inv</em>, <em>path_txt</em>, <em>name_river</em><span class="sig-paren">)</span><a class="headerlink" href="#src.fstress.write_txt" title="Permalink to this definition">¶</a></dt>
<dd><p>This function writes the txt outputs for FStress</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>qmod_all</strong> &#8211; the modelled discharge for each river</li>
<li><strong>vh_all</strong> &#8211; the suitability indoex for each invertebrate species for each river</li>
<li><strong>name_inv</strong> &#8211; The four letter code of each selected invetebrate</li>
<li><strong>path_txt</strong> &#8211; the path where to save the text file</li>
<li><strong>name_river</strong> &#8211; the name of the river</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="substrate">
<h2>Substrate<a class="headerlink" href="#substrate" title="Permalink to this headline">¶</a></h2>
<p>in src/substrate.py</p>
<p>This module contains the function to load and manage the substrate data.</p>
<span class="target" id="module-src.substrate"></span><dl class="function">
<dt id="src.substrate.create_dummy_substrate_from_hydro">
<code class="descclassname">src.substrate.</code><code class="descname">create_dummy_substrate_from_hydro</code><span class="sig-paren">(</span><em>h5name</em>, <em>path</em>, <em>new_name</em>, <em>code_type</em>, <em>attribute_type</em>, <em>nb_point=200</em>, <em>path_out='.'</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.create_dummy_substrate_from_hydro" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes an hydrological hdf5 as inputs and create a shapefile of substrate and a text file of substrate
which can be used as input for habby. The substrate data is random. So it is mainly useful to test an hydrological
input.</p>
<p>The created shape file is rectangular with a size based on min/max of the hydrological coordinates. The substrate
grid is not the same as the hydrological grids (which is good to test the programm). In addition, one side of the shp
is smaller than the hydrological grid to test the &#8216;default substrate&#8217; option (which is used if the substrate
shapefile is not big enough).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>h5name</strong> &#8211; the name of the hydrological hdf5 file</li>
<li><strong>path</strong> &#8211; the path to this file</li>
<li><strong>new_name</strong> &#8211; the name of the create shape file wihtout the shp (string)</li>
<li><strong>code_type</strong> &#8211; the code type for the substrate (Sandre, Cemagref, Const_cemagref, or EDF). All subtrate value
to 4 for Const_cemagref.</li>
<li><strong>attribute_type</strong> &#8211; if the substrate is given in the type coarser/dominant/..(0) or in percenctage (1)</li>
<li><strong>nb_point</strong> &#8211; the number of point needed (more points results in smaller substrate form)</li>
<li><strong>path_out</strong> &#8211; the path where to save the new substrate shape</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.substrate.edf_to_cemagref">
<code class="descclassname">src.substrate.</code><code class="descname">edf_to_cemagref</code><span class="sig-paren">(</span><em>records</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.edf_to_cemagref" title="Permalink to this definition">¶</a></dt>
<dd><p>This function passes the substrate data from the code type &#8216;EDF&#8221; to the code type &#8220;Cemagref&#8221;. As the code 1 from EDF
can be the code 2 or code 1 in Cemagref, a code 1 in EDF is code 1 in Cemagref half of the time and code 2 the
other half of the time. This function is not optimized yet. For the definiction of the code, see the tabular at the 14
of the LAMMI manual. THIS IS NOT RIGHT AS CLASS ARE NOT SPEAREATED IDENTICALLY,  TO BE CORRECTED !!!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>records</strong> &#8211; the substrate data in code edf</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the substrate data in code cemagref</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.substrate.edf_to_cemagref_by_percentage">
<code class="descclassname">src.substrate.</code><code class="descname">edf_to_cemagref_by_percentage</code><span class="sig-paren">(</span><em>records</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.edf_to_cemagref_by_percentage" title="Permalink to this definition">¶</a></dt>
<dd><p>This function change the subtrate in a percetage form from edf code to cemagref code
:param records: the subtrate data (in 8x len tabular)
:return:</p>
</dd></dl>

<dl class="function">
<dt id="src.substrate.fig_substrate">
<code class="descclassname">src.substrate.</code><code class="descname">fig_substrate</code><span class="sig-paren">(</span><em>coord_p, ikle, sub_pg, sub_dom, path_im, fig_opt={}, xtxt=[-99], ytxt=[-99], subtxt=[-99]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.fig_substrate" title="Permalink to this definition">¶</a></dt>
<dd><p>The function to plot the substrate data, which was loaded before. This function will only work if the substrate
data is given using the cemagref code.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coord_p</strong> &#8211; the coordinate of the point</li>
<li><strong>ikle</strong> &#8211; the connectivity table</li>
<li><strong>sub_pg</strong> &#8211; the information on subtrate by element for the &#8220;coarser part&#8221;</li>
<li><strong>sub_dom</strong> &#8211; the information on subtrate by element for the &#8220;dominant part&#8221;</li>
<li><strong>fig_opt</strong> &#8211; the figure option as a doctionnary</li>
<li><strong>xtxt</strong> &#8211; if the data was given in txt form, the orignal x data</li>
<li><strong>ytxt</strong> &#8211; if the data was given in txt form, the orignal y data</li>
<li><strong>subtxt</strong> &#8211; if the data was given in txt form, the orignal sub data</li>
<li><strong>path_im</strong> &#8211; the path where to save the figure</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.substrate.get_all_attribute">
<code class="descclassname">src.substrate.</code><code class="descname">get_all_attribute</code><span class="sig-paren">(</span><em>filename</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.get_all_attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>This function open a shapefile and get the list of all the attibute which is contains in it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> &#8211; the name of the shpae file</li>
<li><strong>path</strong> &#8211; the path to this shapefile</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list with the name and information of all attribute. The form of each element of the list
is [name(str), type (F,N), int, int]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.substrate.get_useful_attribute">
<code class="descclassname">src.substrate.</code><code class="descname">get_useful_attribute</code><span class="sig-paren">(</span><em>attributes</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.get_useful_attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>This function find if the substrate was given in percentage or coarser/dominant/accesory and get the attribute
or header name useful to load the substrate. If the subtrate is given by percentage, it is important to get
attribute in order (S1, S2, S3) and not (S3, S1,S2) for this function and the next functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>attributes</strong> &#8211; The list of attribute from the shp file or the header list from the text file</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The attribute type as int (percentage=1 and coarser/... = 0 and failed = -99) and the attribute names
If we are in the attribute type 0, attribute list is in the order of: coarser, dominant, and accessory</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.substrate.load_sub_shp">
<code class="descclassname">src.substrate.</code><code class="descname">load_sub_shp</code><span class="sig-paren">(</span><em>filename</em>, <em>path</em>, <em>code_type</em>, <em>dominant_case=0</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.load_sub_shp" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to load the substrate in form of shapefile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> &#8211; the name of the shapefile</li>
<li><strong>path</strong> &#8211; the path where the shapefile is</li>
<li><strong>code_type</strong> &#8211; the type of code used to define the substrate (string)</li>
<li><strong>dominant_case</strong> &#8211; an int to manage the case where the transfomation form percentage to dominnat is unclear (two
maxinimum percentage are equal from one element). if -1 take the smallest, if 1 take the biggest,
if 0, we do not know.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">grid in form of list of coordinate and connectivity table (two list)
and an array with substrate type and a boolean which allows to get the case where we have tow dominant case</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.substrate.load_sub_txt">
<code class="descclassname">src.substrate.</code><code class="descname">load_sub_txt</code><span class="sig-paren">(</span><em>filename</em>, <em>path</em>, <em>code_type</em>, <em>path_shp='.'</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.load_sub_txt" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to load the substrate in form of a text file. The text file must have 4 columns x,y coordinate and
coarser substrate type, dominant substrate type, no header or title. It is transform to a grid using a voronoi
transformation.</p>
<p>The voronoi transformation might look strange as it is often bigger than theorginal point. However, this is
just the mathematical result.</p>
<p>At the end of this fnuction, the resulting grid is exported in a shapefile form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> &#8211; the name of the shapefile</li>
<li><strong>path</strong> &#8211; the path where the shapefile is</li>
<li><strong>code_type</strong> &#8211; the type of code used to define the substrate (string)</li>
<li><strong>path_shp</strong> &#8211; the path where to save the shapefile (usually the input folder)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">grid in form of list of coordinate and connectivity table (two list)
and an array with substrate type and (x,y,sub) of the orginal data</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.substrate.main">
<code class="descclassname">src.substrate.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module.</p>
</dd></dl>

<dl class="function">
<dt id="src.substrate.modify_grid_if_concave">
<code class="descclassname">src.substrate.</code><code class="descname">modify_grid_if_concave</code><span class="sig-paren">(</span><em>ikle</em>, <em>point_all</em>, <em>sub_pg</em>, <em>sub_dom</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.modify_grid_if_concave" title="Permalink to this definition">¶</a></dt>
<dd><p>This function check if the grid in entry is composed of convex cell. Indeed, it is possible to have concave
cells in the substrate grid. However, this is unpractical when the hydrological grid is merged with the subtrate
grid. Hence, we find here the concave cells. These cells are then modified using the triangle module.</p>
<p>The algotithm is based on the idea that when you have a convex polygon you turn always in the same direction.
When you have a concave polygon sometime you will turn left, sometime you will turn right. To check this,
we can take the determinant betwen each vector which compose the cells and check if they have the same sign.
Triangle are always convex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ikle</strong> &#8211; the connectivity table of the grid (one reach, one time step as substrate grid is constant)</li>
<li><strong>point_all</strong> &#8211; the point of the grid</li>
<li><strong>sub_pg</strong> &#8211; the coarser substrate, one data by cell</li>
<li><strong>sub_dom</strong> &#8211; the dominant subtrate, one data by cell</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">ikle, point_all with only convexe cells</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.substrate.open_shp">
<code class="descclassname">src.substrate.</code><code class="descname">open_shp</code><span class="sig-paren">(</span><em>filename</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.open_shp" title="Permalink to this definition">¶</a></dt>
<dd><p>This function open a ArcGIS shpaefile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> &#8211; the name of the shapefile</li>
<li><strong>path</strong> &#8211; the path to this shapefile</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a shapefile object as define in the model</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.substrate.percentage_to_domcoarse">
<code class="descclassname">src.substrate.</code><code class="descname">percentage_to_domcoarse</code><span class="sig-paren">(</span><em>sub_data</em>, <em>dominant_case</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.percentage_to_domcoarse" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to pass from percentage data to dominant/coarse. As the code 8 from the subtrate in
Cemagref code is slab, we do not the 8 code as the coarser substrate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sub_data</strong> &#8211; the subtrate data in percentage from Lammi</li>
<li><strong>dominant_case</strong> &#8211; an int to manage the case where the transfomation form percentage to dominnat is unclear (two
maxinimum percentage are equal from one element). if -1 take the smallest, if 1 take the biggest,
if 0, we do not know.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.substrate.sandre_to_cemagref">
<code class="descclassname">src.substrate.</code><code class="descname">sandre_to_cemagref</code><span class="sig-paren">(</span><em>records</em><span class="sig-paren">)</span><a class="headerlink" href="#src.substrate.sandre_to_cemagref" title="Permalink to this definition">¶</a></dt>
<dd><p>This function passes the substrate data from the code type &#8220;Sandre&#8221; to the code type &#8220;Cemagref&#8221;. This function is
not optimized yet. For the definition of the code, see the tabular at the 14 of the LAMMI manual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>records</strong> &#8211; the substrate data in code samdre</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the substrate data in code cemagref</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="merge-the-grid">
<h2>Merge the grid<a class="headerlink" href="#merge-the-grid" title="Permalink to this headline">¶</a></h2>
<p>in src/mesh_grid2.py</p>
<p>This module contains the function to merge the substrate grid and the hydrological grid.
It cut the hydrological grid to the form of each of the substrate. An important hypothesis
is that each polygon forming the subtrate should convex.</p>
<span class="target" id="module-src.mesh_grid2"></span><dl class="function">
<dt id="src.mesh_grid2.create_merge_grid">
<code class="descclassname">src.mesh_grid2.</code><code class="descname">create_merge_grid</code><span class="sig-paren">(</span><em>ikle</em>, <em>coord_p</em>, <em>data_sub_pg</em>, <em>data_sub_dom</em>, <em>vel</em>, <em>height</em>, <em>ikle_sub</em>, <em>default_data</em>, <em>data_crossing</em>, <em>sub_cell</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mesh_grid2.create_merge_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to update the grid after finding the crossing points. It also get the substrate_data for each cell
of the new grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ikle</strong> &#8211; the hydrological grid to be merge with the substrate grid</li>
<li><strong>coord_p</strong> &#8211; the coordinate of the point of the hydrological grid</li>
<li><strong>data_sub_pg</strong> &#8211; the coarser substrate data by hydrological cell (3 information by cells realted to
the three points)</li>
<li><strong>data_sub_dom</strong> &#8211; the dominant substrate data by hydrological cell (3 information by cells realted to
the three points)</li>
<li><strong>vel</strong> &#8211; the velocity (one time step, one reach) for each point in coord_p</li>
<li><strong>height</strong> &#8211; the water height (one time step, one reach) for each point in coord_p</li>
<li><strong>ikle_sub</strong> &#8211; the connectivity table for the substrate</li>
<li><strong>default_data</strong> &#8211; the default substrate data</li>
<li><strong>data_crossing</strong> &#8211; the hydrological elment with a crossing and the info for this crossing (a list of list)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the new grid</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Technical comments</strong></p>
<p>This function corrects all element of the grids where a crossing point have been found by the
function find_sub_and_cross()</p>
<p>There are three cases:</p>
<ol class="loweralpha simple">
<li>one crossing point -&gt; no change</li>
<li>two crossing points and subtrate point inside -&gt; done manually. We take the two crossing point and the side on
which the crossing is done. Based on this, we correct the grid.</li>
<li>more than two crossing point on the elements -&gt; We call the extrenal module
triangle to re-do some triagulations into the element. This last cases covers many possible case, but it is slow.
To optimize, we can think about writing more individual cases. To follow the border of each subtrate cell in
the &#8220;special cell&#8221;, we do one triangulation by subtrate element, so we can have two or three triangulation.
It is also important there that the substrate is convex as the triangulation is not constrained.</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="src.mesh_grid2.fig_merge_grid">
<code class="descclassname">src.mesh_grid2.</code><code class="descname">fig_merge_grid</code><span class="sig-paren">(</span><em>point_all_both_t</em>, <em>ikle_both_t</em>, <em>path_im</em>, <em>name_add=''</em>, <em>ikle_orr=[]</em>, <em>point_all_orr=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mesh_grid2.fig_merge_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to plot the grid after it was merged with the substrate data.
It plots one time step at the time. This function is not used anymore by Habby. Indded, mesh_grid2 uses the
function provided in manage_grid8.py to plot the grid and data after it is merged with the substrate. However,
this function could be useful to debug if one wants to only plots teh grid and not the height/velocity data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>point_all_both_t</strong> &#8211; the coordinate of the points of the updated grid</li>
<li><strong>ikle_both_t</strong> &#8211; the connectivity table</li>
<li><strong>path_im</strong> &#8211; the path where the image should be saved</li>
<li><strong>name_add</strong> &#8211; the anem to be added to the figure name</li>
<li><strong>ikle_orr</strong> &#8211; the orginial ikle</li>
<li><strong>point_all_orr</strong> &#8211; the orginal point_all</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mesh_grid2.find_sub_and_cross">
<code class="descclassname">src.mesh_grid2.</code><code class="descname">find_sub_and_cross</code><span class="sig-paren">(</span><em>ikle_sub</em>, <em>coord_p_sub</em>, <em>ikle</em>, <em>coord_p</em>, <em>data_sub_pg</em>, <em>data_sub_dom</em>, <em>first_time=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mesh_grid2.find_sub_and_cross" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which find where the crossing points are. Crossing points are the points on the triangular side of the
hydrological grid which cross with a side of the substrate grid. The algo based on finding if points of one elements
are in the same polygon using a ray casting method. We assume that the polygon forming the subtrate grid are convex.
Otherwise it would not work in all cases.
We also neglect the case where a substrate cell at the border of the subtrate grid is fully in a hydrological cell.</p>
<p>IMPORTANT: polygon should be convex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ikle_sub</strong> &#8211; the connectivity table for the substrate</li>
<li><strong>coord_p_sub</strong> &#8211; the coordinates of the poitn forming the subtrate</li>
<li><strong>ikle</strong> &#8211; the connectivity table for the hydrology</li>
<li><strong>coord_p</strong> &#8211; the coordinate of the hydrology</li>
<li><strong>data_sub_dom</strong> &#8211; the subtrate data by subtrate cell (dominant)</li>
<li><strong>data_sub_pg</strong> &#8211; the substrate data by substrate cell (coarser)</li>
<li><strong>first_time</strong> &#8211; If True, we preapre the subtrate data</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the new substrate grid (ikle_sub, coord_p_sub, data_sub_pg, data_sub_dom, sub_cell), the data for
the crossing point (hydrological element with a crossing, crossing point, substrate element linked with
the crossing point, point of substrate inside, substrate element linked with the substrate point,
side of the crossing points, substrate leemnt link with hydro_point).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mesh_grid2.get_new_vel_height_data">
<code class="descclassname">src.mesh_grid2.</code><code class="descname">get_new_vel_height_data</code><span class="sig-paren">(</span><em>newp</em>, <em>point_old</em>, <em>data_old</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mesh_grid2.get_new_vel_height_data" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets the height and velcoity data for a new point in or on the side of an element. It does an
average of the data (velocity or height) given at the node of the original (old) elements. This average is weighted
as a function of the distance of the point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>newp</strong> &#8211; the coordinates of the new points</li>
<li><strong>point_old</strong> &#8211; the coordinates of thre three old points (would work with more than three)</li>
<li><strong>data_old</strong> &#8211; the data for the point in point_old</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the new data</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mesh_grid2.inside_trigon">
<code class="descclassname">src.mesh_grid2.</code><code class="descname">inside_trigon</code><span class="sig-paren">(</span><em>pt</em>, <em>p0</em>, <em>p1</em>, <em>p2</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mesh_grid2.inside_trigon" title="Permalink to this definition">¶</a></dt>
<dd><p>This function check if a point is in a triangle using the barycentric coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pt</strong> &#8211; the point to determine if it is in or not</li>
<li><strong>p0</strong> &#8211; the first point of triangle</li>
<li><strong>p1</strong> &#8211; the second point of triangle</li>
<li><strong>p2</strong> &#8211; the third point of triangle</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A boolean (Ture if pt inside of triangle)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mesh_grid2.intersec_cross">
<code class="descclassname">src.mesh_grid2.</code><code class="descname">intersec_cross</code><span class="sig-paren">(</span><em>hyd1</em>, <em>hyd2</em>, <em>sub1</em>, <em>sub2</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mesh_grid2.intersec_cross" title="Permalink to this definition">¶</a></dt>
<dd><p>A function function to calculate the intersection, segment are not parrallel,
used in case where we know that the intersection exists</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>hyd1</strong> &#8211; the first hydrological point</li>
<li><strong>hyd2</strong> &#8211; the second</li>
<li><strong>sub1</strong> &#8211; the first substrate point</li>
<li><strong>sub2</strong> &#8211; the second</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">intersection</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mesh_grid2.main">
<code class="descclassname">src.mesh_grid2.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.mesh_grid2.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module.</p>
</dd></dl>

<dl class="function">
<dt id="src.mesh_grid2.merge_grid_and_save">
<code class="descclassname">src.mesh_grid2.</code><code class="descname">merge_grid_and_save</code><span class="sig-paren">(</span><em>hdf5_name_hyd</em>, <em>hdf5_name_sub</em>, <em>path_hdf5</em>, <em>default_data</em>, <em>name_prj</em>, <em>path_prj</em>, <em>model_type</em>, <em>q=[]</em>, <em>print_cmd=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mesh_grid2.merge_grid_and_save" title="Permalink to this definition">¶</a></dt>
<dd><p>This function call the merging of the grid between the grid from the hydrological data and the substrate data.
It then save the merged data and the substrate data in a common hdf5 file. This function is called in a second
thread to avoid freezin gthe GUI. This is why we have this extra-function just to call save_hdf5() and
merge_grid_hydro_sub().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hdf5_name_hyd</strong> &#8211; the name of the hdf5 file with the hydrological data</li>
<li><strong>hdf5_name_sub</strong> &#8211; the name of the hdf5 with the substrate data</li>
<li><strong>path_hdf5</strong> &#8211; the path to the hdf5 data</li>
<li><strong>default_data</strong> &#8211; The substrate data given in the region of the hydrological grid where no substrate is given</li>
<li><strong>name_prj</strong> &#8211; the name of the project</li>
<li><strong>path_prj</strong> &#8211; the path to the project</li>
<li><strong>model_type</strong> &#8211; the type of the &#8220;model&#8221;. In this case, it is just &#8216;SUBSTRATE&#8217;</li>
<li><strong>q</strong> &#8211; used to share info with the GUI when this thread have finsihed (print_cmd = False)</li>
<li><strong>print_cmd</strong> &#8211; If False, print to the GUI (usually False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.mesh_grid2.merge_grid_hydro_sub">
<code class="descclassname">src.mesh_grid2.</code><code class="descname">merge_grid_hydro_sub</code><span class="sig-paren">(</span><em>hdf5_name_hyd</em>, <em>hdf5_name_sub</em>, <em>path_hdf5</em>, <em>default_data=1</em>, <em>path_prj=''</em><span class="sig-paren">)</span><a class="headerlink" href="#src.mesh_grid2.merge_grid_hydro_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>After the data for the substrate and the hydrological data are loaded, they are still in different grids.
This functions will merge both grid together. This is done for all time step and all reaches. If a
constant substrate is there, the hydrological hdf5 is just copied.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>hdf5_name_hyd</strong> &#8211; the name of the hdf5 file with the hydrological data</li>
<li><strong>hdf5_name_sub</strong> &#8211; the name of the hdf5 with the substrate data</li>
<li><strong>path_hdf5</strong> &#8211; the path to the hdf5 data</li>
<li><strong>default_data</strong> &#8211; The substrate data given in the region of the hydrological grid where no substrate is given</li>
<li><strong>path_prj</strong> &#8211; the path to the project</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the connectivity table, the coordinates, the substrated data, the velocity and height data all in a merge form.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="biological-info">
<h2>Biological Info<a class="headerlink" href="#biological-info" title="Permalink to this headline">¶</a></h2>
<p>in src/bio_info.py</p>
<p>This module contains the script to show and manage the biological models (preference curves) which are in the biology folder.</p>
<span class="target" id="module-src.bio_info"></span><dl class="function">
<dt id="src.bio_info.change_unit">
<code class="descclassname">src.bio_info.</code><code class="descname">change_unit</code><span class="sig-paren">(</span><em>data</em>, <em>unit</em><span class="sig-paren">)</span><a class="headerlink" href="#src.bio_info.change_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>This function modify the unit of the data to SI unit. Currently it accept the following unit :
Centimeter, Meter, CentimeterPerSecond, MeterPerSecond, Millimeter, &#8220;Code EVHA 2.0 (GINOT 1998)&#8221;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> &#8211; the data which has to be change to SI unti</li>
<li><strong>unit</strong> &#8211; the unit code</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.bio_info.create_and_fill_database">
<code class="descclassname">src.bio_info.</code><code class="descname">create_and_fill_database</code><span class="sig-paren">(</span><em>path_bio</em>, <em>name_database</em>, <em>attribute</em><span class="sig-paren">)</span><a class="headerlink" href="#src.bio_info.create_and_fill_database" title="Permalink to this definition">¶</a></dt>
<dd><p>This function create a new database when Habby starts. The goal of creating a database is to avoid freezing the GUI
when info on the preference curve are asked. So it is possible to select one curve and have information without
seeing too much of a delay.</p>
<p>This is not used anymore by HABBY as the xml file is really small.
It could however be useful if the xml file becomes too big. In this case, this function could be
called if modification are found in the pref_file folder and would create a database.</p>
<p>The attribute can be modified, but they should all be of text type. It is also important to keep stage at the first
attribute. The modified attribute should reflect the attribute of the xml file. If it not possible, lines should
be added in the &#8220;special case&#8221; attributes&#8221;. The main table with the data is called pref_bio.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path_bio</strong> &#8211; the path to the biological information (usually ./biology)</li>
<li><strong>name_database</strong> &#8211; the name of the database (string) without the path</li>
<li><strong>attribute</strong> &#8211; the attribute in the database (only text type)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a boolean (True if everthing ok, False otherwise)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.bio_info.create_pdf">
<code class="descclassname">src.bio_info.</code><code class="descname">create_pdf</code><span class="sig-paren">(</span><em>xmlfiles</em>, <em>stages_chosen</em>, <em>path_bio</em>, <em>path_im_bio</em>, <em>path_out</em>, <em>fig_opt</em><span class="sig-paren">)</span><a class="headerlink" href="#src.bio_info.create_pdf" title="Permalink to this definition">¶</a></dt>
<dd><p>This functionc create a pdf with information about the fish. It tries to follow the chosen language, but
the stage name are not translated and the decription are usually only given in French.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>xmlfiles</strong> &#8211; the name of the xmlfile (without the path!)</li>
<li><strong>stages_chosen</strong> &#8211; the stage chosen (might not be all stages)</li>
<li><strong>path_bio</strong> &#8211; the path with the biological xml file</li>
<li><strong>path_im_bio</strong> &#8211; the path with the images of the fish</li>
<li><strong>path_out</strong> &#8211; the path where to save the .pdf file (usually other_outputs)</li>
<li><strong>fig_opt</strong> &#8211; the figure options (contain the chosen language)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.bio_info.execute_request">
<code class="descclassname">src.bio_info.</code><code class="descname">execute_request</code><span class="sig-paren">(</span><em>path_bio</em>, <em>name_database</em>, <em>request</em><span class="sig-paren">)</span><a class="headerlink" href="#src.bio_info.execute_request" title="Permalink to this definition">¶</a></dt>
<dd><p>This function execute the SQL request given in the string called request. it saves the found data in a variable.
The idea is to use this function for SELELCT X FROM X WHERE ... , not really to handle all possible request.
It also opens and close the database name_database to do this. This is not used anymore by HABBY as we do not use
a database. It could however be useful if the xml file becomes too big.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path_bio</strong> &#8211; the path to the biological information (usually ./biology)</li>
<li><strong>name_database</strong> &#8211; the name of the database (string) without the path</li>
<li><strong>request</strong> &#8211; the SQL request in a string form</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the result</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.bio_info.figure_pref">
<code class="descclassname">src.bio_info.</code><code class="descname">figure_pref</code><span class="sig-paren">(</span><em>height</em>, <em>vel</em>, <em>sub</em>, <em>code_fish</em>, <em>name_fish</em>, <em>stade</em>, <em>get_fig=False</em>, <em>fig_opt={}</em><span class="sig-paren">)</span><a class="headerlink" href="#src.bio_info.figure_pref" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to plot the preference curves.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>height</strong> &#8211; the height preference data (list of list)</li>
<li><strong>vel</strong> &#8211; the height preference data (list of list)</li>
<li><strong>sub</strong> &#8211; the height preference data (list of list)</li>
<li><strong>code_fish</strong> &#8211; the three letter code which indiate which fish species is analyzed</li>
<li><strong>name_fish</strong> &#8211; the name of the fish analyzed</li>
<li><strong>stade</strong> &#8211; the name of the stade analyzed (ADU, JUV, ...)</li>
<li><strong>get_fig</strong> &#8211; usually False, If True return the figure (to modfied it more)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.bio_info.get_stage">
<code class="descclassname">src.bio_info.</code><code class="descname">get_stage</code><span class="sig-paren">(</span><em>names_bio</em>, <em>path_bio</em><span class="sig-paren">)</span><a class="headerlink" href="#src.bio_info.get_stage" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads all the stages present in a list of  xml preference files (JUV, ADU, etc) and the latin name of
the fish species. All the files should be in the same folder indicated by path_bio. It is mainly used by habby_cmd
but it can be useful in other cases also.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>names_bio</strong> &#8211; A list of xml biological preference file</li>
<li><strong>path_bio</strong> &#8211; the path to the xml preference files (usually &#8216;./biology&#8217;)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the stages in a list of string</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.bio_info.load_evha_curve">
<code class="descclassname">src.bio_info.</code><code class="descname">load_evha_curve</code><span class="sig-paren">(</span><em>filename</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.bio_info.load_evha_curve" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to load the preference curve in the EVHA form . It will be useful to create xml preference
file, but it is not used direclty by HABBY. This function does not have much control on user input as it is planned
to be used only by people working on HABBY. The order of the data in the file must be height, velocity, substrate</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> &#8211; the name of file containing the preference curve for EVHA</li>
<li><strong>path</strong> &#8211; the path to this file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">preference for height, vel, sub in a list of list form, name of the fish, code, stade and description</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.bio_info.load_xml_name">
<code class="descclassname">src.bio_info.</code><code class="descname">load_xml_name</code><span class="sig-paren">(</span><em>path_bio</em>, <em>attributes</em>, <em>preffiles=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.bio_info.load_xml_name" title="Permalink to this definition">¶</a></dt>
<dd><p>This function looks for all preference curves found in the path_bio folder. It extract the fish name and the stage.
to be corrected if more than one language. The name of attribute_acc should be coherent with the one from the xml
file apart from the common name which should be in the form language_common_name (so we can wirte something in the
GUI to get all langugage if we get something else than English or French).</p>
<p>If one use the argument preffiles, only part of the xml file are loaded. Otherwise all xml file are loaded.</p>
<p>Careful, the first attribute is relgated at the last place of the list return. This is confusing but it is really
useful for the GUI.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path_bio</strong> &#8211; the path to the biological function</li>
<li><strong>attributes</strong> &#8211; the list of attribute which should be possible to search from the GUI or, more generally
which should be in data-fish which is returned.</li>
<li><strong>preffiles</strong> &#8211; If there is a list of string there, it only read this files</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the list of stage/fish species with the info from [name for GUi, s, xmlfilename, attribute_acc without s]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.bio_info.main">
<code class="descclassname">src.bio_info.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.bio_info.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test the module on the biological preference</p>
</dd></dl>

<dl class="function">
<dt id="src.bio_info.plot_hydrosignature">
<code class="descclassname">src.bio_info.</code><code class="descname">plot_hydrosignature</code><span class="sig-paren">(</span><em>xmlfile</em><span class="sig-paren">)</span><a class="headerlink" href="#src.bio_info.plot_hydrosignature" title="Permalink to this definition">¶</a></dt>
<dd><p>This function plots the hydrosignature in the vclass and hclass given in the xml file.
It does only work if: units are SI (meter and m/s) and if the order of data is &#8216;velocity increasing
and then height of water increasing&#8221;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>xmlfile</strong> &#8211; the path and name of the xmlfile</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.bio_info.read_pref">
<code class="descclassname">src.bio_info.</code><code class="descname">read_pref</code><span class="sig-paren">(</span><em>xmlfile</em><span class="sig-paren">)</span><a class="headerlink" href="#src.bio_info.read_pref" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reads the preference curve from the xml file and get the subtrate, height and velocity data.
It return the data in meter. Unit for space can be in centimeter, milimeter or meter. Unit for time should be in
second .The unit attribute of the xml files should be coherent with the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>xmlfile</strong> &#8211; the path and name to the xml file (string)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">height, vel, sub, code_fish, name_fish, stade</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.bio_info.test_evah_xml_pref">
<code class="descclassname">src.bio_info.</code><code class="descname">test_evah_xml_pref</code><span class="sig-paren">(</span><em>path_xml</em>, <em>path_evha</em><span class="sig-paren">)</span><a class="headerlink" href="#src.bio_info.test_evah_xml_pref" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to visually compared the evha (.PRF) curve and the xml curve based on the evah curve.
Obviously the xml file should contain the same data than the evha curve (when the xml file are based on the evah
curve). An important assumption of this function is that the data in the xml file is in the order: fry, juvenile,
adult.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path_xml</strong> &#8211; the path to the folder which contains the xml files</li>
<li><strong>path_evha</strong> &#8211; the path to the evha folder which contains the PRF files</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="calculation-habitat">
<h2>Calculation habitat<a class="headerlink" href="#calculation-habitat" title="Permalink to this headline">¶</a></h2>
<p>in src/calcul_hab.py</p>
<p>This module calculates the habitat value for the fish and creates the outputs (text files, shapefile, and figures).</p>
<span class="target" id="module-src.calcul_hab"></span><dl class="function">
<dt id="src.calcul_hab.calc_hab">
<code class="descclassname">src.calcul_hab.</code><code class="descname">calc_hab</code><span class="sig-paren">(</span><em>merge_name</em>, <em>path_merge</em>, <em>bio_names</em>, <em>stages</em>, <em>path_bio</em>, <em>opt</em><span class="sig-paren">)</span><a class="headerlink" href="#src.calcul_hab.calc_hab" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the habitat value. It loads substrate and hydrology data from an hdf5 files and it loads
the biology data from the xml files. It is possible to have more than one stage by xml file (usually the three
stages are in the xml files). There are more than one method to calculte the habitat so the parameter opt indicate
which metho to use. 0-&gt; usde coarser substrate, 1 -&gt; use dominant substrate</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>merge_name</strong> &#8211; the name of the hdf5 with the results</li>
<li><strong>path_merge</strong> &#8211; the path to the merged file</li>
<li><strong>bio_names</strong> &#8211; the name of the xml biological data</li>
<li><strong>stages</strong> &#8211; the stage chosen (youngs, adults, etc.). List with the same length as bio_names.</li>
<li><strong>path_bio</strong> &#8211; The path to the biological folder (with all files given in bio_names</li>
<li><strong>opt</strong> &#8211; an int fron 0 to n. Gives which calculation method should be used</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the habiatat value for all species, all time, all reach, all cells.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.calcul_hab.calc_hab_and_output">
<code class="descclassname">src.calcul_hab.</code><code class="descname">calc_hab_and_output</code><span class="sig-paren">(</span><em>hdf5_file</em>, <em>path_hdf5</em>, <em>pref_list</em>, <em>stages_chosen</em>, <em>name_fish</em>, <em>name_fish_sh</em>, <em>run_choice</em>, <em>path_bio</em>, <em>path_txt</em>, <em>path_shp</em>, <em>path_para</em>, <em>path_im</em>, <em>q=[]</em>, <em>print_cmd=False</em>, <em>fig_opt={}</em>, <em>path_im_bio=''</em>, <em>xmlfiles=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#src.calcul_hab.calc_hab_and_output" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the habitat and create the outputs for the habitat calculation. The outputs are: text
output (spu and cells by cells), shapefile, paraview files, one 2d figure by time step. The 1d figure
is done on the main thread as we want to show it to the user on the GUI. This function is called by bio_info_GUI.py
on a second thread to minimize the freezing on the GUI.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hdf5_file</strong> &#8211; the name of the hdf5 with the results</li>
<li><strong>path_hdf5</strong> &#8211; the path to the merged file</li>
<li><strong>pref_list</strong> &#8211; the name of the xml biological data</li>
<li><strong>stages_chosen</strong> &#8211; the stage chosen (youngs, adults, etc.). List with the same length as bio_names.</li>
<li><strong>name_fish</strong> &#8211; the name of the chosen fish</li>
<li><strong>name_fish_sh</strong> &#8211; In a shapefile, max 8 character for the column name. Hence, a modified name_fish is needed.</li>
<li><strong>run_choice</strong> &#8211; an int fron 0 to n. Gives which calculation method should be used</li>
<li><strong>path_bio</strong> &#8211; The path to the biological folder (with all files given in bio_names)</li>
<li><strong>path_txt</strong> &#8211; the path where to save the text file</li>
<li><strong>path_shp</strong> &#8211; the path where to save shapefile</li>
<li><strong>path_para</strong> &#8211; the path where to save paraview output</li>
<li><strong>path_im</strong> &#8211; the path where to save the image</li>
<li><strong>path_im_bio</strong> &#8211; the path where are the image of the fish</li>
<li><strong>q</strong> &#8211; used in the second thread</li>
<li><strong>print_cmd</strong> &#8211; if True the print command is directed in the cmd, False if directed to the GUI</li>
<li><strong>fig_opt</strong> &#8211; the options to crete the figure if save_fig1d is True</li>
<li><strong>xmlfiles</strong> &#8211; the list of the xml file (only useful to get the preference curve report, so not used by habby_cmd)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>** Technical comments**</p>
<p>This function redirect the sys.stdout. The point of doing this is because this function will be call by the GUI or
by the cmd. If it is called by the GUI, we want the output to be redirected to the windows for the log under HABBY.
If it is called by the cmd, we want the print function to be sent to the command line. We make the switch here.</p>
</dd></dl>

<dl class="function">
<dt id="src.calcul_hab.calc_hab_norm">
<code class="descclassname">src.calcul_hab.</code><code class="descname">calc_hab_norm</code><span class="sig-paren">(</span><em>ikle_all_t</em>, <em>point_all_t</em>, <em>vel</em>, <em>height</em>, <em>sub</em>, <em>pref_vel</em>, <em>pref_height</em>, <em>pref_sub</em>, <em>percent=False</em>, <em>take_sub=True</em><span class="sig-paren">)</span><a class="headerlink" href="#src.calcul_hab.calc_hab_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the habitat suitiabilty index (f(H)xf(v)xf(sub)) for each and the SPU which is the sum of
all habitat suitability index weighted by the cell area for each reach. It is called by clac_hab_norm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ikle_all_t</strong> &#8211; the connectivity table for all time step, all reach</li>
<li><strong>point_all_t</strong> &#8211; the point of the grid</li>
<li><strong>vel</strong> &#8211; the velocity data for all time step, all reach</li>
<li><strong>height</strong> &#8211; the water height data for all time step, all reach</li>
<li><strong>sub</strong> &#8211; the substrate data (can be coarser or dominant substrate based on function&#8217;s call)</li>
<li><strong>pref_vel</strong> &#8211; the preference index for the velcoity (for one life stage)</li>
<li><strong>pref_sub</strong> &#8211; the preference index for the substrate  (for one life stage)</li>
<li><strong>pref_height</strong> &#8211; the preference index for the height  (for one life stage)</li>
<li><strong>percent</strong> &#8211; If True, the variable sub is in percent form, not in the form dominant/coarser</li>
<li><strong>take_sub</strong> &#8211; If False, the substrate data is neglected.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">vh of one life stage, area, habitat value</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.calcul_hab.find_pref_value">
<code class="descclassname">src.calcul_hab.</code><code class="descname">find_pref_value</code><span class="sig-paren">(</span><em>data</em>, <em>pref</em><span class="sig-paren">)</span><a class="headerlink" href="#src.calcul_hab.find_pref_value" title="Permalink to this definition">¶</a></dt>
<dd><p>This function finds the preference value associated with the data for each cell. For this, it finds the last
point of the preference curve under the data and it makes a linear interpolation with the next data to
find the preference value. As preference value is sorted, it uses the module bisect to accelerate the process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> &#8211; the data on the cells (for one time step, on reach)</li>
<li><strong>pref</strong> &#8211; the pref data [pref, class data]</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.calcul_hab.plot_hist_hydro">
<code class="descclassname">src.calcul_hab.</code><code class="descname">plot_hist_hydro</code><span class="sig-paren">(</span><em>hdf5_file</em>, <em>path_hdf5</em>, <em>vel_c_all_t</em>, <em>height_c_all_t</em>, <em>area_c_all_t</em>, <em>fig_opt</em>, <em>path_im</em>, <em>timestep</em>, <em>name_base</em>, <em>sim_name=[]</em>, <em>erase_id=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.calcul_hab.plot_hist_hydro" title="Permalink to this definition">¶</a></dt>
<dd><p>This function plots an historgram of the hydraulic and substrate data for the selected timestep. This historgramm
is weighted by the area of the cell. The data is based on the height and velocity data by cell and not on the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hdf5_file</strong> &#8211; the name of the hdf5 file</li>
<li><strong>path_hdf5</strong> &#8211; the path to this file</li>
<li><strong>vel_c_all_t</strong> &#8211; the velcoity for all reach all time step by cell</li>
<li><strong>height_c_all_t</strong> &#8211; the water height for all reach all time step by cell</li>
<li><strong>area_c_all_t</strong> &#8211; the aire of cells for all reach, all time step</li>
<li><strong>fig_opt</strong> &#8211; the figure options</li>
<li><strong>path_im</strong> &#8211; the path where to save the images</li>
<li><strong>timestep</strong> &#8211; a list with the time step to be plotted</li>
<li><strong>name_base</strong> &#8211; the base on which to form the figure name</li>
<li><strong>sim_name</strong> &#8211; the name of the time steps when not 0,1,2,3</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.calcul_hab.remove_image">
<code class="descclassname">src.calcul_hab.</code><code class="descname">remove_image</code><span class="sig-paren">(</span><em>name</em>, <em>path</em>, <em>format1</em><span class="sig-paren">)</span><a class="headerlink" href="#src.calcul_hab.remove_image" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a small function used to erase images if erase_id is True. We have a function because different format
czan be used and because it is done often in the functions above.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> &#8211; the name of the file t be erase (without the extension)</li>
<li><strong>path</strong> &#8211; the path to the file</li>
<li><strong>format1</strong> &#8211; the type of format</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.calcul_hab.save_hab_fig_spu">
<code class="descclassname">src.calcul_hab.</code><code class="descname">save_hab_fig_spu</code><span class="sig-paren">(</span><em>area_all</em>, <em>spu_all</em>, <em>name_fish</em>, <em>path_im</em>, <em>name_base</em>, <em>fig_opt={}</em>, <em>sim_name=[]</em>, <em>erase_id=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.calcul_hab.save_hab_fig_spu" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates the figure of the spu as a function of time for each reach. if there is only one
time step, it reverse to a bar plot. Otherwise it is a line plot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>area_all</strong> &#8211; the area for all reach</li>
<li><strong>spu_all</strong> &#8211; the &#8220;surface pondere utile&#8221; (SPU) for each reach</li>
<li><strong>name_fish</strong> &#8211; the list of fish latin name + stage</li>
<li><strong>path_im</strong> &#8211; the path where to save the image</li>
<li><strong>fig_opt</strong> &#8211; the dictionnary with the figure options</li>
<li><strong>name_base</strong> &#8211; a string on which to base the name of the files</li>
<li><strong>sim_name</strong> &#8211; the name of the time steps if not 0,1,2,3</li>
<li><strong>erase_id</strong> &#8211; If True, figure from identical simuation are erased</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.calcul_hab.save_hab_shape">
<code class="descclassname">src.calcul_hab.</code><code class="descname">save_hab_shape</code><span class="sig-paren">(</span><em>name_merge_hdf5</em>, <em>path_hdf5</em>, <em>vh_data</em>, <em>vel_data</em>, <em>height_data</em>, <em>name_fish_sh</em>, <em>path_shp</em>, <em>name_base</em>, <em>sim_name=[]</em>, <em>save_perc=False</em>, <em>erase_id=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.calcul_hab.save_hab_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>This function create the output in the form of a shapefile. It creates one shapefile by time step. It put
all the reaches together. If there is overlap between reaches, it does not care. It create an attribute table
with the habitat value, velocity, height, substrate coarser, substrate dominant. It also create a shapefile
0 with the whole profile without data.</p>
<p>The name of the column of the attribute table should be less than 10 character. Hence, the variable name_fish
has been adapted to be shorter. The shorter name_fish is called name_fish_sh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name_merge_hdf5</strong> &#8211; the name of the hdf5 merged file</li>
<li><strong>path_hdf5</strong> &#8211; the path to the hydrological hdf5 data</li>
<li><strong>vel_data</strong> &#8211; the velocity by reach by time step on the cell (not node!)</li>
<li><strong>height_data</strong> &#8211; the height by reach by time step on the cell (not node!)</li>
<li><strong>vh_data</strong> &#8211; the habitat value data by speces by reach by tims tep</li>
<li><strong>name_fish_sh</strong> &#8211; the list of fish latin name + stage</li>
<li><strong>path_shp</strong> &#8211; the path where to save the shpaefile</li>
<li><strong>name_base</strong> &#8211; a string on which to base the name of the files</li>
<li><strong>sim_name</strong> &#8211; the time step&#8217;s name if not 0,1,2,3</li>
<li><strong>save_perc</strong> &#8211; It true the substrate in percentage will be added to the shapefile</li>
<li><strong>erase_id</strong> &#8211; If True, we erase old text file from identical hydraulic model</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.calcul_hab.save_hab_txt">
<code class="descclassname">src.calcul_hab.</code><code class="descname">save_hab_txt</code><span class="sig-paren">(</span><em>name_merge_hdf5</em>, <em>path_hdf5</em>, <em>vh_data</em>, <em>vel_data</em>, <em>height_data</em>, <em>name_fish</em>, <em>path_txt</em>, <em>name_base</em>, <em>sim_name=[]</em>, <em>erase_id=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.calcul_hab.save_hab_txt" title="Permalink to this definition">¶</a></dt>
<dd><p>This function print the text output. We create one set of text file by time step. Each Reach is separated by the
key work REACH follwoed by the reach number (strating from 0). There are three files by time steps: one file which
gives the connectivity table (starting at 0), one file with the point coordinates in the
coordinate systems of the hydraulic models (x,y), one file wiche gives the results.
In all three files, the first column is the reach number. In the results files, the next columns are velocity,
height, substrate, habitat value for each species. Use tab instead of space to help with excel import.</p>
<p>The name and the form of the files do not change with the chosen language. The idea is that these files are quite big
and that they will mostly be used by computer program. So it is easier for the user if the name and form is coherent.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name_merge_hdf5</strong> &#8211; the name of the hdf5 merged file</li>
<li><strong>path_hdf5</strong> &#8211; the path to the hydrological hdf5 data</li>
<li><strong>vel_data</strong> &#8211; the velocity by reach by time step on the cell (not node!)</li>
<li><strong>height_data</strong> &#8211; the height by reach by time step on the cell (not node!)</li>
<li><strong>vh_data</strong> &#8211; the habitat value data by speces by reach by tims tep</li>
<li><strong>name_fish</strong> &#8211; the list of fish latin name + stage</li>
<li><strong>path_txt</strong> &#8211; the path where to save the text file</li>
<li><strong>name_base</strong> &#8211; a string on which to base the name of the files</li>
<li><strong>sim_name</strong> &#8211; the name of the simulation/time step (list of strings)</li>
<li><strong>erase_id</strong> &#8211; If True, we erase old text file from identical hydraulic model</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.calcul_hab.save_spu_txt">
<code class="descclassname">src.calcul_hab.</code><code class="descname">save_spu_txt</code><span class="sig-paren">(</span><em>area_all</em>, <em>spu_all</em>, <em>name_fish</em>, <em>path_txt</em>, <em>name_base</em>, <em>sim_name=[]</em>, <em>lang=0</em>, <em>erase_id=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.calcul_hab.save_spu_txt" title="Permalink to this definition">¶</a></dt>
<dd><p>This function create a text files with the folowing columns: the tiem step, the reach number, the area of the
reach and the spu for each fish species. Use tab instead of space to help with excel import.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>area_all</strong> &#8211; the area for all reach</li>
<li><strong>spu_all</strong> &#8211; the &#8220;surface pondere utile&#8221; (SPU) for each reach</li>
<li><strong>name_fish</strong> &#8211; the list of fish latin name + stage</li>
<li><strong>path_txt</strong> &#8211; the path where to save the text file</li>
<li><strong>name_base</strong> &#8211; a string on which to base the name of the files</li>
<li><strong>sim_name</strong> &#8211; the name of the time step</li>
<li><strong>lang</strong> &#8211; an int which indicates the chosen language (0 is english)</li>
<li><strong>erase_id</strong> &#8211; If True, we erase old text file from identical hydraulic model</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.calcul_hab.save_vh_fig_2d">
<code class="descclassname">src.calcul_hab.</code><code class="descname">save_vh_fig_2d</code><span class="sig-paren">(</span><em>name_merge_hdf5, path_hdf5, vh_all_t_sp, path_im, name_fish, name_base, fig_opt={}, time_step=[-1], sim_name=[], save_fig=True, erase_id=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.calcul_hab.save_vh_fig_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates 2D map of the habitat value for each species at
the time step asked. All reaches are ploted on the same figure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name_merge_hdf5</strong> &#8211; the name of the hdf5 merged file</li>
<li><strong>path_hdf5</strong> &#8211; the path to the hydrological hdf5 data</li>
<li><strong>vh_all_t_sp</strong> &#8211; the habitat value for all reach all time step all species</li>
<li><strong>path_im</strong> &#8211; the path where to save the figure</li>
<li><strong>name_fish</strong> &#8211; the name and stage of the studied species</li>
<li><strong>name_base</strong> &#8211; the string on which to base the figure name</li>
<li><strong>fig_opt</strong> &#8211; the dictionnary with the figure options</li>
<li><strong>time_step</strong> &#8211; which time step should be plotted</li>
<li><strong>sim_name</strong> &#8211; the name of the time step if not 0,1,2,3</li>
<li><strong>save_fig</strong> &#8211; If True the figure is saved</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="create-paraview-files">
<h2>Create Paraview Files<a class="headerlink" href="#create-paraview-files" title="Permalink to this headline">¶</a></h2>
<p>in src/new_create_vtk.py
in src/evtk.py
in src/hl.py
in src/vtk.py
in src/xml_vk.py</p>
<p>Theses modules contain the scripts to create Paraview input which are binary xml-based vtu files. This part is heavily based on the module
Pyevtk created by Paulo Herrera (<a class="reference external" href="https://bitbucket.org/pauloh/pyevtk">https://bitbucket.org/pauloh/pyevtk</a>). Hence, the only script written for HABBY is in new_create_vtk.py. This
script then called one function in hl.py which then called the three other scripts as in Pyevtk (not documented here).</p>
<span class="target" id="module-src.new_create_vtk"></span><dl class="function">
<dt id="src.new_create_vtk.habitat_to_vtu">
<code class="descclassname">src.new_create_vtk.</code><code class="descname">habitat_to_vtu</code><span class="sig-paren">(</span><em>file_name_base</em>, <em>path_out</em>, <em>path_hdf5</em>, <em>name_hdf5</em>, <em>vh_all_t_sp</em>, <em>height_c_data</em>, <em>vel_c_data</em>, <em>name_fish</em>, <em>erase_id</em><span class="sig-paren">)</span><a class="headerlink" href="#src.new_create_vtk.habitat_to_vtu" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates paraview input in the new, non-legacy xml format. This function called the evtk class
written by Paulo Herrera, which is available at <a class="reference external" href="https://bitbucket.org/pauloh/pyevtk/downloads/">https://bitbucket.org/pauloh/pyevtk/downloads/</a></p>
<p>The format for paravier input file is descirbed in paraview_file_format.pdf in the doc folder of HABBY.</p>
<p>The data of the paraview file created here  is usually in binary form. The idea of paraview for a binary file is
to keep the same usual xml file. The data is encoded to base64. Before the binary array, there is a 32-bits interger
which contains the data length in bytes.
More info: <a class="reference external" href="http://www.earthmodels.org/software/vtk-and-paraview/vtk-file-formats">http://www.earthmodels.org/software/vtk-and-paraview/vtk-file-formats</a>.</p>
<p>Paraview can handle a group of file which compose an output with than one time step. This is the reason to create a
pwd files which list the files composing all the time steps (one file by time step)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_name_base</strong> &#8211; the base to create the name of the vtu file</li>
<li><strong>path_hdf5</strong> &#8211; the path to the hdf5 hydro file (to load the grid)</li>
<li><strong>name_hdf5</strong> &#8211; the name of the hdf5 containing the grid</li>
<li><strong>vh_all_t_sp</strong> &#8211; the habitat data by reach, time step, species</li>
<li><strong>height_c_data</strong> &#8211; the height by cell by reach by time step</li>
<li><strong>vel_c_data</strong> &#8211; the velocity by cell by reach by time step</li>
<li><strong>name_fish</strong> &#8211; the name of fish and stage</li>
<li><strong>path_out</strong> &#8211; the path where to save the data</li>
<li><strong>erase_id</strong> &#8211; if True, previous paraview file from identical merge file are erased</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.new_create_vtk.main">
<code class="descclassname">src.new_create_vtk.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.new_create_vtk.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to test this module</p>
</dd></dl>

<dl class="function">
<dt id="src.new_create_vtk.writePVD">
<code class="descclassname">src.new_create_vtk.</code><code class="descname">writePVD</code><span class="sig-paren">(</span><em>fileName</em>, <em>fileNames</em><span class="sig-paren">)</span><a class="headerlink" href="#src.new_create_vtk.writePVD" title="Permalink to this definition">¶</a></dt>
<dd><p>This function write the file which indicates to paraview how to group the file. This &#8220;grouping&#8221; file is pvd file.
With this file, paraview can open all the time steps together with one clic. This function is heavily inspired
by the class given at the adress:
<a class="reference external" href="https://github.com/cfinch/Shocksolution_Examples/blob/master/Visualization/vtktools.py">https://github.com/cfinch/Shocksolution_Examples/blob/master/Visualization/vtktools.py</a>. Because Element Tree
was not used in the class from Shocksolution, we use minidom here instead of Element Tree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fileName</strong> &#8211; the name of the pvd file</li>
<li><strong>fileNames</strong> &#8211; the names of all the files for this time step (usually only for one reach but could be changed).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="function-for-the-command-lines">
<h2>Function for the command lines<a class="headerlink" href="#function-for-the-command-lines" title="Permalink to this headline">¶</a></h2>
<p>in src/func_for_cmd.py</p>
<p>This module contains functions which are used by habby.py when called on the command line (witjout using the GUI).</p>
<span class="target" id="module-src.func_for_cmd"></span><dl class="function">
<dt id="src.func_for_cmd.all_command">
<code class="descclassname">src.func_for_cmd.</code><code class="descname">all_command</code><span class="sig-paren">(</span><em>all_arg</em>, <em>name_prj</em>, <em>path_prj</em>, <em>path_bio</em>, <em>option_restart=False</em><span class="sig-paren">)</span><a class="headerlink" href="#src.func_for_cmd.all_command" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to call HABBY from the command line. The general form is to call:
habby_cmd command_name input1 input2 .. input n. The list of the command_name is given in the documentation and by
calling the command &#8220;python habby_cmd.py LIST_COMMAND&#8221;. This functiion is usually called direclty by the main()
or it is called by the function restart which read a list of function line by line. Careful, new command cannot
contain the symbol &#8221;:&#8221; as it is used by restart.</p>
<p>For the restart function, it is also important that the input folder is just in the folder &#8220;next&#8221; to the restart
path. So the folder should not be moved randolmy inside the project folder or renamed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>all_arg</strong> &#8211; the list of argument (sys.argv more or less)</li>
<li><strong>name_prj</strong> &#8211; the name of the project, created by default by the main()</li>
<li><strong>path_prj</strong> &#8211; the path to the project created by default bu the main()</li>
<li><strong>path_bio</strong> &#8211; the path to the project</li>
<li><strong>option_restart</strong> &#8211; If True the command are coming from a restart log (which have an impact on file name and
location)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.func_for_cmd.habby_on_all">
<code class="descclassname">src.func_for_cmd.</code><code class="descname">habby_on_all</code><span class="sig-paren">(</span><em>all_arg</em>, <em>name_prj</em>, <em>path_prj</em>, <em>path_bio</em><span class="sig-paren">)</span><a class="headerlink" href="#src.func_for_cmd.habby_on_all" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to execute a command from habby_cmd on all files in a folder. The form of the command should
be something like &#8220;habby_cmd ALL COMMAND path_to_file/*.ext arg2 ag3&#8221; with the arguments adated to the specific
command.</p>
<p>In other words, the command should be the usual command with the keyword ALL before and with the name of
the input files remplace by *.ext . where ext is the extension of the files.
It is better to not add an output name. Indeed default name for output includes the input file name, which
is practical if different files are given as input. If the default
is overided, the same name will be applied, only the time stamps will be different. To be sure to not overwrite a
file, this function waits one second between each command. Only the input argument should containts the string &#8216;*&#8217;.
Otherwise, other commands would be treated as input files.</p>
<p>If there is more than one type of input, it is important that the name of the file are the name (or at least
that there are in the same alphabetical order).</p>
<p>If more than one extension is possible (example g01, g02, g03, etc. in hec-ras), remplace the changing part of the
extension with the symbol * (so path_to_folder/*.g0* arg1 argn). If the name of the file changed in the extension
as in RUBAR (where the file have the name PROFIL.file), just change for PROFIL.* or something similar. Generally
the matching is done using the function glob, so the shell-type wildcard can be used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>all_arg</strong> &#8211; the list of argument (sys.argv without the argument ALL so [sys.argv[0], sys.argv[2], sys.argv[n]])</li>
<li><strong>name_prj</strong> &#8211; the name of the project, created by default by the main()</li>
<li><strong>path_prj</strong> &#8211; the path to the project created by default bu the main()</li>
<li><strong>path_bio</strong> &#8211; the path to the project</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.func_for_cmd.habby_restart">
<code class="descclassname">src.func_for_cmd.</code><code class="descname">habby_restart</code><span class="sig-paren">(</span><em>file_comm</em>, <em>name_prj</em>, <em>path_prj</em>, <em>path_bio</em><span class="sig-paren">)</span><a class="headerlink" href="#src.func_for_cmd.habby_restart" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reads a list of command from a text file called file_comm. It then calls all_command one each line
which does contain the symbol &#8221;:&#8221; . If the lines contains the symbol &#8221;:&#8221;, it considered as an input.
Careful, the intput should be in order!!!! The info on the left and sight of the symbol &#8221;:&#8221; are just there so
an human can read them more easily. Space does not matters here. We try to write the restart file created
automatically by HABBY in a &#8220;nice&#8221; layout, but it just to  read it more easily.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_comm</strong> &#8211; a string wehich gives the name of the restart file (with the path)</li>
<li><strong>name_prj</strong> &#8211; the name of the project, created by default by the main()</li>
<li><strong>path_prj</strong> &#8211; the path to the project created by default bu the main()</li>
<li><strong>path_bio</strong> &#8211; the path to the project</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.func_for_cmd.load_fstress_text">
<code class="descclassname">src.func_for_cmd.</code><code class="descname">load_fstress_text</code><span class="sig-paren">(</span><em>path_fstress</em><span class="sig-paren">)</span><a class="headerlink" href="#src.func_for_cmd.load_fstress_text" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the data for fstress from text files. The data is composed of the name of the rive, the
discharge range, and the [discharge, height, width]. To read the files, the files listriv.txt is given. Form then,
the function looks for the other files in the same folder. The other files are rivdeb.txt and rivqwh.txt. If more
than one river is given in listriv.txt, it load the data for all rivers.</p>
<p>There is a very similar function as a method in the class FStressW() in fstress_GUI.py but it ised by the GUI
and it includes a way to select the file using the GUI. Changes should be copied in both functions if necessary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path_fstress</strong> &#8211; the path to the listriv.txt function (the other fil should be in the same folder)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="src.func_for_cmd.load_manning_txt">
<code class="descclassname">src.func_for_cmd.</code><code class="descname">load_manning_txt</code><span class="sig-paren">(</span><em>filename_path</em><span class="sig-paren">)</span><a class="headerlink" href="#src.func_for_cmd.load_manning_txt" title="Permalink to this definition">¶</a></dt>
<dd><p>This function loads the manning data in case where manning number is not simply a constant. In this case, the manning
parameter is given in a .txt file. The manning parameter used by 1D model such as mascaret or Rubar BE to distribute
velocity along the profiles. The format of the txt file is &#8220;p, dist, n&#8221; where  p is the profile number (start at zero),
dist is the distance along the profile in meter and n is the manning value (in SI unit). White space is neglected
and a line starting with the character # is also neglected.</p>
<p>There is a very similar function as a method in the class Sub_HydroW() in hydro_GUI.py but it used by the GUI
and it includes a way to select the file using the GUI and it used a lot of class attribute. So it cannot be used
by the command line. Changes should be copied in both functions if necessary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename_path</strong> &#8211; the path and the name of the file containing the manning data</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the manning as an array form</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="various-notes">
<h1>Various notes<a class="headerlink" href="#various-notes" title="Permalink to this headline">¶</a></h1>
<div class="section" id="figures-and-matplotlib">
<h2>Figures and matplotlib<a class="headerlink" href="#figures-and-matplotlib" title="Permalink to this headline">¶</a></h2>
<p><strong>The legend of the plots are not shown.</strong></p>
<p>Generally HABBY is able to save the figure while showing the legend (which is often outside of the figure) appropriately. However,
the figure shown to the user by matplotlib often have the legend outside of the visible area. To see the figure fully, one can modify
the axes in the option of the figure (the menu in the axes on the top of the figure).</p>
<p><strong>How to make figures editable in Adobe Illustrator</strong></p>
<p>It is useful to have figures which we can edit in Adobe Illustrator. To achieve this, the following matplotlib option should be added:
mpl.rcParams[&#8216;pdf.fonttype&#8217;] = 42. Moreover, matplolib should be imported (import matplotlib as mpl). It is also useful to add the tranparent option to the function to save the figure (transparent=True). This renders modification easier in many cases. However, it is not good to use mpl.rcParams[&#8216;ps.fonttype&#8217;] = 42 as the figure created in the eps format would be corrupted because of a bug in matplotlib.</p>
</div>
<div class="section" id="translation-of-habby">
<h2>Translation of HABBY<a class="headerlink" href="#translation-of-habby" title="Permalink to this headline">¶</a></h2>
<p>In HABBY, it is possible to translate all strings which are in a python file (.py)
which is in the src_GUI folder.</p>
<p>To add a new string to translate:</p>
<ul class="simple">
<li>Code as usual and write the string in English.</li>
<li>Add self.tr() around the string  a = Qlabel(self.tr(“My message”))</li>
<li>If the code is in a new python file (like the .py was just created), open the habby_trans.pro file which is src_GUI. Then add the line SOURCES+= new_file.py where new_file.py is the new python file.</li>
<li>If you want to add a new language, add the line TRANSLATIONS += Zen_ES.ts in the case you want to add Spanish or any other language.</li>
<li>Copy the files ZEN_EN.ts and ZEN_FR.ts from HABBY/translation to /src_GUI</li>
<li>In the src_GUI folder, run the following command on the cmd: pylupdate5 habby_trans.pro. it will work if pylupdate is installed.</li>
<li>It should update the .ts file (which is an xml file)</li>
<li>Copy both .ts file back to HABBY/translation</li>
<li>Open Qt  linguist. This is a program that you need to install before. Open the French .ts file. The English should not need translation.</li>
<li>Translate as needed and save in Qt Linguist.</li>
<li>A .qm file is the binary representing the .ts file with all the translation. To create .qm file, type (in the cmd) lrelease  file.ts. It will create a file.qm file</li>
<li>Run HABBY. The string should be updated.</li>
</ul>
<p><strong>In the code</strong></p>
<p>If the user asked for a new language, we need to reload the translator with the following lines:</p>
<blockquote>
<div><p><em>app = QApplication.instance()</em></p>
<p><em>self.languageTranslator.load(file.qm, self.path_trans)</em></p>
<p><em>app.installTranslator(self.languageTranslator)</em></p>
</div></blockquote>
<p>with the appropriate name for “file.qm”.</p>
<p>In HABBY, the list of the name of all qm file are in the variable self.file_langue
in class MainWindows. Hence, we can follow the selected language using an integer self.lang
(0 for English and 1 for French). We can now call self.file_langue[self.lang] to get the qm
file in the right language. If a new language is added, it is necessary to add one string to this
list and to modify the menu. If the new language is also present in the xml preference file
(which contains the biological info), it is also necessary to update the variable &#8220;bioinfo_tab.lang&#8221;
from central_widget in the function setlangue from Main_Windows(). If this is done, the description of
the xml preference file in the &#8220;Biology&#8221; tab will be shown in the selected language. Otherwise, it will be
the first language found.</p>
<p>When the translator has been created, it is necessary to re-do all Widgets and Windows. This is not a problem when we open HABBY, but it can be a bit of work if the user asks for a change in language when HABBY is running. This is the function of the setlangue function. This function would work for all language (it takes an integer as input to know which language to use), but it needs to be modified if one modifies the Main_Windows Class strongly (notably if one add signals).
The language should be saved in the user setting using Qsettings as it is done at the end of the
setlangue function.</p>
<p>In addition, every xml project file from HABBY has a part called &#8220;FigureOPtion&#8221;. In the list of available options, there is the language currently used under the attibute &#8220;LangFig&#8221;. The language is given using an int (0 for english, 1 for french). This is useful to translate the axis and the titles of the figures done by HABBY. To this end, one would first called the function &#8220;load_fig_option&#8221; in output_fig_GUI.py. This returns a dictionnary with a key called &#8220;language&#8221; (0 for english, 1 for french). Then, one can use an if statement to write the xlabel in french or english.</p>
</div>
<div class="section" id="create-a-exe">
<h2>Create a .exe<a class="headerlink" href="#create-a-exe" title="Permalink to this headline">¶</a></h2>
<p>Here are step to create a .exe using PyInstaller:</p>
<ul class="simple">
<li>install Pyinstaller (pip install pyinstaller)</li>
<li>cd &#8220;folder with source code&#8221;</li>
<li>pyinstaller.exe [option] habby.py, with the option &#8211;onefile to get only one .exe and &#8211;windowed to not have the cmd which opens with the application.</li>
</ul>
<p>Here are some common problems:</p>
<ul class="simple">
<li>ImportError: (No module named &#8216;PyQt5.QtGui&#8217;): Copy the folder platform with qwindows.dll and add to the set_up.py  &#8220;includes&#8221;: [&#8220;PyQt5.QtCore&#8221;, &#8220;PyQt5.QtGui&#8221;]</li>
<li>This application fails to start because ... the Qt platform pugin windows: Copy the folder platform with qwindows.dll in it</li>
<li>ImportError: h5Py &#8220;includes&#8221;: [&#8220;h5py&#8221;,&#8221;h5py.defs&#8221;, &#8220;h5py.utils&#8221;, &#8220;h5py.h5ac&#8221;, &#8216;h5py._proxy&#8217; ] etc if necessary</li>
<li>Intel MKL fatal error copy the .dll missing (or just find an old dist and copy all mkl stuff) AND the libiomp5md.dll</li>
<li>The translation does not work: Add the translation folder into the dist folder</li>
<li>Do not find log0.txt (or crash when saving project): create a folder called src_GUI, copy the files log0.txt and restart_log0.txt from the src_GUI folder in the python module</li>
</ul>
<p>Practically:</p>
<ul class="simple">
<li>go to the folder called executable and copy the current HABBY source there.</li>
<li>copy createexe.bat in the habby folder.</li>
<li>run createexe.bat (only on Windows)</li>
<li>ignore the executable created in the &#8220;built&#8221; folder Use the one is in the &#8220;dist&#8221; folder.</li>
<li>copy all files in the mklall folder to the folder dist/habby.</li>
<li>copy all the files in the original src_GUI folder which are NOT python file to the src_GUI folder just created (or you know, improve the bat file...).</li>
<li>copy the doc folder in the dist/habby folder</li>
<li>run habby by writing habby on the cmd</li>
<li>test and correct problems. It can be long!</li>
</ul>
</div>
<div class="section" id="logging">
<h2>Logging<a class="headerlink" href="#logging" title="Permalink to this headline">¶</a></h2>
<p><strong>General information</strong></p>
<p>There are two different logs for HABBY. By default, the first one is called “name_projet”.log and
the second is called restart/_&#8217;name_project&#8217;.log. Their name and path can be changed in the xml
project file. Both file are text file.</p>
<p>The first log is in the form of a python file with comments. If python and the necessary modules
are installed on the machine, this log can be renamed “name.py” and started as a python file.
In the command line, the following command should be used: python name.py. This file can be
modified to create a new script to use HABBY in a different ways. For this, python syntax should be used.</p>
<p>The second log, called restart/_’name_project’.log, has limited functionalities but allows to
re-start the HABBY simulation from the command line, without the need for python.
Format of this file is described below. It is aimed to be readable and easily modifiable.
To use the restart file, type in the command line: python habby.py restart/_’name_project’.log.</p>
<p>This part genreally needs more revisions and tests.</p>
<p><strong>Type of log and format</strong></p>
<p>Currently, there are five types of outputs, which can be sent to the log:</p>
<ul class="simple">
<li>Comment, which should start with #. They will be sent to the python-type log file and to the GUI of Habby.</li>
<li>Errors, which should start with word “Error”. They will be sent to the python-type log file and to the GUI of Habby. In the GUI, they will appear in red.</li>
<li>Warnings, which should start with the word “Warning”. They will be sent to the python-type log file and to the GUI of Habby. In the GUI, they will appear in orange.</li>
<li>Restart info, which should start with the word “restart’. They will be sent to the restart_’name_project’.log. The format will be developed afterwards.</li>
<li>All types of text which do not start with these code words are only shown to the GUI of Habby.</li>
<li>Python code, which should start with the line py followed by four spaces.  It will be sent to the python-type log file. It is usually a function which is part of Habby code. The different arguments of the function should be given in the preceding lines.</li>
</ul>
<p><strong>Example</strong></p>
<p>Let’s write to the log a function which takes an integer and a string as input. The function
is in the module called habby1, which is imported by default in the .log file. The strings to send
as log would be:</p>
<ul class="simple">
<li>&#8220;#  this my fancy function&#8221;</li>
<li>&#8220;py    my_int = &#8221; + str(my_int_in_code)</li>
<li>&#8220;py    my_string = ’” + my_string_in_the _code+ &#8220;&#8217;“</li>
<li>&#8220;py    habby1.myfunc(my_int, my_string)&#8221;</li>
</ul>
<p>A comment should be added before each chunk of python code to improve the readability.</p>
<p><strong>Update the log</strong></p>
<p>Let’s consider a scenario where a new function has been written in a non-GUI module (class or
function) and has to be called in the GUI in a method of a class. Let’s call the new function
new_func and the class in the GUI my_class.</p>
<p>To create a new line of log for new_func, one should follow these steps:</p>
<ul class="simple">
<li>A PyQtsignal with a string as argument should be added to my_class: send_log = pyqtSignal(str, name=&#8217;send_log&#8217;)</li>
<li>If a log should be sent directly from my_class (for example, to say that new_func  has been called), the signal should be emitted: self.send_log.emit(&#8216;# new_func has been called&#8217;))</li>
<li>In the new function,  error and warning are written as follows: print(“Error: here is an error.n”) or print(“Warning:  This is just a warning.n”)</li>
<li>In my_class, error and warning are collected by redirecting stdout to a string. The following lines of code should be added around the calling of my_func():<ul>
<li>sys.stdout = mystdout = StringIO()  # redirect stdout</li>
<li>my_func(my_int,my_string)</li>
<li>sys.stdout = sys.__stdout__   # re-sent stdout to the cmd</li>
<li>str_found = mystdout.getvalue()   # get all warning, error, text,…</li>
<li>str_found = str_found.split(&#8216;n&#8217;)  # separate each message</li>
<li>for i in range(0, len(str_found)):<ul>
<li>if len(str_found[i]) &gt; 1:<ul>
<li>self.send_log.emit(str_found[i])  #send the text</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>To import StringIO, the following statement is needed at the start of the code: from io import StringIO</li>
<li>If new_func is called from the command line, stdout will not be redirected and the errors or warnings will be printed on the cmd as usual.  Stderr should be re-directed in a similar manner if needed.</li>
<li>The signal should be collected in the function connect_signal_log in the Main_Windows_1.py.  For this, a line should be added in the function:
*       self.my_class.send_log.connect(self.write_log)</li>
</ul>
<p><strong>restart file</strong></p>
<p>The format of the restart file is based on the format asked by the functions in func_for_cmd.py. More information on this format in func_for_cmd.py
(notably in the part list_command).</p>
</div>
<div class="section" id="git-code-management">
<h2>Git - code management<a class="headerlink" href="#git-code-management" title="Permalink to this headline">¶</a></h2>
<p><strong>Pour commencer:</strong></p>
<ul class="simple">
<li>Choisir un dossier sur l’ordinateur local ou va se trouver les fichiers sources.</li>
<li>cd  « dossier avec les codes source»</li>
<li>git config - - global user.name « username »</li>
<li>git config - - global user.email  « mail »</li>
<li>git init</li>
<li>lier le repertoire local avec le repertoire distant sur forge.irstea.fr</li>
</ul>
<p><strong>Pour mettre une nouvelle version sur le site web</strong></p>
<ul class="simple">
<li>cd « dossier avec les codes source»</li>
<li>git pull (prend la dernière version à jour sur le site et mets tous les fichiers ensemble) ou git fetch (prend juste les derniers fichiers sans mettre tous les fichiers ensemble).</li>
<li>git add ‘my_file.py ou .pyc’ (choisit les fichiers qui doivent être envoyé), le signe * fonctionne.</li>
<li>git log (donne l’historique)</li>
<li>git status (donne les nouveaux fichiers locals)</li>
<li>git commit –m « description » (commit localement)</li>
<li>git push</li>
</ul>
<p><strong>Pour ajouter une nouvelle branche</strong></p>
<ul class="simple">
<li>Donc pour avoir une partie du travail sépare du reste</li>
<li>git checkout –b [branchname] pour créer la branche et y travailler</li>
<li>git checkout [branchname] pour y travailler</li>
</ul>
</div>
<div class="section" id="write-the-documentation">
<h2>Write the documentation<a class="headerlink" href="#write-the-documentation" title="Permalink to this headline">¶</a></h2>
<p>Habby uses Sphinx to document the code. Sphinx uses the docstring given in each function. Hence, it is necessary to write a docstring for each function which has to be documented.</p>
<p>To update the html documentation, go to the doc folder and execute the command: “make html”.</p>
<p>To update the Latex documentation, use the commande &#8220;make latex&#8221; and use Miketex to create the pdf. rts2pdf does not work with Python 3.</p>
<p>To add text in the documentation, modify the index.rst file in the doc folder. To add a new module to the
documentation, add the module as written in the index.rts file in the doc folder. To add text comment, the index.rts file can also be direclty modified.</p>
<p>It is important to keep the formatting and the alignment.</p>
<p>If the module is in a new folder, the address of the folder must be added to the config.py file.
It is better to not use absolute path for this, so it is possible to move the documentation on another
computer. If the documentation does not run on a new computer, check the path given in the config.py file.</p>
<p>In the docstring, add as many blank lines as possible (in reasonable limit). This is easier for the
formatting. To make a bullet list, one should use a tab and the symbol &#8220;*&#8221;.  Using only the symbol &#8220;*&#8221; will
fail.</p>
<p>To add a new title, do not start the title or the line of symbol under the title with a blank space.</p>
</div>
<div class="section" id="license-of-used-python-modules">
<h2>License of used python modules<a class="headerlink" href="#license-of-used-python-modules" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>h5py: BSD License</li>
<li>Element tree (XML): MIT License</li>
<li>numpy: BSD License</li>
<li>matplotlib: BSD License</li>
<li>PyQt5: GNU License</li>
<li>Scipy: BSD license</li>
<li>shutil:</li>
</ul>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Welcome to HABBY&#8217;s documentation!</a></li>
<li><a class="reference internal" href="#how-to-execute-habby">How to execute HABBY</a></li>
<li><a class="reference internal" href="#main-and-source-code">Main(   ) and source code</a></li>
<li><a class="reference internal" href="#graphical-interface">Graphical interface</a><ul>
<li><a class="reference internal" href="#main-windows-of-habby">Main_windows of HABBY</a></li>
<li><a class="reference internal" href="#hydrological-information-gui">Hydrological information - GUI</a></li>
<li><a class="reference internal" href="#figure-option-gui">Figure Option - GUI</a></li>
<li><a class="reference internal" href="#the-stathab-model-gui">The Stathab model - GUI</a></li>
<li><a class="reference internal" href="#fstress-model-gui">FStress model - GUI</a></li>
<li><a class="reference internal" href="#estimhab-gui">Estimhab - GUI</a></li>
<li><a class="reference internal" href="#information-biological-and-run-habitat">Information Biological and Run habitat</a><ul>
<li><a class="reference internal" href="#biological-data-estimhab">Biological data - Estimhab</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#calculation-of-fish-s-habitat">Calculation of fish&#8217;s habitat</a><ul>
<li><a class="reference internal" href="#hec-ras-model-1d">Hec-ras model 1D</a><ul>
<li><a class="reference internal" href="#notes-on-hec-ras-outputs">Notes on hec-ras outputs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hec-ras-model-2d">Hec-ras model 2D</a></li>
<li><a class="reference internal" href="#mascaret">Mascaret</a></li>
<li><a class="reference internal" href="#river-2d">River 2D</a></li>
<li><a class="reference internal" href="#rubar">Rubar</a></li>
<li><a class="reference internal" href="#telemac">Telemac</a></li>
<li><a class="reference internal" href="#lammi">LAMMI</a></li>
<li><a class="reference internal" href="#load-habby-hdf5-file">Load HABBY hdf5 file</a><ul>
<li><a class="reference internal" href="#form-of-the-hdf5-files">Form of the hdf5 files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#velocity-distribution">Velocity distribution</a></li>
<li><a class="reference internal" href="#create-a-grid">Create a grid</a></li>
<li><a class="reference internal" href="#estimhab-source">Estimhab -source</a></li>
<li><a class="reference internal" href="#stathab-source">Stathab - source</a></li>
<li><a class="reference internal" href="#fstress-source">FStress - source</a></li>
<li><a class="reference internal" href="#substrate">Substrate</a></li>
<li><a class="reference internal" href="#merge-the-grid">Merge the grid</a></li>
<li><a class="reference internal" href="#biological-info">Biological Info</a></li>
<li><a class="reference internal" href="#calculation-habitat">Calculation habitat</a></li>
<li><a class="reference internal" href="#create-paraview-files">Create Paraview Files</a></li>
<li><a class="reference internal" href="#function-for-the-command-lines">Function for the command lines</a></li>
</ul>
</li>
<li><a class="reference internal" href="#various-notes">Various notes</a><ul>
<li><a class="reference internal" href="#figures-and-matplotlib">Figures and matplotlib</a></li>
<li><a class="reference internal" href="#translation-of-habby">Translation of HABBY</a></li>
<li><a class="reference internal" href="#create-a-exe">Create a .exe</a></li>
<li><a class="reference internal" href="#logging">Logging</a></li>
<li><a class="reference internal" href="#git-code-management">Git - code management</a></li>
<li><a class="reference internal" href="#write-the-documentation">Write the documentation</a></li>
<li><a class="reference internal" href="#license-of-used-python-modules">License of used python modules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">HABBY 1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Diane von Gunten, Yann Le Coarer and Fabrice Zaoui.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1.
    </div>
  </body>
</html>